{
  "document_id": "96682e33-0000-489d-a12a-2b9a92648d20",
  "content": "© 2020 Teradata. All rights reserved.\nLake - Monitor Resources and Performance\nRainer Geissendoerfer\nrainer.geissendoerfer@uderia.com\n11/27/2025\n© Teradata. All rights reserved.  However, you may combine your original work with publicly-available, Teradata-owned documentation to make a Custom Document; provided you limit\naccess to the Custom Document to you (and, if you are acting on behalf of a company, to that company for that company’s internal use).  TERADATA DISCLAIMS ALL\nREPRESENTATIONS, CONDITIONS, AND WARRANTIES OF ANY KIND (EXPRESS, IMPLIED, OR STATUTORY) WITH RESPECT TO THIS CUSTOM DOCUMENT. YOU AND PERSONS\nACCESSING THIS CUSTOM DOCUMENT BEAR THE ENTIRE RISK OF ANY RELIANCE ON THIS CUSTOM DOCUMENT, INCLUDING AS TO QUALITY, ACCURACY, AND RESULTS.\nMonitor Resources and Performance\nLearn about monitoring your system performance and managing your workloads.\nMonitoring Performance and Resource Usage\nYou can monitor current and past performance data, including ofﬂoading past resource usage and past query performance data into foreign tables in object storage.\nManaging Your Workloads\nVantageCloud Lake requires signiﬁcantly less workload management as compared to other Vantage offerings. Simplicity and ease of use, relying as much as possible on the\nnatural boundaries created by distinct primary clusters and compute clusters are primary characteristics.\nBring Your Own Viewpoint\nLearn how to connect your existing multisystem Viewpoint implementation and the primary cluster of a VantageCloud Lake environment.\nPerformance Monitoring and Workload Management APIs\nDescribes the Workload Management and Statitstics Management APIs and how to use them to interface with your custom applications when other tools (such as resource\nusage reports) or client applications do not provide the information you need.\nMonitoring Performance and Resource Usage\nUsing VantageCloud Lake you can monitor the following types of data:\nCurrent system-wide and query performance data. See Monitor Primary and Compute Cluster APIs.\nPast resource usage and query performance as trends or at certain days or times of day.\nLake - Monitor Resources and Performance\nPage 2 of 420To support analyzing trends, Vantage ofﬂoads past resource usage and past query performance data into foreign tables in object storage. These tables contain consolidated\ndata across your primary clusters and compute clusters, enabling you to monitor your compute resources to effectively manage them.\nMonitor Primary and Compute Cluster APIs\nMonitor Resource Usage\nMonitor Compute Cluster Events\nMonitor Queries\nQuery Monitoring Examples\nTroubleshooting: Query Logging Views for Teradata Employees\nMonitor Primary and Compute Cluster APIs\nThese single operational view APIs aggregate performance results from active primary clusters and compute clusters, allowing you to see performance numbers across all the\ndeployed and operational groups. This helps you measure performance of these operational groups and identify sessions that have a negative impact on performance.\nThey also provide a detailed view that provides additional columns to identify the group.\nSee the individual APIs for syntax and examples.\nMonitorAMPLoadSV\nThis single operational view API aggregates AMP load data across VantageCloud Lake clusters.\nMonitorPhysicalConﬁgSV\nThis single operational view API aggregates node availability data across VantageCloud Lake clusters.\nMonitorPhysicalResourceSV\nThis single operational view API aggregates node-speciﬁc RSS data across VantageCloud Lake clusters.\nMonitorSessionSV\nThis single operational view API can return session information across VantageCloud Lake clusters. The API can also be used to trace query sessions to a compute node.\nMonitorSQLCurrentStepSV\nUse this single operational view API for the SQL step being run on the currently running request across VantageCloud Lake clusters. You can then use this function to get\nadditional details on that session to monitor the current SQL step for the SQL run, provided it is a session that is running a query.\nMonitorSQLStepsSV\nUse this single operational view API for SQL steps being run across VantageCloud Lake clusters. Then use this function to get additional details on that session to monitor the\ncurrent SQL step for the SQL run, provided it is a session that is running a query.\nMonitorSQLTextSV\nUse this single operational view for the SQL text value for the current SQL step being run across VantageCloud Lake clusters. You can get additional details on that session to\nmonitor the SQL text for the current step, provided it is a session that is running a query.\nThere are additional APIs that monitor only primary clusters in VantageCloud Lake. See System PMPC PM/APIs and System PMPC Open APIs (SQL Interfaces).\nMonitor Resource Usage\nEach resource usage foreign table represents system usage data from a speciﬁc perspective collected during the logging period. The logging period is a system deﬁned interval of\ntime during which usage data is accumulated (speciﬁed in the NominalSecs column in each table). At the end of the logging interval, usage data is written to each of the resource\nusage foreign tables. Views have been created that are named similarly to the foreign tables in your object storage.\nUse resource usage views for these monitoring purposes:\nAnalyze disk and CPU usage\nProvide different perspectives on disk utilization\nCheck for bottlenecks\nProvide an overall history of the system operation\nMonitor the usage of AMP Worker Tasks (AWTs)\nForeign table deﬁnitions and view deﬁnitions reside in the td_metric_svc database.\nLearn about the data each resource usage view contains:\nresusagesawtV\nresusagescpuV\nresusageshstV\nresusagesldvV\nresusagespdskV\nresusagespmaV\nresusagespsV\nresusagesvdskV\nresusagesvprV\nThese views are not documented:\nresusagesmhmV is reserved for future use.\nresusagelpmaV and resusagelvprV are only used by Teradata personnel.\nresusa gesawtV\nDatabase: td_metric_svc\nIf you need detailed statistics for AMP Worker Tasks (AWT) per AMP in the system, use this view to:\nLake - Monitor Resources and Performance\nPage 3 of 420Get a historical view of AWT utilization across the system.\nGet the length of each AMP message queue (mailbox), the queue which holds work messages from the Dispatcher that are waiting to be serviced by an AMP Worker Task.\nGet the frequency and duration for which an AMP entered ﬂow control during the logging interval.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(7) LATIN NOT CASESPECIFIC NOT\nNULLX(7) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nvprId INTEGER NOT NULL -11(9) Identiﬁes the AMP vproc.\nLake - Monitor Resources and Performance\nPage 4 of 420View Column Data T ype Format Comment\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nMailBoxDepth FLOAT NOT NULL -(20)9 Current depth of the AMP work mailbox at\nthe end of the period.\nFlowControlled FLOAT NOT NULL -(20)9 If the value is non-zero, then the AMP is in\nﬂow control. Indicates ﬂow control on\nincoming mailbox for AMPs only: work\nmailbox name 2-11, where 2 is the mailbox\nnumber and 11 is the AMP Worker Task\npartition.\nFlowCtlCnt FLOAT NOT NULL -(20)9 Number of times during the log period that\nthe system entered the ﬂow control state\nfrom a non-ﬂow controlled state.\nFlowCtlTime FLOAT NOT NULL -(20)9 Total time, in milliseconds, that an AMP is in\nﬂow control.\nInuseMax FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at any one time during the log period.\nAvailable FLOAT NOT NULL -(20)9 Number of unreserved AMP Worker Tasks\nfrom the pool that are not being used at the\nend of the interval.\nAvailableMin FLOAT NOT NULL -(20)9 Minimum number of unreserved AMP\nWorker Tasks available in the pool for each\nAMP for the logged period. For example, a\nzero value means there were no unreserved\nAMP Worker Tasks available in the pool at\nsome point during the reporting period.\nAWTsConﬁgured FLOAT NOT NULL -(20)9 Current setting for AMP Worker Task (for\nexample, 80, 100, or so on).\nWorkTypeInuse00 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKNEW for the VprId vproc.\nWorkTypeInuse01 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKONE for the VprId vproc.\nWorkTypeInuse02 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKTWO for the VprId vproc.\nWorkTypeInuse03 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKTHREE for the VprId vproc.\nWorkTypeInuse04 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKFOUR for the VprId vproc. The\nWorkTypeInuse04 column value is at least 1\ndue to the internal database design for the\nControl AMP rows in the ResUsageSawt\ntable.\nWorkTypeInuse05 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKFIVE for the VprId vproc.\nWorkTypeInuse06 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKSIX for the VprId vproc.\nWorkTypeInuse07 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKSEVEN for the VprId vproc.\nWorkTypeInuse08 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKEIGHT for the VprId vproc.\nLake - Monitor Resources and Performance\nPage 5 of 420View Column Data T ype Format Comment\nWorkTypeInuse09 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKNINE for the VprId vproc.\nWorkTypeInuse10 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKTEN for the VprId vproc.\nWorkTypeInuse11 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKELEVEN for the VprId vproc.\nWorkTypeInuse12 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKABORT for the VprId vproc.\nWorkTypeInuse13 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKSPAWN for the VprId vproc.\nWorkTypeInuse14 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKNORMAL for the VprId vproc.\nWorkTypeInuse15 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nduring the log period for work type\nMSGWORKCONTROL for the VprId vproc.\nWorkTypeMax00 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKNEW for the VprId\nvproc.\nWorkTypeMax01 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKONE for the VprId\nvproc.\nWorkTypeMax02 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKTWO for the VprId\nvproc.\nWorkTypeMax03 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKTHREE for the VprId\nvproc.\nWorkTypeMax04 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKFOUR for the VprId\nvproc.\nWorkTypeMax05 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKFIVE for the VprId\nvproc.\nWorkTypeMax06 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKSIX for the VprId\nvproc.\nWorkTypeMax07 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKSEVEN for the VprId\nvproc.\nWorkTypeMax08 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKEIGHT for the VprId\nvproc.\nWorkTypeMax09 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKNINE for the VprId\nvproc.\nLake - Monitor Resources and Performance\nPage 6 of 420View Column Data T ype Format Comment\nWorkTypeMax10 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKTEN for the VprId\nvproc.\nWorkTypeMax11 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKELEVEN for the VprId\nvproc.\nWorkTypeMax12 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKABORT for the VprId\nvproc.\nWorkTypeMax13 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKSPAWN for the VprId\nvproc.\nWorkTypeMax14 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKNORMAL for the\nVprId vproc.\nWorkTypeMax15 FLOAT NOT NULL -(20)9 Maximum number of AMP Worker Tasks in\nuse at one time during the log period for\nwork type MSGWORKCONTROL for the\nVprId vproc.\nUnReservedAwtPoolSize FLOAT NOT NULL -(20)9 Total number of AWTs in the unreserved\nAWT pool.\nAvailableForWork00 FLOAT NOT NULL -(20)9 Unused limit of AWTs for work type 00 at\nend period.\nAvailableForWork08 FLOAT NOT NULL -(20)9 Unused limit of AWTs for work type 08 at\nend period.\nAvailableForWork00Min FLOAT NOT NULL -(20)9 The minimum value of AvailableForWork00\nover the entire period.\nAvailableForWork08Min FLOAT NOT NULL -(20)9 The minimum value of AvailableForWork08\nover the entire period.\nSpaceReactiveCnt FLOAT NOT NULL -(20)9 Current number of AMP worker tasks\nwaiting for reactive space allocations.\nSpaceReactiveWaitTime FLOAT NOT NULL -(20)9 Total time in milliseconds AMP worker tasks\nwere waiting for reactive space allocations.\nWorkTypeAWTExhausted00 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted01 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted02 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted03 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted04 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted05 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted06 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted07 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted08 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted09 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nLake - Monitor Resources and Performance\nPage 7 of 420View Column Data T ype Format Comment\nWorkTypeAWTExhausted10 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted11 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted12 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted13 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted14 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted15 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nresusa gescpuV\nDatabase: td_metric_svc\nIf you need detailed statistics for each CPU within the system, use this view to evaluate parallelism of CPUs within a node.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Number of seconds since midnight,\nJanuary 1, 1970.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nLake - Monitor Resources and Performance\nPage 8 of 420View Column Data T ype Format Comment\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(1) LATIN NOT CASESPECIFIC X(1) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\ncpuid SMALLINT NOT NULL -6(9) Identiﬁes the CPU within this node. The\nvalues are 0 through NCPUs-1. In Summary\nMode, the value is -1.\nCPUFrequencyMHz FLOAT NOT NULL -(20)9 CPU Frequencies in MHz.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nCPUIdle FLOAT NOT NULL -(20)9 Time in centiseconds the CPU is idle and\nnot waiting for I/O.\nCPUIoWait FLOAT NOT NULL -(20)9 Time in centiseconds CPU is waiting for I/O\ncompletion.\nCPUUServ FLOAT NOT NULL -(20)9 Time in centiseconds CPU is busy\nexecuting kernel system calls or servicing\nI/O and timer hardware interrupts.\nCPUUExec FLOAT NOT NULL -(20)9 Time in centiseconds CPU is busy\nexecuting user execution code, that is, time\nspent in a user state on behalf of a process.\nTDEnabled FLOAT NOT NULL -(20)9 Indicates whether the CPU is TD-enabled at\nthe end of the reporting period.\nresusa geshstV\nDatabase: td_metric_svc\nIf you need detailed statistics for each host channel and TCP/IP network used to communicate with the system, use this view to:\nIdentify patterns in inbound and outbound trafﬁc with the system.\nQuantify channel or network trafﬁc volume.\nVerify that all host channels are participating equally in communication between a host and the system.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\nLake - Monitor Resources and Performance\nPage 9 of 420View Column Data T ype Format Comment\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(3) LATIN NOT CASESPECIFIC NOT\nNULLX(3) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nIPaddr0 BIGINT NOT NULL -(20)9 Bytes 0-7 of the 16-byte IP address.\nIPaddr1 BIGINT NOT NULL -(20)9 Bytes 8-15 of the 16-byte IP address.\nHstType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Type of host connection:\nIBMECS (Part TCP/IP and channel\nhardware connection)\nIBMMUX (Channel hardware\nconnection)\nIBMNET (TCP/IP end-to-end, also\ncalled .pure network connection)\nNETWORK (Gateway connection)\nvprid INTEGER NOT NULL -11(9) For NETWORK HstType, it is the Gateway\nvproc ID.\nReservedS1 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Reserved for future use.\nhstid BIGINT NOT NULL -(20)9 IBMECS: RRRRRAAAUUUNNN,\nRRRRR=link, AAA=channel unit addr,\nUUU=logical control unit, NNN=logical\nchannel.\nLake - Monitor Resources and Performance\nPage 10 of 420View Column Data T ype Format Comment\nIBMNET: host group ID.\nNETWORK and IBMMUX: BBMMPPHHH,\nBB=bus, MM=module/chassis, PP=port,\nHHH=host group ID.\nHostReadKB FLOAT NOT NULL -(20)9 KB transferred in from the host.\nHostWriteKB FLOAT NOT NULL -(20)9 KB transferred out to the host.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nHostBlockReads FLOAT NOT NULL -(20)9 Number of message blocks (one or more\nmessages sent in one physical group)\nreceived from all clients.\nHostBlockWrites FLOAT NOT NULL -(20)9 Number of message blocks (that is, one or\nmore messages sent in one physical group)\nsent to all hosts.\nHostMessageReads FLOAT NOT NULL -(20)9 Number of messages read in from the host.\nHostMessageWrites FLOAT NOT NULL -(20)9 Number of messages written out to the\nhost.\nHostReadFails FLOAT NOT NULL -(20)9 Number of failures transmitting from the\nhost.\nHostWriteFails FLOAT NOT NULL -(20)9 Number of failures transmitting to the host.\nCmdTransactions FLOAT NOT NULL -(20)9 Number of transaction commands.\nCmdRequests FLOAT NOT NULL -(20)9 Number of request commands.\nCmdAlterStmts FLOAT NOT NULL -(20)9 Number of alter, modify, or drop statement\ncommands.\nCmdCreateStmts FLOAT NOT NULL -(20)9 Number of create or replace statement\ncommands.\nCmdDeleteStmts FLOAT NOT NULL -(20)9 Number of delete commands.\nCmdGrantStmts FLOAT NOT NULL -(20)9 Number of grant or revoke commands.\nCmdInsertStmts FLOAT NOT NULL -(20)9 Number of insert commands.\nCmdSelectStmts FLOAT NOT NULL -(20)9 Number of select commands.\nCmdUpdateStmts FLOAT NOT NULL -(20)9 Number of update commands.\nCmdArchUtilityStmts FLOAT NOT NULL -(20)9 Number of archival utility commands (for\nexample, restore, archive and recovery).\nCmdLoadUtilityStmts FLOAT NOT NULL -(20)9 Number of FastLoad and MultiLoad utility\ncommands. (Tpump commands cannot be\ndistinguished, and are therefore counted by\nthe INSERT, UPDATE and DELETE\nstatements).\nCmdOtherStmts FLOAT NOT NULL -(20)9 Number of other commands.\nCmdStmtSuccesses FLOAT NOT NULL -(20)9 Number of statements that departed\nnormally.\nCmdStmtFailures FLOAT NOT NULL -(20)9 Number of statements that departed\nnormally.\nCmdStmtErrors FLOAT NOT NULL -(20)9 Number of statements that departed in\nerror.\nresusa gesldvV\nDatabase: td_metric_svc\nIf you need detailed statistics for each logical disk device in the system, use this view to:\nEvaluate logical disk response times, read/write IO volume, and so on.\nCompare logical disk performance between nodes.\nValidate overall logical disk parallelism within a node or across the system.\nLake - Monitor Resources and Performance\nPage 11 of 420View Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged..\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Reserved for future use.\nReservedS1 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nPM_COD_IO SMALLINT NOT NULL -(6)9 Platform Metering IO COD value in whole\npercent. For example, a value of 50\nrepresents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nLake - Monitor Resources and Performance\nPage 12 of 420View Column Data T ype Format Comment\nvalue of 500 represents a COD value of\n50.0%.\nWM_COD_IO SMALLINT NOT NULL -(6)9 Workload Management IO COD value in\nwhole percent. For example, a value of 50\nrepresents a COD value of 50.0%.\nTIER_FACTOR SMALLINT NOT NULL -(6)9 I/O performance limit placed on a core-\nreduced node. For example, a value of 75\nrepresents an I/O limit of 75.0% placed\nbefore other COD values.\nctlid INTEGER NOT NULL -(11)9 Represents the controller number. The\nvalue is the decimal equivalent of the three\ndigit controller ID in the LdvId (the HHC\ndigits). If the controller information is not\navailable, its value is set to -1.\nldvid BYTE(4) NOT NULL X(8) LdvId is derived from the Host, Channel, Id,\nand Lun information of the device\n(00HHCTLL). If the device address\ninformation is not available, this column\ncontains the device major and minor\nnumber (for example, MMMmmmmm).\nLdvName CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Storage device name.\nLdvType CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of logical device. The value is either\nDISK for database disk or SDSK for system\ndisk.\nLdvKind CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) The device kind, SSD or HDD.\nMajor INTEGER NOT NULL -(11)9 Device major number.\nMinor INTEGER NOT NULL -(11)9 Device minor number.\nReservedS2 CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Reserved for future use.\nLdvOutReqSum FLOAT NOT NULL -(20)9 Time-weighted total of samples in\ncentiseconds spent doing I/O. Used to\ncalculate LdvOutReqAvg = LdvOutReqSum\n/ LdvOutReqDiv.\nLdvReadKB FLOAT NOT NULL -(20)9 Number of KB read from the logical device.\nLdvWriteKB FLOAT NOT NULL -(20)9 Number of KB written to the logical device.\nLdvReadRespTot FLOAT NOT NULL -(20)9 Total of individual read response times in\ncentiseconds.\nLdvWriteRespTot FLOAT NOT NULL -(20)9 Total of individual write response times in\ncentiseconds.\nFullPotentialIota FLOAT NOT NULL -(20)9 The full (total uninhibited) potential IOTAs\nfor device.\nCodPotentialIota FLOAT NOT NULL -(20)9 The potential IOTAs for device. These are\naccumulated only when an I/O is pending\non a device, and they are limited by the\nIO_COD setting.\nUsedIota FLOAT NOT NULL -(20)9 Used IOTAs for device.\nIoThrottleCount FLOAT NOT NULL -(20)9 Number of times that an I/O was throttled.\nIoThrottleTime FLOAT NOT NULL -(20)9 Total I/O Throttle Time in centiseconds.\nIoThrottleCntZeroIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nno IOTA tokens available in the bucket.\nIoThrottleCntInsuffIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket.\nIoThrottleCntInsuffIotasHL FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket for Hard Limits.\nLake - Monitor Resources and Performance\nPage 13 of 420View Column Data T ype Format Comment\nIoThrottleCntMaxQD FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nthe queue depth to the storage being at\nmaximum.\nFullPotentialIotaUnAdj FLOAT NOT NULL -(20)9 The unadjusted full potential input or output\ntoken allocations for a device.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nLdvOutReqDiv FLOAT NOT NULL -(20)9 Delta time in centiseconds for the sample.\nUsed to calculate LdvOutReqAvg =\nLdvOutReqSum / LdvOutReqDiv.\nLdvReads FLOAT NOT NULL -(20)9 Number of reads issued.\nLdvWrites FLOAT NOT NULL -(20)9 Number of writes issued.\nLdvOutReqTime FLOAT NOT NULL -(20)9 Total time in centiseconds with (any)\noutstanding requests. The value in this\ncolumn is less than or equal to the reported\nlogging period.\nresusa gespdskV\nDatabase: td_metric_svc\nIf you need detailed statistics for each physical disk (pdsk) in the system, use this view to:\nEvaluate response times for physical disks.\nCompare IO performed by physical disks across the system.\nAssess how physical disks are managing TVS activity.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Number of seconds since midnight,\nJanuary 1, 1970.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nLake - Monitor Resources and Performance\nPage 14 of 420View Column Data T ype Format Comment\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(1) LATIN NOT CASESPECIFIC X(1) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nPM_COD_IO SMALLINT NOT NULL -(6)9 Platform Metering IO COD value in whole\npercent. For example, a value of 50\nrepresents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nWM_COD_IO SMALLINT NOT NULL -(6)9 Workload Management IO COD value in\nwhole percent. For example, a value of 50\nrepresents a COD value of 50.0%.\nTIER_FACTOR SMALLINT NOT NULL -(6)9 I/O performance limit placed on a core-\nreduced node. For example, a value of 75\nrepresents an I/O limit of 75.0% placed\nbefore other COD values.\nPdiskGlobalId INTEGER NOT NULL -(11)9 Identiﬁes the pdisk in the system. Each\npdisk has a global ID which uniquely\nidentiﬁes the pdisk in the system. If a pdisk\nis connected to the nodes in a clique, all\nthe nodes in that clique see the same pdisk\nglobal ID associated with that pdisk.\nPdiskDeviceId BYTE(4) NOT NULL X(8) Identiﬁes the local pdisk device. For DISK\nand SSD pdisks, the ID can be a\nmajor/minor number. The major number bit\npositions are 20-31 and the minor number is\nin bits 0-19. (MMMM MMMM MMMM\nmmmm mmmm mmmm mmmm mmmm).\nFor FILE pdisk, the ID is 0xFFFFFFFF.\nPdiskType CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of pdisk can be one of the following:\nDISK: a storage device\nFILE: a ﬁle\nSSD: a solid-state device\nArrayName CHAR(32) LATIN NOT CASESPECIFIC NOT\nNULLX(32) Pdisk storage array name.\nReservedS1 CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Reserved for future use.\nReadKB FLOAT NOT NULL -20(9) Number of KB read from the logical device.\nWriteKB FLOAT NOT NULL -20(9) Number of KB written to the logical device.\nReadRespTot FLOAT NOT NULL -20(9) Total of individual read response time in\ncentiseconds.\nLake - Monitor Resources and Performance\nPage 15 of 420View Column Data T ype Format Comment\nWriteRespTot FLOAT NOT NULL -20(9) Total of individual write response time in\ncentiseconds.\nReadRespSq FLOAT NOT NULL -20(9) Total of squares of the individual read\nresponse time in centiseconds.\nWriteRespSq FLOAT NOT NULL -(20)9 Total of squares of the individual write\nresponse time in centiseconds.\nExtMigrateReadRespTot FLOAT NOT NULL -(20)9 Migration read I/O response time.\nExtMigrateWriteRespTot FLOAT NOT NULL -(20)9 Migration write I/O response time.\nExtMigrateIOTimeImprove FLOAT NOT NULL -(20)9.99 Estimates the percent improvement in\naverage I/O response time due to\nmigrations completing in the log interval. If\nthe average response time was 10 ms and\nExtMigrateIOTimeImprove is 10%, then\naverage response time is (100%-\n10%)*10ms = 9ms.\nDiskCacheReadCnt FLOAT NOT NULL -(20)9 Total number of 4KB blocks read.\nDiskCacheWriteCnt FLOAT NOT NULL -(20)9 Total number of 4KB blocks written.\nDiskCacheReadHitCnt FLOAT NOT NULL -(20)9 Number of 4KB blocks read from the disk\ncache.\nDiskCacheWriteHitCnt FLOAT NOT NULL -(20)9 Number of 4KB blocks written to the disk\ncache.\nDiskCacheFillCnt FLOAT NOT NULL -(20)9 Number of 4KB blocks ﬁlled to the disk\ncache due to PDISK read operation.\nDiskCacheInUseKB FLOAT NOT NULL -(20)9 Current KBs of disk cache in use.\nDiskCacheTotalKB FLOAT NOT NULL -(20)9 Total KBs of disk cache available for the\npdisk.\nRawReadRespTot FLOAT NOT NULL -(20)9 Total raw I/O Read Response Time in\ncentiseconds.\nRawWriteRespTot FLOAT NOT NULL -(20)9 Total raw I/O Write Response Time in\ncentiseconds.\nRawReadRespMax FLOAT NOT NULL -(20)9 Maximum raw I/O Read Response Time in\ncentiseconds.\nRawWriteRespMax FLOAT NOT NULL -(20)9 Maximum raw I/O Write Response Time in\ncentiseconds.\nIoThrottleCount FLOAT NOT NULL -(20)9 Number of times an I/O was throttled.\nIoThrottleTime FLOAT NOT NULL -(20)9 Total I/O Throttle Time in centiseconds.\nIoThrottleTimeMax FLOAT NOT NULL -(20)9 Maximum I/O Throttle Time in centiseconds.\nIoThrottleCntZeroIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nno IOTA tokens available in the bucket.\nIoThrottleCntInsuffIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket.\nIoThrottleCntInsuffIotasHL FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket for Hard Limits.\nIoThrottleCntMaxQD FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nthe queue depth to the storage being at\nmaximum.\nIoPrioStarvedCount FLOAT NOT NULL -(20)9 Number of prioritized I/Os that were starved\nand had their priority updated to alleviate\nstarvation.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nReadCnt FLOAT NOT NULL -(20)9 Number of logical device reads.\nWriteCnt FLOAT NOT NULL -(20)9 Number of logical device writes.\nLake - Monitor Resources and Performance\nPage 16 of 420View Column Data T ype Format Comment\nReadRespMax FLOAT NOT NULL -(20)9 Maximum of individual read response time\nin centiseconds.\nWriteRespMax FLOAT NOT NULL -(20)9 Maximum of individual write response time\nin centiseconds.\nConcurrentMax FLOAT NOT NULL -(20)9 Maximum number of concurrent I/O\nrequests.\nConcurrentReadMax FLOAT NOT NULL -(20)9 Maximum number of concurrent read I/O\nrequests.\nConcurrentWriteMax FLOAT NOT NULL -(20)9 Maximum number of concurrent write I/O\nrequests.\nMigrationBlockedIos FLOAT NOT NULL -(20)9 Number of inputs and outputs that are\nblocked due to migration request.\nExtAllocHot FLOAT NOT NULL -(20)9 Number of hot allocations made in the\ncurrent log period. A hot allocation is an\none whose estimated temperature falls\nwithin the pre-deﬁned hot temperature\nrange. Temperature is the frequency of\naccess to the data by I/O.\nExtAllocWarm FLOAT NOT NULL -(20)9 Number of warm allocations made in the\ncurrent log period. A warm allocation is an\nallocation whose estimated temperature\nfalls within the pre-deﬁned warm\ntemperature range. Temperature is the\nfrequency of access to the data by I/O.\nExtAllocTotal FLOAT NOT NULL -(20)9 Total number of allocations made in the\ncurrent log period.\nCold Allocation = ExtAllocTotal -ExtAllocHot\n-ExtAllocWarm\nQueryPacing Allocation = ExtAllocTotal -\nExtAllocNonPacing - ExtAllocSystemPacing\nDynamic Allocation = ExtAllocTotal -\nExtAllocStatic\nExtAllocNonPacing FLOAT NOT NULL -(20)9 Number of non-pacing allocations made in\nthe current log period. A non-pacing\nallocation is an allocation whose data\naccess affects neither system performance\nnor individual query performance.\nExtAllocSystemPacing FLOAT NOT NULL -(20)9 Number of system pacing allocations made\nin the current log period. A system pacing\nallocation is an allocation whose data\naccess affects system performance.\nExtAllocStatic FLOAT NOT NULL -(20)9 Number of static allocations made in the\ncurrent log period. A static allocation is an\nallocation whose requested temperature is\nused and the measured temperature is\nignored during migration.\nExtMigrateFaster FLOAT NOT NULL -(20)9 Number of cylinders migrated to a faster\nlocation on a device. The following formula\ncalculates a ExtMigrateSlower value, which\nis the number of cylinders migrated to\nslower locations:\nExtMigrateSlower = ExMigrateTotal -\nExMigrateFaster\nExtMigrateTotal FLOAT NOT NULL -(20)9 Total number of cylinders migrated to a\ndifferent physical location. For more\ninformation, see the ExtMigrateFaster ﬁeld.\nExtMigrateIOTimeCost FLOAT NOT NULL -(20)9 Estimates the total cost, in centiseconds,\nincurred by migration I/Os completing\nduring the log period, where cost is the\nLake - Monitor Resources and Performance\nPage 17 of 420View Column Data T ype Format Comment\nextra time waited by all non-migration I/Os\nas a result of the migration I/O.\nExtMigrateIOTimeBeneﬁt FLOAT NOT NULL -(20)9 Estimates the total I/O time savings\nachieved by migrations completing in the\nlog period. The I/O time savings include the\nimprovement in response time caused by\nthe new data arrangement up to the time\nhorizon.\nresusa gespmaV\nDatabase: td_metric_svc\nIf you need detailed statistics for each node in the system, use this view to:\nAggregate information to evaluate overall system CPU, IO, Memory, and Bynet utilization.\nEvaluate overall node level parallelism over time.\nCompare IO activity amongst the nodes.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nLake - Monitor Resources and Performance\nPage 18 of 420View Column Data T ype Format Comment\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nPM_COD_IO SMALLINT NOT NULL -(6)9 Platform Metering IO COD value in whole\npercent. For example, a value of 50\nrepresents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nWM_COD_IO SMALLINT NOT NULL -(6)9 Workload Management IO COD value in\nwhole percent. For example, a value of 50\nrepresents a COD value of 50.0%.\nTIER_FACTOR SMALLINT NOT NULL -(6)9 I/O performance limit placed on a core-\nreduced node. For example, a value of 75\nrepresents an I/O limit of 75.0% placed\nbefore other COD values.\nReserved00 SMALLINT NOT NULL -(6)9 Reserved for future use.\nReservedS0 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Reserved for future use.\nNCPUs SMALLINT NOT NULL -(6)9 Number of online CPUs on this node.\nVProc1 SMALLINT NOT NULL -(6)9 Current count of type 1 (AMP) virtual\nprocessors running on the node.\nVProc2 SMALLINT NOT NULL -(6)9 Current count of type 2 (PE) virtual\nprocessors running under the node.\nVProc3 SMALLINT NOT NULL -(6)9 Current count of type 3 (GTW) virtual\nprocessors running under the node.\nVProc4 SMALLINT NOT NULL -(6)9 Current count of type 4 (RSG) virtual\nprocessors running under the node.\nVProc5 SMALLINT NOT NULL -(6)9 Current count of type 5 (TVS) virtual\nprocessors running under the node.\nVProc6 SMALLINT NOT NULL -(6)9 Current count of type 6 virtual processors\nrunning under the node.\nVProc7 SMALLINT NOT NULL -(6)9 Current count of type 7 virtual processors\nrunning under the node.\nVProcType1 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc1. When\nthe vproc is present on the node, the value\nis AMP.\nVProcType2 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc2. When\nthe vproc is present on the node, the value\nis PE.\nVProcType3 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc3. When\nthe vproc is present on the node, the value\nis GTW.\nVProcType4 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc4. When\nthe vproc is present on the node, the value\nis RSG.\nVProcType5 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc5. When\nthe vproc is present on the node, the value\nis TVS.\nVProcType6 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc6.\nVProcType7 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of virtual processor for Vproc7.\nNodeNormFactor INTEGER NOT NULL Z(11)9 A per-CPU normalization factor that is used\nto normalize the reported CPU values of the\nResUsageSpma table to a single 5100\nLake - Monitor Resources and Performance\nPage 19 of 420View Column Data T ype Format Comment\nCPU. This value is scaled by a factor of\n100. If the actual factor is 5.25, then the\nvalue of the NodeNormFactor is 525.\nMemSize BIGINT NOT NULL -(20)9 Amount of memory on this node in\nmegabytes.\nReservedS1 CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Reserved for future use.\nProcPendMisc FLOAT NOT NULL -(20)9 Number of processes blocked pending\nmiscellaneous events.\nProcBlksTime FLOAT NOT NULL -(20)9 Number of process blocks waiting only for\ntimer expiration.\nProcWaitMsgRead FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending nonstep work.\nProcWaitTime FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending some amount of elapsed\ntime only.\nProcWaitMisc FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending miscellaneous events.\nMemFreeKB FLOAT NOT NULL -(20)9 Approximate amount of memory that is\navailable for use. The Linux operating\nsystem uses most free memory for buffers\nand caching to improve performance, but\nthe operating system can reclaim that\nmemory if it is needed by programs.\nMsgPtPReadKB FLOAT NOT NULL -(20)9 KB of net point-to-point messages input to\nprocesses on the node through the\nmessage subsystem\nMsgPtPWriteKB FLOAT NOT NULL -(20)9 KB of net point-to-point messages output\nfrom processes on the node through the\nmessage subsystem.\nMsgBrdReadKB FLOAT NOT NULL -(20)9 KB of net broadcast messages input to\nprocesses on the node through the\nmessage subsystem\nMsgBrdWriteKB FLOAT NOT NULL -(20)9 KB of net broadcast messages output from\nprocesses on the node through the\nmessage subsystem.\nMsgBrdWriteKB FLOAT NOT NULL -(20)9 KB of net broadcast messages output from\nprocesses on the node through the\nmessage subsystem.\nNetMsgPtPWriteKB FLOAT NOT NULL -(20)9 Amount of point-to-point message data in\nKB transmitted by both BYNETs.\nNetMsgBrdWriteKB FLOAT NOT NULL -(20)9 Amount of broadcast message data in KB\ntransmitted by both BYNETs.\nNetMsgPtPReadKB FLOAT NOT NULL -(20)9 Amount of point-to-point message data in\nKB received by both BYNETs.\nNetMsgBrdReadKB FLOAT NOT NULL -(20)9 Amount of broadcast message data in KB\nreceived by both BYNETs.\nNetRxKBPtP FLOAT NOT NULL -(20)9 Point-to-point KB received over all BYNETs.\nNetTxKBPtP FLOAT NOT NULL -(20)9 Point-to-point KB transmitted over all\nBYNETs.\nNetRxKBBrd FLOAT NOT NULL -(20)9 Broadcast KB received over all BYNETs.\nNetTxKBBrd FLOAT NOT NULL -(20)9 Broadcast KB transmitted over all BYNETs.\nNetMrgTxKB FLOAT NOT NULL -(20)9 Number of KB transmitted, without regard to\nwhich net, by merge transmission services\nfor currently active merge operations.\nNetMrgRxKB FLOAT NOT NULL -(20)9 Number of KB received, without regard to\nwhich net, by merge receive services for\ncurrently active merge operations.\nLake - Monitor Resources and Performance\nPage 20 of 420View Column Data T ype Format Comment\nNetMrgTxRows FLOAT NOT NULL -(20)9 Number of data rows transmitted, without\nregard to which net, by merge transmission\nservices for currently active merge\noperations.\nNetMrgRxRows FLOAT NOT NULL -(20)9 Number of data rows received, without\nregard to which net, by merge receive\nservices for currently active merge\noperations.\nHostReadKB FLOAT NOT NULL -(20)9 KB transferred in from the host.\nHostWriteKB FLOAT NOT NULL -(20)9 KB transferred out to the host.\nFileAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FileAcqs.\nFileAcqOtherKB FLOAT NOT NULL -(20)9 Number of scratch disk segments acquired\nin KB.\nFileAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileAcqReads\nFileRelKB FLOAT NOT NULL -(20)9 KB logically released by FileRels.\nFileRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch disk segments released\nin KB.\nFileWriteKB FLOAT NOT NULL -(20)9 KB physically written by FileWrites\nFilePreKB FLOAT NOT NULL -(20)9 Sum of the sizes of data blocks logically\nloaded with data prefetches (for example,\neither cylinder reads or individual block\nreads). For cylinder reads, this column does\nnot include the disk sectors in between the\nloaded data blocks.\nFilePreReadKB FLOAT NOT NULL -(20)9 Size of the data prefetch (cylinder section\nor individual blocks being read) that is\nphysically loaded from disk. For cylinder\nreads, this column includes the disk sectors\nin between the loaded data block.\nFileContigWIos FLOAT NOT NULL -(20)9 Number of I/Os done on the blocks that\nwere marked for contiguous write. By\ncalculating FileContigWBlocks /\nFileContigWIOs you can get the average\nnumber of blocks combined into a single\nI/O.\nFileContigWBlocks FLOAT NOT NULL -(20)9 Number of data blocks marked as\ncontiguous writable. When creating\nsequential blocks in-order, blocks are\nmarked as contiguous writable and aged to\nallow PDE to combine the write I/Os of such\nblocks.\nFileContigWKB FLOAT NOT NULL -(20)9 Size, in KB, of the blocks that were marked\nfor contiguous write. By calculating\nFileContigWKB / FileContigWBlocks you\ncan get the average size of the writes that\nwere candidates for combining.\nPSQWaitTime FLOAT NOT NULL -(20)9 Time in centiseconds that work requests\nwaited on an input queue before being\nserviced. To get an approximate average\nQWaitTime per request during this period,\ndivide QWaitTime by NumRequests.\nPSServiceTime FLOAT NOT NULL -(20)9 Time in centiseconds that work requests\nrequired for service. To get an approximate\naverage ServiceTime per request during\nthis period, divide ServiceTime by\nNumRequests.\nTvsReadCnt FLOAT NOT NULL -(20)9 Number of logical device reads. The\nTvsReadCnt column is a summary of the\nReadCnt column in the SPDSK table.\nTvsWriteCnt FLOAT NOT NULL -(20)9 Number of logical device writes.\nLake - Monitor Resources and Performance\nPage 21 of 420View Column Data T ype Format Comment\nTvsReadRespTot FLOAT NOT NULL -(20)9 Total of individual read response time in\ncentiseconds.\nTvsWriteRespTot FLOAT NOT NULL -(20)9 Total of individual write response time in\ncentiseconds.\nFullPotentialIota FLOAT NOT NULL -(20)9 Sum of full (total uninhibited) potential\nIOTAs from all devices attached to this\nnode. These are NOT limited by the IO COD\nsetting.\nCodPotentialIota FLOAT NOT NULL -(20)9 Sum of potential IOTAs from all devices\nattached to this node. These are\naccumulated only when an I/O is pending\non a device, and they are limited by the\nIO_COD setting.\nUsedIota FLOAT NOT NULL -(20)9 Sum of used IOTAs from all devices\nattached to this node.\nCpuThrottleCount FLOAT NOT NULL -(20)9 Number of times that WM CPU COD\nthrottling was triggered\nCpuThrottleTime FLOAT NOT NULL -(20)9 Time in centiseconds that WM CPU COD\nthrottling was active.\nVHCacheKB FLOAT NOT NULL -(20)9 Current size of the VH Cache in KB.\nNLBMsgFlowControlledKB FLOAT NOT NULL -(20)9 KB of segment memory in use by ﬂow\ncontrolled Node Level Buffered messages.\nNetActiveMrgKB FLOAT NOT NULL -(20)9 Current memory usages by BYNET merge\njobs.\nKernMemInuseKB FLOAT NOT NULL -(20)9 KB of kernel memory in use by PDE.\nSegMDLInuseKB FLOAT NOT NULL -(20)9 Total memory in use by segment MDLs.\nFsgCacheKB FLOAT NOT NULL -(20)9 Allocated memory for FSG cache.\nPageScanDirects FLOAT NOT NULL -(20)9 Number of pages scanned directly in kernel\non user context to locate free memory.\nPageScanKswapds FLOAT NOT NULL -(20)9 Number of pages scanned by kswapd\ndaemon to locate free memory.\nPageMajorFaults FLOAT NOT NULL -(20)9 Number of major page faults (page was not\nin memory).\nPageMinorFaults FLOAT NOT NULL -(20)9 Number of minor page faults (page was still\nin memory).\nSlabCacheKB FLOAT NOT NULL -(20)9 Current KB of memory cache managed by\nthe Linux slab allocator.\nDiskCacheInUseKB FLOAT NOT NULL -(20)9 Current KBs of disk cache in use.\nDiskCacheTotalKB FLOAT NOT NULL -(20)9 Total KBs of disk cache available for the\npdisk.\nPageCacheKB FLOAT NOT NULL -(20)9 Current KB of Linux page cache.\nIoThrottleCount FLOAT NOT NULL -(20)9 Number of times an I/O was throttled.\nIoThrottleTime FLOAT NOT NULL -(20)9 Total I/O Throttle Time in milliseconds.\nIoThrottleTimeMax FLOAT NOT NULL -(20)9 Maximum I/O Throttle Time in milliseconds.\nIoThrottleCntZeroIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nno IOTA tokens available in the bucket.\nIoThrottleCntInsuffIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket.\nIoThrottleCntInsuffIotasHL FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket for Hard Limits.\nIoThrottleCntMaxQD FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nthe queue depth to the storage being at\nmaximum.\nLake - Monitor Resources and Performance\nPage 22 of 420View Column Data T ype Format Comment\nNosTables FLOAT NOT NULL -(20)9 Number of Native Object Store tables\naccessed. Access through READ_NOS\ndoes not increment this column, although it\ndoes increment the other NOS columns.\nNosPhysReadIOs FLOAT NOT NULL -(20)9 Number of physical read IOs issued against\nNative Object Store tables.\nNosPhysReadIOKB FLOAT NOT NULL -(20)9 Total KB physically read from Native Object\nStore tables.\nNosFiles FLOAT NOT NULL -(20)9 Number of Native Object Store ﬁles read in\nsatisfying queries against Native Object\nStore tables.\nNosFilesSkipped FLOAT NOT NULL -(20)9 Number of Native Object Store ﬁles (or\npartial ﬁles) skipped due to errors.\nNosRecordsReturned FLOAT NOT NULL -(20)9 Number of records returned in satisfying\nqueries against Native Object Store tables.\nNosRecordsReturnedKB FLOAT NOT NULL -(20)9 Total KB of records returned from Native\nObject Store ﬁles.\nNosRecordsSkipped FLOAT NOT NULL -(20)9 Number of Native Object Store records\nskipped due to errors\nNosTotalIOWaitTime FLOAT NOT NULL -(20)9 Total time in seconds waiting for IOs when\nreading Native Object Store ﬁles.\nNosMaxIOWaitTime FLOAT NOT NULL -(20)9 Maximum single IO wait time in seconds\nwhen reading Native Object Store ﬁles.\nNosCPUTime FLOAT NOT NULL -(20)9 Total CPU time in seconds spent\ndecompressing, translating, or otherwise\nprocessing Native Object Store data as part\nof reading it. This time is already included in\nother non-NOS CPU ﬁelds.\nProcBlksMsgReadAwt FLOAT NOT NULL -(20)9 Number of process blocks for non-step\nwork (AWT only).\nProcPendNetReadAwt FLOAT NOT NULL -(20)9 Number of processes blocked pending\nnon-step work, that is, the number of\nprocesses blocked on any mailbox other\nthan the work mailbox (AWT only).\nNodeMbs FLOAT NOT NULL -(20)9 I/O capacity conﬁgured for a node in MB/s\nbased on a 96k 90/10 R/W workload not\nadjusted for COD.\nIoPrioStarvedCount FLOAT NOT NULL -(20)9 Number of prioritized I/Os that were starved\nand had their priority updated to alleviate\nstarvation.\nProcWaitMsgReadAwt FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending nonstep work (AWT only).\nNosFilesWritten FLOAT NOT NULL -(20)9 Number of ﬁle writes attempted by Native\nObject Store.\nNosPhysWriteIOs FLOAT NOT NULL -(20)9 Total physical write IOs for Native Object\nStore ﬁles.\nNosPhysWriteIOKB FLOAT NOT NULL -(20)9 Total KB of physical write IOs for Native\nObject Store ﬁles.\nFullPotentialIotaUnAdj FLOAT NOT NULL -(20)9 Sum of the unadjusted full potential input or\noutput token allocations from all devices\nattached to the node.\nNosPhysDataReadIO FLOAT NOT NULL -(20)9 Number of Physical Data IO Reads for\nNative Object Store.\nNosPhysDataReadIOKB FLOAT NOT NULL -(20)9 Total KBs of physical data read for Native\nObject Store.\nNosCacheReadIO FLOAT NOT NULL -(20)9 Number of Cache Data IO Reads for Native\nObject Store.\nLake - Monitor Resources and Performance\nPage 23 of 420View Column Data T ype Format Comment\nNosCacheReadIOKB FLOAT NOT NULL -(20)9 Total KBs of cache data read for Native\nObject Store.\nNosSpCIsReturned FLOAT NOT NULL -(20)9 Number of NOS Spool CIs returned by a\nNative Object Store spool request.\nNosSpCIsReturnedKB FLOAT NOT NULL -(20)9 Total KB of CIs returned for Native Object\nStore spool requests.\nNosSpDBChunksReturned FLOAT NOT NULL -(20)9 Number of NOS Spool Datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBChunksReturnedKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool Datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBsReturned FLOAT NOT NULL -(20)9 Number of NOS Spool Datablocks returned\nby a Native Object Store spool request.\nNosSpDBsReturnedKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool Datablocks returned\nby a Native Object Store spool request.\nNosSpBlksFSGAcqs FLOAT NOT NULL -(20)9 Number of NOS Spool Datablocks read\nfrom FSG.\nNosSpBlksFSGAcqsKB FLOAT NOT NULL -(20)9 Total KB of the Number of NOS Spool\nDatablocks read from FSG.\nNosSpTablesRead FLOAT NOT NULL -(20)9 Number of NOS Spool tables accessed.\nThis value is the same as the number of\nNOS Spool MIs read.\nNosSpTablesWritten FLOAT NOT NULL -(20)9 Number of NOS spool tables written. This\ncorresponds to the number of TMIs written.\nNosSpCIsWritten FLOAT NOT NULL -(20)9 Number of NOS Spool CIs written.\nNosSpCIsWrittenKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool CIs written.\nNosSpDBChunksWritten FLOAT NOT NULL -(20)9 Number of NOS spool DB chunks written.\nNosSpDBChunksWrittenKB FLOAT NOT NULL -(20)9 Total KB of NOS spool DB chunks written.\nNosSpDBsWritten FLOAT NOT NULL -(20)9 Number of NOS DBs written.\nNosSpDBsWrittenKB FLOAT NOT NULL -(20)9 Total KB of NOS spool DBs written.\nRDFCShrink FLOAT NOT NULL -(20)9 Count of times the RDFC Shrink action was\ninvoked.\nRDFCShrinkKB FLOAT NOT NULL -(20)9 Volume of unused FSG cache\nunpinned/freed up (in KB) for a shrink\naction.\nRDFCGrow FLOAT NOT NULL -(20)9 Count of times the RDFC grow action was\ninvoked.\nRDFCGrowKB FLOAT NOT NULL -(20)9 Volume of FSG Cache re-pinned/acquired\n(in KB) for the RDFC grow action.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nProcReadyMax FLOAT NOT NULL -(20)9 Maximum number of ready tasks, also\ncalled threads, able to run on CPUs when a\nCPU becomes available.\nProcReady FLOAT NOT NULL -(20)9 Number of runnable or ready tasks, also\ncalled threads, able to run on CPUs when a\nCPU becomes available.\nProcBlocked FLOAT NOT NULL -(20)9 Number of threads blocked waiting for I/O\nat the current time.\nProcPendMemAlloc FLOAT NOT NULL -(20)9 Number of processes blocked pending\nmemory allocations\nProcPendFsgRead FLOAT NOT NULL -(20)9 Number of processes blocked pending a\nFile Segment (FSG) read from disk.\nLake - Monitor Resources and Performance\nPage 24 of 420View Column Data T ype Format Comment\nProcPendFsgWrite FLOAT NOT NULL -(20)9 Number of processes blocked pending an\nFSG write to disk.\nProcPendNetThrottle FLOAT NOT NULL -(20)9 Number of processes blocked pending\ndelivery of outstanding outgoing messages.\nProcPendNetRead FLOAT NOT NULL -(20)9 Number of processes blocked pending\nnon-step work, that is, the number of\nprocesses blocked on any mailbox other\nthan the work mailbox.\nProcPendMonitor FLOAT NOT NULL -(20)9 Number of processes blocked pending a\nuser monitor.\nProcPendMonResume FLOAT NOT NULL -(20)9 Number of processes blocked pending a\nuser monitor resume from a yield.\nProcPendDBLock FLOAT NOT NULL -(20)9 Number of processes blocked pending\ndatabase locks.\nProcPendSegLock FLOAT NOT NULL -(20)9 Number of processes blocked pending a\nsegment lock.\nProcPendFsgLock FLOAT NOT NULL -(20)9 Number of processes blocked pending an\nFSG lock\nProcPendQnl FLOAT NOT NULL -(20)9 Number of processes blocked pending a\nTSKQNL lock.\nProcBlksMemAlloc FLOAT NOT NULL -(20)9 Number of process blocks for memory\nallocations.\nProcBlksFsgRead FLOAT NOT NULL -(20)9 Number of process blocks for an FSG read\nfrom disk.\nProcBlksFsgWrite FLOAT NOT NULL -(20)9 Number of process blocks for an FSG write\nto disk.\nNetSemInUse FLOAT NOT NULL -(20)9 Number of semaphores in use at the current\ntime.\nNetChanInUse FLOAT NOT NULL -(20)9 Number of channels in use at the current\ntime.\nNetGroupInUse FLOAT NOT NULL -(20)9 Number of groups in use at the current\ntime. This number is same across all nodes.\nProcBlksNetThrottle FLOAT NOT NULL -(20)9 Number of process blocks for delivery of\noutstanding outgoing messages.\nProcBlksMsgRead FLOAT NOT NULL -(20)9 Number of process blocks for non-step\nwork.\nProcBlksMonitor FLOAT NOT NULL -(20)9 Number of process blocks for a user\nmonitor.\nProcBlksMonResume FLOAT NOT NULL -(20)9 Number of process blocks for a user\nmonitor resume from a yield\nProcBlksDBLock FLOAT NOT NULL -(20)9 Number of process blocks for database\nlocks. The AMP Worker Task can do other\nwork while the lock is blocked.\nProcBlksSegLock FLOAT NOT NULL -(20)9 Number of process blocks for a disk or task\ncontext (for example, scratch, stack, and so\non) segment lock.\nProcBlksMisc FLOAT NOT NULL -(20)9 Number of process blocks for\nmiscellaneous events.\nProcBlksFsgLock FLOAT NOT NULL -(20)9 Number of process blocks for an FSG lock.\nProcBlksQnl FLOAT NOT NULL -(20)9 Number of process blocks for a TSKQNL\nlock.\nProcWaitMemAlloc FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending memory allocations.\nProcWaitPageRead FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending a page read from disk.\nProcWaitFsgRead FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending an FSG read from disk.\nLake - Monitor Resources and Performance\nPage 25 of 420View Column Data T ype Format Comment\nProcWaitFsgWrite FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending an FSG lock.\nProcWaitNetThrottle FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending delivery of outstanding\noutgoing messages.\nProcWaitMonitor FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending a user monitor.\nProcWaitMonResume FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending a user monitor resume\nfrom a yield.\nProcWaitDBLock FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending database locks\nProcWaitSegLock FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending a disk or task context (for\nexample, scratch, stack, and so on)\nsegment lock.\nProcWaitFsgLock FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending an FSG lock.\nProcWaitQnl FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending a TSKQNL lock.\nCPUIdle FLOAT NOT NULL -(20)9 Time in centiseconds CPUs are idle and not\nwaiting for I/O.\nCPUIoWait FLOAT NOT NULL -(20)9 Time in centiseconds CPUs are idle and\nwaiting for I/O completion.\nCPUUServ FLOAT NOT NULL -(20)9 Time in centiseconds CPUs are busy\nexecuting user service code, that is,\nprivileged work performing system services\non behalf of user execution processes\nwhich do not have root access. CPUUServ\nreports if a task used CPU while in the\nkernel.\nCPUUExec FLOAT NOT NULL -(20)9 Time in centiseconds CPUs are busy\nexecuting user execution code, that is, time\nspent in a user state on behalf of a process.\nCPUProcSwitches FLOAT NOT NULL -(20)9 Number of times the scheduler switched a\ncurrently active process of a CPU to a new\nprocess.\nMemVprAllocKB FLOAT NOT NULL -(20)9 Change in memory. MemVprAllocKB\nrepresents a delta from the previous\nreporting period and reports negative\nvalues as less memory is used.\nMemTextPageReads FLOAT NOT NULL -(20)9 Number of pages paged minus the pages\nswapped in.\nMemCtxtPageWrites FLOAT NOT NULL -(20)9 Number of pages swapped out.\nMemCtxtPageReads FLOAT NOT NULL -(20)9 Number of pages swapped in.\nMsgPtPReads FLOAT NOT NULL -(20)9 Number of net point-to-point messages\ninput to processes on the node through the\nmessage subsystem.\nMsgPtPWrites FLOAT NOT NULL -(20)9 Number of net point-to-point messages\noutput from processes on the node through\nthe message subsystem.\nMsgBrdReads FLOAT NOT NULL -(20)9 Number of net broadcast messages input\nto processes on the node through the\nmessage subsystem.\nMsgBrdWrites FLOAT NOT NULL -(20)9 Number of net broadcast messages output\nfrom processes on the node through the\nmessage subsystem\nNetTxRouting FLOAT NOT NULL -(20)9 Number of samples showing the transmitter\nrouting on a BYNET.\nLake - Monitor Resources and Performance\nPage 26 of 420View Column Data T ype Format Comment\nNetTxConnected FLOAT NOT NULL -(20)9 Number of samples showing the transmitter\nconnected on a BYNET.\nNetRxConnected FLOAT NOT NULL -(20)9 Number of samples showing the receiver\nconnected on a BYNET.\nNetTxIdle FLOAT NOT NULL -(20)9 Number of samples showing the transmitter\nidle on a BYNET.\nNetRxIdle FLOAT NOT NULL -(20)9 Number of samples showing the receiver\nidle on a BYNET.\nNetSamples FLOAT NOT NULL -(20)9 Sample count for sampled statistics for a\nBynet. NetSamples is used to normalize all\nnet time monitored statistics to a percent-of-\ntime basis. For example, dividing\n(NetTxIdle/NetSamples) yields the\ntransmitter-idle time ratio for the net\nstatistics.\nNetMsgPtPWrites FLOAT NOT NULL -(20)9 Number of point-to-point messages\ntransmitted by both BYNETs.\nNetMsgBrdWrites FLOAT NOT NULL -(20)9 Number of broadcast messages\ntransmitted by both BYNETs.\nNetMsgPtPReads FLOAT NOT NULL -(20)9 Number of point-to-point messages\nreceived by both BYNETs.\nNetMsgBrdReads FLOAT NOT NULL -(20)9 Number of broadcast messages received\nby both BYNETs.\nNetMrgBlock FLOAT NOT NULL -(20)9 Number of times a merge message was\nblocked until delivery of outstanding\noutgoing messages.\nNetMsgChannelBlock FLOAT NOT NULL -(20)9 Number of times the net software was\nblocked because the channel was not in\nRxReady state on the receiver.\nNetMsgGroupBlock FLOAT NOT NULL -(20)9 Number of times the net software was\nblocked because the receiver could not\nimplicitly enter the group.\nNetMsgResourceBlock FLOAT NOT NULL -(20)9 Number of times the net software was\nblocked because the receiver could not get\nthe necessary resources.\nNetMsgFCBlock FLOAT NOT NULL -(20)9 Number of times the net software was\nblocked because the receiver was ﬂow-\ncontrolled.\nNetMsgRxBlock FLOAT NOT NULL -(20)9 Number of times the net software could not\naccept a message and caused a\ntransmitter to block.\nNetBlockQueueTotal FLOAT NOT NULL -(20)9 Total number of services added to the\nBlockableServices queue in this interval.\nNetBlockQueueMax FLOAT NOT NULL -(20)9 Maximum number of services on the\nBlockableServices queue in this interval.\nNetBlockQueue FLOAT NOT NULL -(20)9 Total number of services on the\nBlockableService queue at the current time.\nNetTxCircHPBrd FLOAT NOT NULL -(20)9 Number of high priority broadcast circuits\ntransmitted on all BYNETs.\nNetRxCircPtP FLOAT NOT NULL -(20)9 Number (both normal and high priority) of\npoint-to-point circuits received on all\nBYNETs.\nNetTxCircHPPtP FLOAT NOT NULL -(20)9 Number of high priority point-to-point\ncircuits transmitted on all BYNETs.\nNetRxCircBrd FLOAT NOT NULL -(20)9 Number (both normal and high priority) of\nbroadcast circuits received on all BYNETs.\nNetTxCircBrd FLOAT NOT NULL -(20)9 Number (both normal and high priority) of\nbroadcast circuits transmitted on all\nBYNETs.\nLake - Monitor Resources and Performance\nPage 27 of 420View Column Data T ype Format Comment\nNetBackoffs FLOAT NOT NULL -(20)9 Software backoffs, deﬁned as BNS service\nblocked occurrences, without regard for\nwhich net was involved.\nNetSemInUseMax FLOAT NOT NULL -(20)9 Maximum number of semaphores in use.\nNetChanInUseMax FLOAT NOT NULL -(20)9 Maximum number of channels in use.\nNetGroupInUseMax FLOAT NOT NULL -(20)9 Maximum number of groups in use.\nNetHWBackoffs FLOAT NOT NULL -(20)9 Hardware backoffs reported by the BLM for\nall BYNETs.\nNetTxCircPtP FLOAT NOT NULL -(20)9 Number (both normal and high priority) of\npoint-to-point circuits transmitted on all\nBYNETs.\nHostBlockReads FLOAT NOT NULL -(20)9 Number of blocks read in from the host.\nHostBlockWrites FLOAT NOT NULL -(20)9 Number of blocks written out to the host.\nHostMessageReads FLOAT NOT NULL -(20)9 Number of messages read in from the host.\nHostMessageWrites FLOAT NOT NULL -(20)9 Number of messages written out to the\nhost.\nDBLockBlocks FLOAT NOT NULL -(20)9 Number of times a database lock was\nblocked.\nDBLockDeadlocks FLOAT NOT NULL -(20)9 Number of times a database lock was\ndeadlocked.\nFileAcqs FLOAT NOT NULL -(20)9 Number of disk segments acquires that\nwere logically acquired. Only the FileAcqs\ncolumn is counted as a cache hit.\nFileAcqsOther FLOAT NOT NULL -(20)9 Number scratch disk segments that were\nlogically acquired.\nFileAcqReads FLOAT NOT NULL -(20)9 Number of disk segment acquired that\ncaused a physical read.\nFileRels FLOAT NOT NULL -(20)9 Number of disk segments released by\ntasks.\nFileRelsOther FLOAT NOT NULL -(20)9 Number of scratch disk segments released\nas part of them being deleted.\nFileWrites FLOAT NOT NULL -(20)9 Number of disk segment immediate or\ndelayed physical writes.\nFilePres FLOAT NOT NULL -(20)9 Number of times a logical data prefetch\nwas performed (either as a cylinder read or\nindividual block reads).\nFilePreReads FLOAT NOT NULL -(20)9 Number of times a data prefetch was\nphysically performed either as a cylinder\nread or individual blocks read.\nFileLockBlocks FLOAT NOT NULL -(20)9 Number of lock requests that were blocked\nFileLockDeadlocks FLOAT NOT NULL -(20)9 Number of deadlocks detected on lock\nrequests.\nFileLockEnters FLOAT NOT NULL -(20)9 Number of times a lock was requested.\nFileSmallDepotWrites FLOAT NOT NULL -(20)9 Number of small writes to the depot\nperformed to protect in-place modiﬁcations.\nEach small Depot write protects a single in-\nplace write of either a write ahead logging\n(WAL) data block or a database data block.\nFileLargeDepotWrites FLOAT NOT NULL -(20)9 Number of large writes to the depot\nperformed to protect in-place modiﬁcations.\nEach large Depot write protects multiple in-\nplace writes of either WAL data blocks or\ndatabase data blocks.\nFileLargeDepotBlocks FLOAT NOT NULL -(20)9 Total number of blocks (either WAL or\ndatabase) that have been protected by\nlarge Depot writes. The average number of\nblocks protected by each large Depot write\nLake - Monitor Resources and Performance\nPage 28 of 420View Column Data T ype Format Comment\n= FileLargeDepotBlocks /\nFileLargeDepotWrites.\nMsgChnLastDone FLOAT NOT NULL -(20)9 Number of last done events that occurred\non this node.\nThe last AMP to ﬁnish an operation may\nsend a last done broadcast message\nindicating the work is done for this step.\nThis is used in tracking down the slowest\nnode or AMP in the system.\nCmdDDLStmts FLOAT NOT NULL -(20)9 Number of alter, modify, drop, create,\nreplace, grant or revoke commands.\nCmdDeleteStmts FLOAT NOT NULL -(20)9 Number of delete commands.\nCmdInsertStmts FLOAT NOT NULL -(20)9 Number of insert commands.\nCmdSelectStmts FLOAT NOT NULL -(20)9 Number of select commands.\nCmdUpdateStmts FLOAT NOT NULL -(20)9 Number of update commands.\nCmdUtilityStmts FLOAT NOT NULL -(20)9 Number of utility commands.\nCmdOtherStmts FLOAT NOT NULL -(20)9 Number of other commands.\nCmdStmtSuccesses FLOAT NOT NULL -(20)9 Number of statements that departed\nnormally.\nCmdStmtFailures FLOAT NOT NULL -(20)9 Number of statements that departed in\nfailure or were aborted.\nCmdStmtErrors FLOAT NOT NULL -(20)9 Number of statements that departed in\nerror.\nAmpsFlowControlled FLOAT NOT NULL -(20)9 Number of AMPs currently in ﬂow control on\nthe work input mailbox.\nFlowCtlCnt FLOAT NOT NULL -(20)9 Number of times this period that the node\nentered the ﬂow control state from a non-\nﬂow controlled state.\nAwtInuse FLOAT NOT NULL -(20)9 Number of AMP Worker Tasks currently in\nuse for this node.\nAwtInuseMax FLOAT NOT NULL -(20)9 Peak number of AMP Worker Tasks (Max)\non this node. This is not the Peak or the Max\nvalue stored in the Priority Scheduler (sch)\ndata structure and reported by the puma\nutility.\nPSNumRequests FLOAT NOT NULL -(20)9 Number of work requests received for all\nPerformance Groups on this node.\nTvsReadRespMax FLOAT NOT NULL -(20)9 Maximum read response time value during\nthe reporting period.\nTvsWriteRespMax FLOAT NOT NULL -(20)9 Maximum response time of logical device\nwrites during the reporting period.\nNLBActiveSessionsMax FLOAT NOT NULL -(20)9 Maximum concurrent Node Level Buffering\nsessions.\nNLBSessionsInuse FLOAT NOT NULL -(20)9 Current number of active Node Level\nBuffering sessions.\nNLBSessionsCompleted FLOAT NOT NULL -(20)9 Number of Node Level Buffering sessions\ncompleted.\nNLBMsgFlowControlled FLOAT NOT NULL -(20)9 Number of Node Level Buffered messages\nbeing ﬂow controlled on the sender side (or\nnode).\nNetActiveMrg FLOAT NOT NULL -(20)9 Number of concurrent active merges on all\nBYNETs.\nNetMrgCompleted FLOAT NOT NULL -(20)9 Number of BYNET merges completed.\nFileSmallDepotBusy FLOAT NOT NULL -(20)9 Number of times a Small Depot I/O request\nwaited for a free Slot.\nLake - Monitor Resources and Performance\nPage 29 of 420View Column Data T ype Format Comment\nFileLargeDepotBusy FLOAT NOT NULL -(20)9 Number of times a Large Depot I/O request\nwaited for a free Slot.\nSegMaxAvailMB FLOAT NOT NULL -(20)9 Current MB of maximum PDE segment ﬁles\navailable.\nSegInuseMB FLOAT NOT NULL -(20)9 Current MB of PDE segment ﬁles in use.\nSegCacheMB FLOAT NOT NULL -(20)9 Current MB of segment cache.\nSegMDLAlloc FLOAT NOT NULL -(20)9 Number of segments of all sizes allocated\nfor the MDL pool during this period.\nSegMDLFree FLOAT NOT NULL -(20)9 Number of dirty segments of all sizes freed\nfrom the MDL pool during this period.\nSegMDLRelease FLOAT NOT NULL -(20)9 Number of clean segments of all sizes freed\nfrom the MDL pool during this period.\nSegMDLRecycle FLOAT NOT NULL -(20)9 Number of segments of all sizes recycled to\nthe MDL pool during this period.\nSegMDLAllocKB FLOAT NOT NULL -(20)9 KB of segments of all sizes allocated for the\nMDL pool during this period.\nSegMDLFreeKB FLOAT NOT NULL -(20)9 KB of dirty segments of all sizes freed from\nthe MDL pool during this period.\nSegMDLReleaseKB FLOAT NOT NULL -(20)9 KB of clean segments of all sizes freed from\nthe MDL pool during this period.\nSegMDLRecycleKB FLOAT NOT NULL -(20)9 KB of segments of all sizes recycled to the\nMDL pool during this period.\nRTCpuTime FLOAT NOT NULL -(20)9 Total CPU time in milliseconds consumed\nby boosted real-time tasks.\nRTTasksM ax FLOAT NOT NULL -(20)9 Maximum number of tasks running in\nboosted real-time priority.\nTDEnabledCPUs FLOAT NOT NULL -(20)9 Number of CPUs available for Teradata\ntasks at the end of the reporting period.\nresusa gespsV\nDatabase: td_metric_svc\nIf you need detailed statistics for each workload deﬁnition on the system, use this view to:\nGet a historical view of workload behavior for utilities and SQL operations.\nDetermine the number of workload requests that are using AMP Worker Task.\nExamine queue wait and service time numbers to ﬁnd backed up queries and allocation groups.\nDetermine what workload is responsible for I/O skew.\nMonitor CPU usage managed by the Priority Scheduler.\nIdentify the percent of CPU being used by different workloads.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\nLake - Monitor Resources and Performance\nPage 30 of 420View Column Data T ype Format Comment\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC X(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nPM_COD_IO SMALLINT NOT NULL -(6)9 Platform Metering IO COD value in whole\npercent. For example, a value of 50\nrepresents a COD value of 50.0%\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nWM_COD_IO SMALLINT NOT NULL -(6)9 Workload Management IO COD value in\nwhole percent. For example, a value of 50\nrepresents a COD value of 50.0%.\nTIER_FACTOR SMALLINT NOT NULL -(6)9 I/O performance limit placed on a core-\nreduced node. For example, a value of 75\nrepresents an I/O limit of 75.0% placed\nbefore other COD values.\nReserved00 SMALLINT NOT NULL -(6)9 Reserved for future use.\nNCPUs SMALLINT NOT NULL -(6)9 Number of online CPUs on this node.\nAMPcount SMALLINT NOT NULL -(6)9 Number of AMPs on the node. AMPcount is\nused to divide columns that are reporting\ndata from all the AMPs. This allows the\nResSpsView view to report the data\ncolumns on a per-AMP basis.\nRowIndex1 SMALLINT NOT NULL -(6)9 On SLES 10 or earlier systems, this column\ncontains the PGId. On SLES 11 or later\nsystems, this column contains the pWDid.\nThe pWDid value ranges from 0 to 255.\nVprType CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of vproc (AMP, PE, and MISC). Rows\nreported as vproc type of MISC contain\ndata for all vproc types other than the AMP\nand PE vproc types.\nLake - Monitor Resources and Performance\nPage 31 of 420View Column Data T ype Format Comment\nReservedS0 CHAR(2) LATIN NOT CASESPECIFIC NOT\nNULLX(2) Reserved for future use.\nPPid BYTEINT NOT NULL -(4)9 On SLES 10 or earlier systems, this column\nidentiﬁes the performance period. The PPId\nmaps the internal performance period to a\nRSS value (0=>0, 1 to 7 => 1). On SLES 11\nor later systems, this column is not valid\nand returns a zero value.\nReservedS1 CHAR(7) LATIN NOT CASESPECIFIC NOT\nNULLX(7) Reserved for future use.\nQWaitTime FLOAT NOT NULL -(20)9 Total time in milliseconds that work requests\nwaited on an input queue before being\nserviced. Work requests that are not\ndelivered are not counted.\nServiceTime FLOATNOT NULL -(20)9 Time in milliseconds that work requests\nrequired for service. The service time is the\nelapsed time from the time the message\nwas received to the time the AMP Worker\nTask was released. The time it was held\nthrough sleeps, I/O, and so on, until it is\nreleased.\nWorkTimeInuse FLOAT NOT NULL -(20)9 Service time consumed by a WD during the\ncurrent reporting period\nFilePDbAcqKB FLOAT NOT NULL -(20)9 KB acquired by FilePDbAcqs.\nFilePCiAcqKB FLOAT NOT NULL -(20)9 KB acquired by FilePCiAcqs.\nFileSDbAcqKB FLOAT NOT NULL -(20)9 KB acquired by FileSDbAcqs.\nFileSCiAcqKB FLOAT NOT NULL -(20)9 KB acquired by FileSCiAcqs.\nFileTJtAcqKB FLOAT NOT NULL -(20)9 KB acquired by FileTJtAcqs.\nFileAPtAcqKB FLOAT NOT NULL -(20)9 KB acquired by FileAPtAcqs.\nFilePDbAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FilePDbAcqReads.\nFilePCiAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FilePCiAcqReads.\nFileSDbAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileSDbAcqReads.\nFileSCiAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileSCiAcqReads.\nFileTJtAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileTJtAcqReads.\nFileAPtAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileAPtAcqReads.\nFilePDbPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FilePDbPres.\nFilePCiPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FilePCiPres.\nFileSDbPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileSDbPres.\nFileSCiPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileSCiPres.\nFileTJtPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileTJtPres.\nFileAPtPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileAPtPres.\nFilePDbPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFilePDbPreReads.\nFilePCiPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFilePCiPreReads.\nFileSDbPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileSDbPreReads.\nFileSCiPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileSCiPreReads.\nFileTJtPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileTJtPreReads\nFileAPtPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileAPtPreReads\nFilePDbDyRRelKB FLOAT NOT NULL -(20)9 KB released by FilePDbDyRRels.\nLake - Monitor Resources and Performance\nPage 32 of 420View Column Data T ype Format Comment\nFilePCiDyRRelKB FLOAT NOT NULL -(20)9 KB released by FilePCiDyRRels.\nFileSDbDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileSDbDyRRels.\nFileSCiDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileSCiDyRRels.\nFileTJtDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileTJtDyRRels.\nFileAPtDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileAPtDyRRels.\nFilePDbFWriteKB FLOAT NOT NULL -(20)9 KB written by FilePDbFWrites.\nFilePCiFWriteKB FLOAT NOT NULL -(20)9 KB written by FilePCiFWrites.\nFileSDbFWriteKB FLOAT NOT NULL -(20)9 KB written by FileSDbFWrites.\nFileSCiFWriteKB FLOAT NOT NULL -(20)9 KB written by FileSCiFWrites.\nFileTJtFWriteKB FLOAT NOT NULL -(20)9 KB written by FileTJtFWrites.\nFileAPtFWriteKB FLOAT NOT NULL -(20)9 KB written by FileAPtFWrites.\nNetPtPReadKB FLOAT NOT NULL -(20)9 KB of point-to-point messages input to the\nvproc on behalf of the WD.\nNetPtPWriteKB FLOAT NOT NULL -(20)9 KB of point-to-point messages output to the\nvproc on behalf of the WD.\nProcBlksTime FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a timer expiration.\nProcWaitTime FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending some amount of elapsed\ntime only.\nProcWaitMisc FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending miscellaneous events.\nWaitIO FLOAT NOT NULL -(20)9 SLES11: Time in milliseconds tasks in WD\nwaited for I/O. Updated when the wait for\nI/O is completed.\nCPURunDelay FLOAT NOT NULL -(20)9 SLES11: Time in milliseconds tasks in the\nWD sat in the CPU run queue waiting to run\nover the reporting period.\nIOSubmittedKB FLOAT NOT NULL -(20)9 SLES11: KB of I/O submitted on behalf of\nthis WD.\nFileAgeOutNowIOKB FLOAT NOT NULL -(20)9 Volume of AgeOut Now data blocks not to\nkeep in memory(fsgcache) and to be\nwritten out to disk in terms of KB\n(FileAgeOutNowIOKB).\nIOCriticalSubmittedKB FLOAT NOT NULL -(20)9 SLES11: KB of I/O submitted with an MI\nLock Priority. These I/Os go into a Teradata\nScheduler queue and are not prioritized\nbased on the type of management method.\nFullPotentialIota FLOAT NOT NULL -(20)9 Sum of full (total uninhibited) potential\nIOTAs from all devices attached to this\nnode.\nCodPotentialIota FLOAT NOT NULL -(20)9 Sum of potential IOTAs from all devices\nattached to this node for this WD. These are\naccumulated only when an I/O is pending\non a device, and they are limited by the\nIO_COD setting.\nUsedIota FLOAT NOT NULL -(20)9 Sum of used IOTAs from all devices\nattached to this node for this WD.\nIoThrottleCount FLOAT NOT NULL -(20)9 Number of times an I/O was throttled.\nCpuVpThrottleCount FLOAT NOT NULL -(20)9 Number of times that VP hard limits\nthrottling was triggered.\nCpuVpThrottleTime FLOAT NOT NULL -(20)9 Time in milliseconds that VP hard limits\nthrottling was active.\nCpuThrottleCount FLOAT NOT NULL -(20)9 Number of times that WD hard limits\nthrottling was triggered.\nLake - Monitor Resources and Performance\nPage 33 of 420View Column Data T ype Format Comment\nCpuThrottleTime FLOAT NOT NULL -(20)9 Time in milliseconds that WD hard limits\nthrottling was active.\nVHLogicalDBRead FLOAT NOT NULL -(20)9 Logical reads that were hit in the FSG-VH\ncache per WD.\nVHLogicalDBReadKB FLOAT NOT NULL -(20)9 KB read from the FSG-VH cache per WD.\nVHPhysicalDBRead FLOAT NOT NULL -(20)9 Physical reads by TVS for Very Hot data per\nWD.\nVHPhysicalDBReadKB FLOAT NOT NULL -(20)9 Physical read KBs by TVS for Very Hot data\nper WD.\nIoThrottleTime FLOAT NOT NULL -(20)9 Total I/O Throttle Time in milliseconds.\nIoThrottleTimeMax FLOAT NOT NULL -(20)9 Maximum I/O Throttle Time in milliseconds.\nIoThrottleCntZeroIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nno IOTA tokens available in the bucket.\nIoThrottleCntInsuffIotas FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket.\nIoThrottleCntInsuffIotasHL FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\ninsufﬁcient IOTA tokens available in the\nbucket for Hard Limits.\nIoThrottleCntMaxQD FLOAT NOT NULL -(20)9 Number of times an I/O was throttled due to\nthe queue depth to the storage being at\nmaximum.\nReadRespMax FLOAT NOT NULL -(20)9 Maximum I/O Read Response Time in\nmilliseconds.\nWriteRespMax FLOAT NOT NULL -(20)9 Maximum I/O Write Response Time in\nmilliseconds.\nReadRespTot FLOAT NOT NULL -(20)9 Total I/O Read Response Time in\nmilliseconds.\nWriteRespTot FLOAT NOT NULL -(20)9 Total I/O Write Response Time in\nmilliseconds.\nProcBlksCpuThrottle FLOAT NOT NULL -(20)9 Number of times processes were throttled\ndue to WM CPU COD or CPU hard limits.\nProcWaitCpuThrottle FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nthrottled due to WM CPU COD or CPU hard\nlimits.\nRRDHCount FLOAT NOT NULL -(20)9 Total count of hashed row redistributions\n(RRDs) processed by the node-level\nbuffered redistribution services (NLB).\nRRDHCascAll FLOAT NOT NULL -(20)9 Count of hashed RRDs with a Cascade\nFactor of 100%.\nRRDHCascSome FLOAT NOT NULL -(20)9 Count of hashed RRDs with a Cascade\nFactor greater than 0% but less than 100%.\nCISleeps FLOAT NOT NULL -(20)9 Number of times that processes are\nblocked waiting for a lock on the CI.\nCISleepTime FLOAT NOT NULL -(20)9 Total amount of time in milliseconds that\nprocesses are blocked waiting for a lock on\nthe CI.\nCISleepTimeMax FLOAT NOT NULL -(20)9 Maximum amount of time in milliseconds\nthat processes are blocked waiting for a\nlock on the CI.\nFileWalTJCount FLOAT NOT NULL -(20)9 Number of Transient Journal records\noperations.\nFileWalRedoCount FLOAT NOT NULL -(20)9 Number of Redo records operations.\nFileWalTJIOKB FLOAT NOT NULL -(20)9 Volume of Transient Journal records\noperations in terms of KB.\nFileWalRedoIOKB FLOAT NOT NULL -(20)9 Volume of Redo records operations in terms\nof KB.\nLake - Monitor Resources and Performance\nPage 34 of 420View Column Data T ype Format Comment\nIoPrioStarvedCount FLOAT NOT NULL -(20)9 Number of prioritized I/Os that were starved\nand had their priority updated to alleviate\nstarvation.\nMISleeps FLOAT NOT NULL -(20)9 Number of times that processes are\nblocked waiting for a lock on the MI.\nMISleepTime FLOAT NOT NULL -(20)9 Total amount of time in milliseconds that\nprocesses are blocked waiting for a lock on\nthe MI.\nMISleepTimeMax FLOAT NOT NULL -(20)9 Maximum amount of time in milliseconds\nthat processes are blocked waiting for a\nlock on the MI.\nMmapSemReadCount FLOAT NOT NULL -(20)9 Number of times a segment is mapped and\npinned pages or unmapped to process\naddress-space.\nMmapSemReadTime FLOAT NOT NULL -(20)9 Time in milliseconds task took to map and\npin or unmap a segment to process\naddress-space.\nMmapSemWriteCount FLOAT NOT NULL -(20)9 Number of times a segment is mapped or\nunmapped to process address-space\nMmapSemWriteTime FLOAT NOT NULL -(20)9 Time in milliseconds task took to map or\nunmap a segment to process address-\nspace\nIOSubmittedLocal FLOAT NOT NULL -(20)9 Number of I/Os submitted to local disks.\nIOSubmittedLocalKB FLOAT NOT NULL -(20)9 Amount of I/O submitted, in KB, to local\ndisks.\nProcWaitIoThrottle FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nthrottled due to PSF WM I/O COD or I/O\nhard limits.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nVPid FLOAT NOT NULL -(20)9 Virtual partition ID. Only one VpId is\nassociated with a pWDid and VprType row\nat any point in time. There can be multiple\npWDid values associated with a VPId.\nWDid FLOAT NOT NULL -(20)9 Workload Deﬁnition ID.\nNumTasks FLOAT NOT NULL -(20)9 Average number of tasks of online nodes\nActiveSessions FLOAT NOT NULL -(20)9 On SLES 10, this is the number of\nScheduling Sets. On SLES 11, this is the\nnumber of request-level workload\nmanagement objects created. There is one\nobject created per user request. For non-\nuser work request, there is one object\ncreated per WD.\nNumRequests FLOAT NOT NULL -(20)9 Number of AMP Worker Task messages or\nrequests that got assigned AMP Worker\nTasks to them.\nQWaitTimeMax FLOAT NOT NULL -(20)9 Maximum time in milliseconds that work\nrequests waited on an input queue before\nbeing serviced.\nServiceTimeMax FLOAT NOT NULL -(20)9 Maximum time in milliseconds that work\nrequests required for service.\nWorkMsgSendDelay FLOAT NOT NULL -(20)9 Total time in milliseconds it takes to deliver\nwork messages.\nWorkMsgSendDelayMax FLOAT NOT NULL -(20)9 Maximum time in milliseconds that it takes\nto deliver any single work message.\nWorkMsgReceiveDelay FLOAT NOT NULL -(20)9 Time for all messages not yet delivered at\nthe end of each reporting period. Related to\nthe QWaitTime column, represents a\nrunning total of delays attributed to the\nLake - Monitor Resources and Performance\nPage 35 of 420View Column Data T ype Format Comment\ntasks that still have not been assigned an\nAMP Worker Task within this interval.\nWorkMsgReceiveDelayMax FLOAT NOT NULL -(20)9 Maximum delay time in milliseconds for\nmessages that are still in the work box at\nthe end of each reporting period.\nWorkTimeInuseMax FLOAT NOT NULL -(20)9 Maximum service time of a single task in a\nWD that is running or ha ﬁnished in the\ncurrent reporting period. This includes time\nused during previous intervals for that task.\nAwtReleases FLOAT NOT NULL -(20)9 Number of AMP Worker Tasks released\n(that is, completed requests) while the\nNumRequests column reports the number\nof AMP Worker Task requests that arrived.\nWorkMsgSendDelayCnt FLOAT NOT NULL -(20)9 Number of messages that are delivered to\nthe work box.\nWorkMsgReceiveDelayCnt FLOAT NOT NULL -(20)9 Number of messages that are still waiting\nfor AMP Worker Tasks at the end of each\nreporting period.\nCPUUServ FLOAT NOT NULL -(20)9 Time in milliseconds CPUs are busy\nexecuting user service code. This is the\nsystem-level time spent on a process.\nCPUUExec FLOAT NOT NULL -(20)9 Time in milliseconds CPUs are busy\nexecuting user execution code. This is the\nuser-level time spent on a process.\nCPUUServOther FLOAT NOT NULL -(20)9 Time in milliseconds CPUs are busy\nexecuting miscellaneous activities for user\nservice code. This is the system-level time\nspent on a process.\nCPUUExecOther FLOAT NOT NULL -(20)9 Time in milliseconds CPUs are busy\nexecuting miscellaneous activities for user\nexecution code. This is the user-level time\nspent on a process\nMemAllocs FLOAT NOT NULL -(20)9 Number of successful SEG memory\nallocations.\nWorkTypeInuse00 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse01 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse02 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse03 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse04 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse05 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse06 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse07 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse08 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse09 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse10 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse11 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nLake - Monitor Resources and Performance\nPage 36 of 420View Column Data T ype Format Comment\nWorkTypeInuse12 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse13 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse14 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeInuse15 FLOAT NOT NULL -(20)9 Current number of AMP Worker Tasks in use\nfor each work type.\nWorkTypeMax00 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax01 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax02 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax03 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax04 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax05 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax06 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax07 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nLake - Monitor Resources and Performance\nPage 37 of 420View Column Data T ype Format Comment\nWorkTypeMax08 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax09 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax10 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax11 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax12 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax13 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax14 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nWorkTypeMax15 FLOAT NOT NULL -(20)9 Maximum of the WorkTypeInuse values\nreported during the logging period. The true\nmaximum number of in-use AMP Worker\nTasks of a WorkType may occur at a\ndifferent time during the reporting period\nand not be seen and, therefore, not be\nreported.\nFilePDbAcqs FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegments acquired.\nFilePCiAcqs FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegments acquired.\nFileSDbAcqs FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments acquired.\nFileSCiAcqs FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index disk segments acquired.\nLake - Monitor Resources and Performance\nPage 38 of 420View Column Data T ype Format Comment\nFileTJtAcqs FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegments acquired.\nFileAPtAcqs FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments acquired.\nFilePDbAcqReads FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment acquires that caused a physical\nread.\nFilePCiAcqReads FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment acquires that caused a physical\nread.\nFileSDbAcqReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments that caused a physical\nread.\nFileSCiAcqReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segments that caused a physical\nread.\nFileTJtAcqReads FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegments that caused a physical read.\nFileAPtAcqReads FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments that caused a physical read.\nFilePDbPres FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegments prefetched.\nFilePCiPres FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegments prefetched.\nFileSDbPres FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments prefetched.\nFileSCiPres FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segments prefetched.\nFileTJtPres FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegments prefetched.\nFileAPtPres FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments prefetched.\nFilePDbPreReads FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment prefetches that caused a physical\nread.\nFilePCiPreReads FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment prefetches that caused a physical\nread.\nFileSDbPreReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segment prefetches that caused\na physical read.\nFileSCiPreReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segment prefetches that caused\na physical read.\nFileTJtPreReads FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegment prefetches that caused a physical\nread\nFileAPtPreReads FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segment prefetches that caused a\nphysical read.\nFilePDbDyRRels FLOAT NOT NULL -(20)9 Number of dirty permanent data block disk\nsegment resident releases.\nFilePCiDyRRels FLOAT NOT NULL -(20)9 Number of dirty permanent cylinder index\ndisk segment resident releases.\nLake - Monitor Resources and Performance\nPage 39 of 420View Column Data T ype Format Comment\nFileSDbDyRRels FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ndata block disk segment resident releases.\nFileSCiDyRRels FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ncylinder index disk segment resident\nreleases.\nFileTJtDyRRels FLOAT NOT NULL -(20)9 Number of dirty transient journal table or\nWAL data block or WAL cylinder index disk\nsegment resident releases.\nFileAPtDyRRels FLOAT NOT NULL -(20)9 Number of dirty append table and\npermanent journal data block or cylinder\nindex disk segment resident releases.\nFilePDbFWrites FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFilePCiFWrites FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFileSDbFWrites FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segment forced releases or\nspeciﬁc I/O requests causing an immediate\nphysical write.\nFileSCiFWrites FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index disk segment forced\nreleases or speciﬁc I/O requests causing an\nimmediate physical write.\nFileTJtFWrites FLOAT NOT NULL -(20)9 Number of transient journal table or WAL\ndata block or WAL cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFileAPtFWrites FLOAT NOT NULL -(20)9 Number of append table and permanent\njournal data block or cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nNetPtPReads FLOAT NOT NULL -(20)9 Number of point-to-point messages input to\nthe vproc on behalf of the WD.\nNetPtPWrites FLOAT NOT NULL -(20)9 Number of point-to-point messages output\nfrom the vproc on behalf of the WD\nNetBrdReads FLOAT NOT NULL -(20)9 Number of broadcast messages input to\nthe vproc.\nNetBrdWrites FLOAT NOT NULL -(20)9 Number of broadcast messages output\nfrom the vproc.\nProcBlksSegNoVirtual FLOAT NOT NULL -(20)9 Number of times processes were blocked\nwaiting for virtual memory for a segment.\nProcBlksFsgNIOs FLOAT NOT NULL -(20)9 Number of times processes were blocked\nwaiting for task I/Os to complete.\nProcBlksSegMDL FLOAT NOT NULL -(20)9 Number of times processes were blocked\nwaiting for an MDL resource to become\navailable. An MDL is an internal PDE data\nstructure needed by the operation of the\nsegment subsystem.\nProcBlksMonResume FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a user monitor resume from a yield.\nProcBlksNetThrottle FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor delivery of outstanding outgoing\nmessages.\nLake - Monitor Resources and Performance\nPage 40 of 420View Column Data T ype Format Comment\nProcBlksQnl FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a TSKQNL lock.\nProcBlksFsgRead FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor an FSG read\nProcBlksFsgWrite FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor an FSG write from disk.\nProcBlksDBLock FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a database lock.\nProcBlksMonitor FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a user monitor.\nProcBlksSegLock FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor a disk or task context (for example,\nscratch, stack, and so on).\nProcBlksFsgLock FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor an FSG lock\nProcBlksFlowControl FLOAT NOT NULL -(20)9 Number of times processes were blocked\nby delays caused by the ﬂow control\nconditions.\nProcBlksMisc FLOAT NOT NULL -(20)9 Number of times processes were blocked\nfor miscellaneous events.\nProcWaitSegNoVirtual FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked waiting for virtual memory for a\nsegment.\nProcWaitFsgNIOs FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked waiting for task I/ Os to complete.\nProcWaitSegMDL FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked waiting for an MDL resource to\nbecome available. An MDL is an internal\nPDE data structure needed by the\noperation of the segment subsystem.\nProcWaitMonResume FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending a user monitor resume\nfrom a yield.\nProcWaitNetThrottle FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending delivery of outstanding\noutgoing messages.\nProcWaitQnl FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending an TSKQNL lock.\nProcWaitFsgRead FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending an FSG read from disk.\nProcWaitFsgWrite FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending an FSG write from disk.\nProcWaitDBLock FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending a database lock.\nProcWaitMonitor FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending a user monitor.\nProcWaitSegLock FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending a disk or task context (for\nexample, scratch, stack, and so on) lock.\nProcWaitFsgLock FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending an FSG lock.\nProcWaitFlowControl FLOAT NOT NULL -(20)9 Time in milliseconds processes were\nblocked pending the delays caused by ﬂow\ncontrol conditions.\nIOSubmitted FLOAT NOT NULL -(20)9 SLES11: Number of I/Os submitted on\nbehalf of this WD.\nLake - Monitor Resources and Performance\nPage 41 of 420View Column Data T ype Format Comment\nFileAgeOutNowCount FLOAT NOT NULL -(20)9 Number of AgeOut Now data blocks not to\nkeep in memory(fsgcache) and to be\nwritten out to disk (FileAgeOutNowCount)..\nIOCriticalSubmitted FLOAT NOT NULL -(20)9 SLES11: Number of I/Os submitted with a\nMI Lock Priority. These I/Os go into a\nTeradata Scheduler queue and are not\nprioritized based on the type of\nmanagement method.\nDecayLevel1IO FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD hit decay level 1 due to I/O.\nDecayLevel2IO FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD decay level 2 due to I/O.\nDecayLevel1CPU FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD hit decay level 1 due to CPU.\nDecayLevel2CPU FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD hit decay level 2 due to CPU.\nTacticalExceptionIO FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD hit a tactical per-node exception\ndue to I/O.\nTacticalExceptionCPU FLOAT NOT NULL -(20)9 SLES11: Number of times SQL requests in\nthe WD hit a tactical per-node exception\ndue to CPU.\nRTBoostCount FLOAT NOT NULL -(20)9 Number of tasks boosted to real time\npriority (Maximum priority).\nRTCpuTime FLOAT NOT NULL -(20)9 Total CPU time in milliseconds consumed\nby boosted real-time tasks.\nRTTasksM ax FLOAT NOT NULL -(20)9 Maximum number of tasks running in\nboosted real-time priority.\nWorkTypeAWTExhausted00 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted01 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted02 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted03 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted04 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted05 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted06 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted07 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted08 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted09 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted10 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted11 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted12 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted13 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nLake - Monitor Resources and Performance\nPage 42 of 420View Column Data T ype Format Comment\nWorkTypeAWTExhausted14 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nWorkTypeAWTExhausted15 FLOAT NOT NULL -(20)9 Number of times a work message cannot\nbe assigned to an AWT.\nUdfServ FLOAT NOT NULL -(20)9 System-level UDF CPU time in milliseconds,\nexcluding the CPU time of the STO child\nprocesses.\nUdfExec FLOAT NOT NULL -(20)9 User-level UDF CPU time in milliseconds,\nexcluding the CPU time of the STO child\nprocesses.\nUdfServOther FLOAT NOT NULL -(20)9 System-level UDF CPU time in milliseconds\nof other UDF processes such as the STO\nchild processes.\nUdfExecOther FLOAT NOT NULL -(20)9 User-level UDF CPU time in milliseconds of\nother UDF processes such as the STO child\nprocesses.\nTDEnabledCPUs FLOAT NOT NULL -(20)9 Number of CPUs available for Teradata\ntasks at the end of the reporting period.\nresusa gesvdskV\nDatabase: td_metric_svc\nIf you need detailed statistics for each virtual disk (vdsk) in the system, use this view to:\nCompare how each AMP is using its allocated virtual disks.\nEvaluate the amount of time consumed by outstanding requests, per AMP.\nIdentify non-parallel activity for various metrics such as Read/Write count, Read/Write volume, and so on.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The day on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nLake - Monitor Resources and Performance\nPage 43 of 420View Column Data T ype Format Comment\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nPM_COD_IO SMALLINT NOT NULL -(6)9 Platform Metering IO COD value in whole\npercent. For example, a value of 50\nrepresents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nWM_COD_IO SMALLINT NOT NULL -(6)9 Workload Management IO COD value in\nwhole percent. For example, a value of 50\nrepresents a COD value of 50.0%.\nTIER_FACTOR SMALLINT NOT NULL -(6)9 I/O performance limit placed on a core-\nreduced node. For example, a value of 75\nrepresents an I/O limit of 75.0% placed\nbefore other COD values.\nVprId INTEGER NOT NULL -(11)9 Identiﬁes the AMP vproc\nReadKB FLOAT NOT NULL -(20)9 Number of KB read from the logical device.\nWriteKB FLOAT NOT NULL -(20)9 Number of KB written to the logical device\nReadRespTot FLOAT NOT NULL -(20)9 Total of individual read response time in\ncentiseconds.\nWriteRespTot FLOAT NOT NULL -(20)9 Total of individual write response time in\ncentiseconds.\nWriteRespSq FLOAT NOT NULL -(20)9 Total of squares of the individual write\nresponse time in centiseconds.\nExtMigrateReadRespTot FLOAT NOT NULL -(20)9 Migration read I/O response time\nExtMigrateWriteRespTot FLOAT NOT NULL -(20)9 Migration write I/O response time\nExtMigrateIOTimeImprove FLOAT NOT NULL -(20)9.99 Estimates the percent improvement in\naverage I/O response time due to\nmigrations completing in the log interval. If\nthe average I/O response time was 10 ms\nand the ExtMigrateIOTimeImprove is 10%,\naverage I/O response time is\n(100%-10%)*10ms = 9ms.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nReadCnt FLOAT NOT NULL -(20)9 Number of logical device reads.\nWriteCnt FLOAT NOT NULL -(20)9 Number of logical device writes.\nLake - Monitor Resources and Performance\nPage 44 of 420View Column Data T ype Format Comment\nReadRespMax FLOAT NOT NULL -(20)9 Maximum of individual read response time\nin centiseconds.\nWriteRespMax FLOAT NOT NULL -(20)9 Maximum of individual write response time\nin centiseconds.\nConcurrentMax FLOAT NOT NULL -(20)9 Maximum number of concurrent I/O\nrequests.\nConcurrentReadMax FLOAT NOT NULL -(20)9 Maximum number of concurrent read I/O\nrequests.\nConcurrentWriteMax FLOAT NOT NULL -(20)9 Maximum number of concurrent write I/O\nrequests.\nOutReqTime FLOAT NOT NULL -(20)9 Time with outstanding requests (busy time),\nin centiseconds.\nExtAllocHot FLOAT NOT NULL -(20)9 Number of hot allocations made in the\ncurrent log period. An allocation whose\nestimated temperature falls within the pre-\ndeﬁned hot temperature range.\nTemperature is the frequency of access to\nthe data by I/O independent of where the\ndata resides.\nExtAllocWarm FLOAT NOT NULL -(20)9 Number of warm allocations made in the\ncurrent log period. An allocation whose\nestimated temperature falls within the pre-\ndeﬁned warm temperature range.\nTemperature is the frequency of access to\nthe data by I/O independent of where the\ndata resides.\nExtAllocTotal FLOAT NOT NULL -(20)9 Total number of allocations. Cold Allocation\n= ExtAllocTotal - ExtAllocHot -\nExtAllocWarm, QueryPacing Allocation =\nExtAllocTotal - ExtAllocNonPacing -\nExtAllocSystemPacing, Dynamic Allocation\n= ExtAllocTotal - ExtAllocStatic.\nExtAllocNonPacing FLOAT NOT NULL -(20)9 Number of non-pacing allocations made in\nthe current log period. A non-pacing\nallocation is an allocation whose data\naccess affects neither system performance\nnor individual query performance.\nExtAllocSystemPacing FLOAT NOT NULL -(20)9 Number of system pacing allocations made\nin the current log period. A system pacing\nallocation is an allocation whose data\naccess affects system performance.\nExtAllocStatic FLOAT NOT NULL -(20)9 Number of static allocations made in the\ncurrent log period. A static allocation is an\nallocation whose requested temperature is\nused and the measured temperature is\nignored during migration.\nExtMigrateFaster FLOAT NOT NULL -(20)9 Number of cylinders migrated to faster\nlocations. SlowerMigration =\nExtMigrateTotal - ExtMigrateFaster,\nCylinders are migrated to slower locations\nto make room for hotter cylinders to replace\nthem.\nExtMigrateTotal FLOAT NOT NULL -(20)9 Total number of cylinders migrated to a\ndifferent physical location. For more\ninformation, see the ExtMigrateFaster\ncolumn.\nExtMigrateIOTimeCost FLOAT NOT NULL -(20)9 Estimates the total cost, in centiseconds,\nincurred by migration I/Os completing\nduring the log period, where cost is the\nextra time waited by all non-migration I/Os\nas a result of the migration I/O.\nExtMigrateIOTimeBeneﬁt FLOAT NOT NULL -(20)9 Estimates the total I/O time savings\nachieved by migrations completing in the\nLake - Monitor Resources and Performance\nPage 45 of 420View Column Data T ype Format Comment\nlog period. The I/O time savings include the\nimprovement in response time caused by\nthe new data arrangement up to the time\nhorizon.\nresusa gesvprV\nDatabase: td_metric_svc\nIf you need detailed statistics for each virtual processor (vproc) in the system, use this view to:\nDetermine how each AMP is using memory.\nConﬁrm that all parsing engines (PE) are being allocated work appropriately.\nCompare physical IO reads and writes per AMP.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) File path in object storage for metric data\nobjects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp, in EPOCH timestamp format,\nthis metric data was collected from your\ndatabase and written to object storage.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was logged.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nTheDate DATE NOT NULL YYYY/MM/DD Local Date of the log entry.\nNodeID INTEGER NOT NULL ZZZ9-9999 Numeric value that uniquely identiﬁes a\nnode (cloud compute instance) within a\ncompute cluster. For example,\n'10001','10002'.\nTheTime FLOAT NOT NULL 99:99:99.99 Nominal local time of the log entry.\nGmtTime FLOAT NOT NULL 99:99:99.99 Nominal GMT time of the log entry.\nGreenwich Mean Time is not affected by the\nDaylight Saving Time adjustments that\noccur twice a year.\nCabinetID\nNot applicable. Do not use.    Not applicable.\nModuleID\nNot applicable. Do not use.    Not applicable.\nNodeType CHAR(8) LATIN NOT CASESPECIFIC NOT\nNULLX(8) Indicates the node (cloud compute\ninstance) family. For example, '67_R5'.\nTheTimestamp BIGINT NOT NULL -(20)9 Number of seconds since midnight,\nJanuary 1, 1970.\nCentiSecs INTEGER NOT NULL -(11)9 Actual number of centiseconds in the\nlogging period.\nSecs SMALLINT NOT NULL -(6)9 Actual number of seconds in the logging\nperiod.\nNominalSecs SMALLINT NOT NULL -(6)9 Nominal number of seconds in the logging\nperiod.\nLake - Monitor Resources and Performance\nPage 46 of 420View Column Data T ype Format Comment\nSummaryFlag CHAR(1) LATIN NOT CASESPECIFIC NOT\nNULLX(1) Summarization status of this row. Possible\nvalues are N if the row is a non-summary\nrow, and S if the row is a summary row.\nReservedS0 CHAR(3) LATIN NOT CASESPECIFIC NOT\nNULLX(3) Reserved for future use.\nPM_COD_CPU SMALLINT NOT NULL -(6)9 Platform Metering CPU COD value in one\ntenths of a percent. For example, a value of\n500 represents a COD value of 50.0%.\nWM_COD_CPU SMALLINT NOT NULL -(6)9 Workload Management CPU COD value in\none tenths of a percent. For example, a\nvalue of 500 represents a COD value of\n50.0%.\nReserved00 SMALLINT NOT NULL -(6)9 Reserved for future use.\nNCPUs SMALLINT NOT NULL -(6)9 Number of online CPUs on this node.\nvprid INTEGER NOT NULL -(11)9 Identiﬁes the vproc number (non-Summary\nMode) or the vproc type (Summary Mode; 0\n= NODE, 1 = AMP, 2 = PE, 3=GTW, 4=RSG,\n5=TVS).\nVprType CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Type of vproc. The values can be NODE,\nAMP, PE, GTW, RSG, or TVS.\nReservedS1 CHAR(4) LATIN NOT CASESPECIFIC NOT\nNULLX(4) Reserved for future use.\nMemPDbKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent data block disk segments that\nare clean and not accessed.\nMemPCiKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent cylinder index disk segments\nthat are clean and not accessed\nMemSDbKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool data block disk\nsegments that are clean and not accessed.\nMemSCiKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool cylinder index disk\nsegments that are clean and not accessed.\nMemTJtKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for transient\njournal table or WAL data block or WAL\ncylinder index disk segments that are clean\nand not accessed.\nMemAPtKBResCU FLOAT NOT NULL -(20)9 Current KB resident in memory for append\ntable or permanent journal table data block\nor cylinder index disk segments that are\nclean and not accessed.\nMemPDbKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent data block disk segments that\nare dirty and unaccessed.\nMemPCiKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent cylinder index disk segments\nthat are dirty and unaccessed.\nMemSDbKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool data block disk\nsegments that are dirty and unaccessed.\nMemSCiKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool cylinder index disk\nsegments that are dirty and unaccessed.\nMemTJtKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for transient\njournal table or WAL data block or WAL\ncylinder index disk segments that are dirty\nand unaccessed.\nMemAPtKBResDU FLOAT NOT NULL -(20)9 Current KB resident in memory for append\ntable or permanent journal table data block\nLake - Monitor Resources and Performance\nPage 47 of 420View Column Data T ype Format Comment\nor cylinder index disk segments that are\ndirty and unaccessed.\nMemPDbKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent data block segments that are\nclean and accessed.\nMemPCiKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent cylinder index disk segments\nthat are clean and accessed.\nMemSDbKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool data block disk\nsegments that are clean and accessed.\nMemSCiKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool cylinder index disk\nsegments that are clean and accessed.\nMemTJtKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for transient\njournal table or WAL data block or WAL\ncylinder index disk segments that are clean\nand accessed.\nMemAPtKBResCA FLOAT NOT NULL -(20)9 Current KB resident in memory for append\ntable or permanent journal table data block\nor cylinder index disk segments that are\nclean and accessed.\nMemPDbKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent data block disk segments that\nare dirty and accessed.\nMemPCiKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for\npermanent cylinder index disk segments\nthat are dirty and accessed.\nMemSDbKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool data block disk\nsegments that are dirty and accessed.\nMemSCiKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for regular\nor restartable spool cylinder index disk\nsegments that are dirty and accessed.\nMemTJtKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for transient\njournal table or WAL data block or WAL\ncylinder index disk segments that are dirty\nand accessed.\nMemAPtKBResDA FLOAT NOT NULL -(20)9 Current KB resident in memory for append\ntable or permanent journal table data block\nor cylinder index disk segments that are\ndirty and accessed.\nMemCtxtAccessKB FLOAT NOT NULL -(20)9 KB of segments accessed.\nMemCtxtDeaccessKB FLOAT NOT NULL -(20)9 KB of segments deaccessed.\nMemCtxtDestroyKB FLOAT NOT NULL -(20)9 KB of segments destroyed.\nNetPtPReadKB FLOAT NOT NULL -(20)9 KB of point-to-point messages input to the\nvproc.\nNetPtPWriteKB FLOAT NOT NULL -(20)9 KB of point-to-point messages output from\nthe vproc.\nNetBrdReadKB FLOAT NOT NULL -(20)9 KB of broadcast messages input to the\nvproc.\nNetBrdWriteKB FLOAT NOT NULL -(20)9 KB of broadcast messages output from the\nvproc.\nFilePDbAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FilePDbAcqs.\nFilePCiAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FilePCiAcqs.\nFileSDbAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FileSDbAcqs.\nFileSCiAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FileSCiAcqs.\nFileTJtAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FileTJtAcqs.\nLake - Monitor Resources and Performance\nPage 48 of 420View Column Data T ype Format Comment\nFileAPtAcqKB FLOAT NOT NULL -(20)9 KB logically acquired by FileAPtAcqs.\nFilePDbAcqOtherKB FLOAT NOT NULL -(20)9 Number of permanent data block scratch\ndisk segments acquired in KB.\nFilePCiAcqOtherKB FLOAT NOT NULL -(20)9 Number of permanent cylinder index\nscratch disk segments acquired in KB.\nFileSDbAcqOtherKB FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock scratch disk segments acquired in\nKB.\nFileSCiAcqOtherKB FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index scratch disk segments\nacquired in KB.\nFileTJtAcqOtherKB FLOAT NOT NULL -(20)9 Number of transient journal or WAL data\nblock or WAL cylinder index scratch disk\nsegments acquired in KB.\nFileAPtAcqOtherKB FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\nscratch disk segments acquired in KB.\nFilePDbRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch permanent data block\ndisk segments released in KB.\nFilePCiRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch permanent cylinder\nindex disk segments released in KB.\nFileSDbRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch regular or restartable\nspool data block disk segments released in\nKB.\nFileSCiRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch regular or restartable\nspool cylinder index disk segments\nreleased in KB.\nFileTJtRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch transient journal table or\nWAL data block or WAL cylinder index disk\nsegments released in KB.\nFileAPtRelOtherKB FLOAT NOT NULL -(20)9 Number of scratch append table or\npermanent journal table data block or\ncylinder index disk segments released in\nKB.\nFilePDbAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FilePDbAcqReads.\nFilePCiAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FilePCiAcqReads.\nFileSDbAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileSDbAcqReads.\nFileSCiAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileSCiAcqReads.\nFileTJtAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileTJtAcqReads.\nFileAPtAcqReadKB FLOAT NOT NULL -(20)9 KB physically read by FileAPtAcqReads.\nFilePDbPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FilePDbPres.\nFilePCiPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FilePCiPres.\nFileSDbPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileSDbPres.\nFileSCiPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileSCiPres.\nFileTJtPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileTJtPres.\nFileAPtPresKB FLOAT NOT NULL -(20)9 Number of KB prefetched by FileAPtPres.\nFilePDbPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFilePDbPreReads.\nFilePCiPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFilePCiPreReads.\nFileSDbPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileSDbPreReads.\nFileSCiPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileSCiPreReads.\nLake - Monitor Resources and Performance\nPage 49 of 420View Column Data T ype Format Comment\nFileTJtPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileTJtPreReads\nFileAPtPreReadKB FLOAT NOT NULL -(20)9 Number of KB physical read by\nFileAPtPreReads\nFilePDbDyRRelKB FLOAT NOT NULL -(20)9 KB released by FilePDbDyRRels.\nFilePCiDyRRelKB FLOAT NOT NULL -(20)9 KB released by FilePCiDyRRels.\nFileSDbDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileSDbDyRRels.\nFileSCiDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileSCiDyRRels.\nFileTJtDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileTJtDyRRels.\nFileAPtDyRRelKB FLOAT NOT NULL -(20)9 KB released by FileAPtDyRRels.\nFilePDbFWriteKB FLOAT NOT NULL -(20)9 KB written by FilePDbFWrites.\nFilePCiFWriteKB FLOAT NOT NULL -(20)9 KB written by FilePCiFWrites.\nFileSDbFWriteKB FLOAT NOT NULL -(20)9 KB written by FileSDbFWrites.\nFileSCiFWriteKB FLOAT NOT NULL -(20)9 KB written by FileSCiFWrites.\nFileTJtFWriteKB FLOAT NOT NULL -(20)9 KB written by FileTJtFWrites.\nFileAPtFWriteKB FLOAT NOT NULL -(20)9 KB written by FileAPtFWrites.\nFilePDbDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FilePDbDyAWrites.\nFilePCiDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FilePCiDyAWrites.\nFileSDbDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FileSDbDyAWrites.\nFileSCiDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FileSCiDyAWrites.\nFileTJtDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FileTJtDyAWrites.\nFileAPtDyAWriteKB FLOAT NOT NULL -(20)9 KB written by FileAPtDyAWrites.\nFilePDbCnRRelKB FLOAT NOT NULL -(20)9 KB released by FilePDbCnRRels.\nFilePCiCnRRelKB FLOAT NOT NULL -(20)9 KB released by FilePCiCnRRels.\nFileSDbCnRRelKB FLOAT NOT NULL -(20)9 KB released by FileSDbCnRRels.\nFileSCiCnRRelKB FLOAT NOT NULL -(20)9 KB released by FileSCiCnRRels.\nFileTJtCnRRelKB FLOAT NOT NULL -(20)9 KB released by FileTJtCnRRels.\nFileAPtCnRRelKB FLOAT NOT NULL -(20)9 KB released by FileAPtCnRRels.\nFilePDbFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FilePDbFDrps.\nFilePCiFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FilePCiFDrps.\nFileSDbFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FileSDbFDrps.\nFileSCiFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FileSCiFDrps.\nFileTJtFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FileTJtFDrps.\nFileAPtFDrpKB FLOAT NOT NULL -(20)9 KB dropped by FileAPtFDrps.\nFilePDbCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FilePDbCnADrps.\nFilePCiCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FilePCiCnADrps.\nFileSDbCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FileSDbCnADrps.\nFileSCiCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FileSCiCnADrps.\nFileTJtCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FileTJtCnADrps.\nFileAPtCnADrpKB FLOAT NOT NULL -(20)9 KB dropped by FileAPtCnADrps.\nReadResponseHotTotal FLOAT NOT NULL -(20)9 Read response time of all cylinders that are\nconsidered HOT.\nReadResponseWarmTotal FLOAT NOT NULL -(20)9 Read response time of all cylinders that are\nconsidered WARM.\nReadResponseColdTotal FLOAT NOT NULL -(20)9 Read response time of all cylinders that are\nconsidered COLD.\nWriteResponseHotTotal FLOAT NOT NULL -(20)9 Write response time of all cylinders that are\nconsidered HOT.\nLake - Monitor Resources and Performance\nPage 50 of 420View Column Data T ype Format Comment\nWriteResponseWarmTotal FLOAT NOT NULL -(20)9 Write response time of all cylinders that are\nconsidered WARM.\nWriteResponseColdTotal FLOAT NOT NULL -(20)9 Write response time of all cylinders that are\nconsidered COLD.\nFilePreCompMB FLOAT NOT NULL -(20)9 Total number of MBs for the data block to\ncompress before any compression starts.\nThis column is used with the\nFilePostCompMB column to calculate the\ncompression ratio.\nFilePostCompMB FLOAT NOT NULL -(20)9 Total number of MBs of compressed data\nthat result from uncompressed blocks being\ncompressed. This column is used with the\nFilePreCompMB column to calculate the\ncompression ratio.\nFilePreUnCompMB FLOAT NOT NULL -(20)9 Total number of MBs for the compressed\ndata block to uncompress before\nuncompression starts. This column is used\nwith the FilePostUncompMB column to\ncalculate the uncompression ratio.\nFilePostUnCompMB FLOAT NOT NULL -(20)9 Total number of MBs of uncompressed data\nthat result from compressed blocks being\nuncompressed. This column is used with\nthe FilePreUncompMB column to calculate\nthe uncompression ratio.\nFileCompCPU FLOAT NOT NULL -(20)9 Compression time, including any overhead.\nThe column measures, in microseconds,\nthe time it takes from the beginning of the\ncompression operation to the end.\nFileUnCompCPU FLOAT NOT NULL -(20)9 Uncompression time, including any\noverhead. The column measures, in\nmicroseconds, the time it takes from the\nbeginning of the uncompression operation\nto the end.\nFileTempCPU FLOAT NOT NULL -(20)9 CPU time, in microseconds, spent by the\nAutoTempComp background task either\ncompressing or uncompressing data,\nincluding any overhead.\nVHAgedOut FLOAT NOT NULL -(20)9 Number of data segments that were aged\nout of VERY-HOT cache.\nVHAgedOutKB FLOAT NOT NULL -(20)9 Volume of data segments in KB that were\naged out of VERY-HOT cache.\nVHLogicalDBRead FLOAT NOT NULL -(20)9 Number of logical db reads from VH cache.\nVHLogicalDBReadKB FLOAT NOT NULL -(20)9 Volume of logical reads in KB from VERY-\nHOT cache.\nVHPhysicalDBRead FLOAT NOT NULL -(20)9 Number of physical db reads from VH\ncache.\nVHPhysicalDBReadKB FLOAT NOT NULL -(20)9 KB of physical reads for VH data.\nVHCacheInuseKB FLOAT NOT NULL -(20)9 Size of VH cache in KB in use.\nFsgCacheInuseKB FLOAT NOT NULL -(20)9 KB of FSG cache in use. This includes the\nmemory in use by TIM (VHCacheInuseKB).\nSpaceAllocated FLOAT NOT NULL -(20)9 Total number of bytes of space allocated to\nthe AMP VPROC.\nSpaceDeallocated FLOAT NOT NULL -(20)9 Total number of bytes of space de-allocated\nfrom the AMP VPROC.\nNosPhysReadIOs FLOAT NOT NULL -(20)9 Number of physical read IOs issued against\nNative Object Store tables.\nNosPhysReadIOKB FLOAT NOT NULL -(20)9 Total KB physically read from Native Object\nStore tables.\nNosFiles FLOAT NOT NULL -(20)9 Number of Native Object Store ﬁles read in\nsatisfying queries against Native Object\nLake - Monitor Resources and Performance\nPage 51 of 420View Column Data T ype Format Comment\nStore tables.\nNosFilesSkipped FLOAT NOT NULL -(20)9 Number of Native Object Store ﬁles (or\npartial ﬁles) skipped due to errors.\nNosRecordsReturned FLOAT NOT NULL -(20)9 Number of records returned in satisfying\nqueries against Native Object Store tables.\nNosRecordsReturnedKB FLOAT NOT NULL -(20)9 Total KB of records returned from Native\nObject Store ﬁles.\nNosRecordsSkipped FLOAT NOT NULL -(20)9 Number of Native Object Store records\nskipped due to errors.\nNosTotalIOWaitTime FLOAT NOT NULL -(20)9 Total time in seconds waiting for IOs when\nreading Native Object Store ﬁles.\nNosMaxIOWaitTime FLOAT NOT NULL -(20)9 Maximum single IO wait time in seconds\nwhen reading Native Object Store ﬁles.\nNosCPUTime FLOAT NOT NULL -(20)9 Total CPU time in seconds spend\ndecompressing, translating, or otherwise\nprocessing Native Object Store data as part\nof reading it.\nRRDHCount FLOAT NOT NULL -(20)9 Total count of hashed row redistributions\n(RRDs) processed by the node-level\nbuffered redistribution services (NLB).\nRRDHCascAll FLOAT NOT NULL -(20)9 Count of hashed RRDs with a Cascade\nFactor of 100%.\nRRDHCascMost FLOAT NOT NULL -(20)9 Count of hashed RRDs with a Cascade\nFactor of 90 or more, but less than 100%%.\nRRDHCascSome FLOAT NOT NULL -(20)9 Count of hashed RRDs with a Cascade\nFactor greater than 0% but less than 90%.\nNosPhysDataReadIO FLOAT NOT NULL -(20)9 Number of Physical Data IO Reads for\nNative Object Store.\nNosPhysDataReadIOKB FLOAT NOT NULL -(20)9 Total KBs of physical data read for Native\nObject Store.\nNosCacheReadIO FLOAT NOT NULL -(20)9 Number of Cache Data IO Reads for Native\nObject Store.\nFileSpoolForceAgeoutnow FLOAT NOT NULL -(20)9 Number of spool data segments that were\nforced to change their age to ageoutnow.\nFileSpoolForceAgeoutnowKB FLOAT NOT NULL -(20)9 Volume of spool data segments in KB that\nwere forced to change their age to\nageoutnow.\nFileSpoolKeepAge FLOAT NOT NULL -(20)9 Number of spool data segments that keep\ntheir age irrespective of\nFSGINFOSPOOLAGEOUTNOW ﬂag.\nFileSpoolKeepAgeKB FLOAT NOT NULL -(20)9 Volume of spool data segments in KB that\nkeep their age irrespective of\nFSGINFOSPOOLAGEOUTNOW ﬂag.\nNosCacheReadIOKB FLOAT NOT NULL -(20)9 Total KBs of cache data read for Native\nObject Store.\nCISleeps FLOAT NOT NULL -(20)9 Number of times that processes are\nblocked waiting for a lock on the CI.\nCISleepTime FLOAT NOT NULL -(20)9 Total amount of time in milliseconds that\nprocesses are blocked waiting for a lock on\nthe CI.\nCISleepTimeMax FLOAT NOT NULL -(20)9 Maximum amount of time in milliseconds\nthat processes are blocked waiting for a\nlock on the CI.\nMsgAwtWorkDQCount FLOAT NOT NULL -(20)9 Number of messages dequeued for AMP\nWorker Tasks.\nFileWalTJCount FLOAT NOT NULL -(20)9 Number of Transient Journal records\noperations.\nFileWalRedoCount FLOAT NOT NULL -(20)9 Number of Redo records operations.\nLake - Monitor Resources and Performance\nPage 52 of 420View Column Data T ype Format Comment\nFileWalTJIOKB FLOAT NOT NULL -(20)9 Volume of Transient Journal records\noperations in terms of KB.\nFileWalRedoIOKB FLOAT NOT NULL -(20)9 Volume of Redo records operations in terms\nof KB.\nNosFilesWritten FLOAT NOT NULL -(20)9 Number of ﬁle writes attempted by Native\nObject Store.\nNosPhysWriteIOs FLOAT NOT NULL -(20)9 Total physical write IOs for Native Object\nStore.\nNosPhysWriteIOKB FLOAT NOT NULL -(20)9 Total KB of physical write IOs for Native\nObject Store ﬁles.\nNosSpCIsReturned FLOAT NOT NULL -(20)9 Number of NOS Spool CIs returned by a\nNative Object Store Spool request.\nNosSpCIsReturnedKB FLOAT NOT NULL -(20)9 Total KB of CIs returned for Native Object\nStore spool requests.\nNosSpDBChunksReturned FLOAT NOT NULL -(20)9 Number of NOS Spool Datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBChunksReturnedKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool Datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBsReturned FLOAT NOT NULL -(20)9 Number of NOS Spool Datablocks returned\nby a Native Object Store spool request.\nNosSpDBsReturnedKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool Datablocks returned\nby a Native Object Store spool request.\nNosSpBlksFSGAcqs FLOAT NOT NULL -(20)9 Number of NOS Spool Datablocks read\nfrom FSG.\nNosSpBlksFSGAcqsKB FLOAT NOT NULL -(20)9 Total KB of the Number of NOS Spool\nDatablocks read from FSG.\nNosSpCPUTime FLOAT NOT NULL -(20)9 Total CPU time in seconds for reading\nNative Object Store spool blocks (MI, CI,\nDBChunks).\nNosSpMaxIOWaitTime FLOAT NOT NULL -(20)9 Max Native Object Store spool IO wait time\nin seconds for any individual IO.\nNosSpTotalIOWaitTime FLOAT NOT NULL -(20)9 Total of the Native Object Store spool IO\nwait time in seconds across all steps.\nNosSpTablesWritten FLOAT NOT NULL -(20)9 Number of NOS spool tables written. This\ncorresponds to the number of TMIs written.\nNosSpCIsWritten FLOAT NOT NULL -(20)9 Number of NOS Spool CIs written.\nNosSpCIsWrittenKB FLOAT NOT NULL -(20)9 Total KB of NOS Spool CIs written.\nNosSpDBChunksWritten FLOAT NOT NULL -(20)9 Number of NOS spool DB chunks written.\nNosSpDBChunksWrittenKB FLOAT NOT NULL -(20)9 Total KB of NOS spool DB chunks written.\nNosSpDBsWritten FLOAT NOT NULL -(20)9 Number of NOS DBs written.\nNosSpDBsWrittenKB FLOAT NOT NULL -(20)9 Total KB Number of NOS spool DBs written.\nActive FLOAT NOT NULL -(20)9 Controls whether the rows are logged to the\nresource usage tables if Active Row Filter\nMode is enabled.\nProcPendDBLock FLOAT NOT NULL -(20)9 Number of process blocks pending\ndatabase locks.\nProcBlksDBLock FLOAT NOT NULL -(20)9 Number of process blocks f.or database\nlocks.\nProcWaitDBLock FLOAT NOT NULL -(20)9 Time in centiseconds processes were\nblocked pending database locks.\nMemCtxtAllocs FLOAT NOT NULL -(20)9 Number of successful memory allocations\nand size-increasing memory alters on task\ncontext pages.\nMemCtxtAccesses FLOAT NOT NULL -(20)9 Number of segments accessed.\nLake - Monitor Resources and Performance\nPage 53 of 420View Column Data T ype Format Comment\nMemCtxtDeaccesses FLOAT NOT NULL -(20)9 Number of segments deaccessed.\nDeaccessed segments remain in memory\nuntil paged out through aging.\nMemCtxtDestroys FLOAT NOT NULL -(20)9 Number of segments destroyed. Destroyed\nsegments are immediately dropped from\nmemory.\nNetPtPReads FLOAT NOT NULL -(20)9 Number of point-to-point messages input to\nthe vproc.\nNetPtPWrites FLOAT NOT NULL -(20)9 Number of point-to-point messages output\nfrom the vproc.\nNetBrdReads FLOAT NOT NULL -(20)9 Number of broadcast messages input to\nthe vproc.\nNetBrdWrites FLOAT NOT NULL -(20)9 Number of broadcast messages output\nfrom the vproc.\nDBLockEnters FLOAT NOT NULL -(20)9 Number of times a database lock was\nentered for holding.\nDBLockBlocks FLOAT NOT NULL -(20)9 Number of times a database lock was\nblocked.\nDBLockDeadlocks FLOAT NOT NULL -(20)9 Number of times a database lock was\ndeadlocked.\nFilePDbAcqs FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegments acquires that were logically\nacquired.\nFilePCiAcqs FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegments acquires that were logically\nacquired.\nFileSDbAcqs FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments acquires that were\nlogically acquired.\nFileSCiAcqs FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index disk segments acquires that\nwere logically acquired.\nFileTJtAcqs FLOAT NOT NULL -(20)9 Number of transient journal or WAL data\nblock or WAL cylinder index disk segments\nacquires that were logically acquired.\nFileAPtAcqs FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments that were logically acquired.\nFilePDbAcqsOther FLOAT NOT NULL -(20)9 Number of permanent data block scratch\ndisk segments that were logically acquired.\nFilePCiAcqsOther FLOAT NOT NULL -(20)9 Number of permanent cylinder index\nscratch disk segments that were logically\nacquired.\nFileSDbAcqsOther FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock scratch disk segments that were\nlogically acquired.\nFileSCiAcqsOther FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index scratch disk segments that\nwere logically acquired.\nFileTJtAcqsOther FLOAT NOT NULL -(20)9 Number of transient journal or WAL data\nblock or WAL cylinder index scratch disk\nsegments that were logically acquired.\nFileAPtAcqsOther FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\nscratch disk segments that were logically\nacquired.\nFilePDbRelsOther FLOAT NOT NULL -(20)9 Number of scratch permanent data block\ndisk segments released as part of them\nbeing deleted.\nLake - Monitor Resources and Performance\nPage 54 of 420View Column Data T ype Format Comment\nFilePCiRelsOther FLOAT NOT NULL -(20)9 Number of scratch permanent cylinder\nindex disk segments released as part of\nthem being deleted.\nFileSDbRelsOther FLOAT NOT NULL -(20)9 Number of scratch regular or restartable\nspool data block disk segments released\nas part of them being deleted.\nFileSCiRelsOther FLOAT NOT NULL -(20)9 Number of scratch regular or restartable\nspool cylinder index disk segments\nreleased as part of them being deleted.\nFileTJtRelsOther FLOAT NOT NULL -(20)9 Number of scratch transient journal table or\nWAL data block or WAL cylinder index disk\nsegments released as part of them being\ndeleted.\nFileAPtRelsOther FLOAT NOT NULL -(20)9 Number of scratch append table or\npermanent journal table data block or\ncylinder index disk segments released as\npart of them being deleted.\nFilePDbAcqReads FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment acquires that caused a physical\nread.\nFilePCiAcqReads FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment acquires that caused a physical\nread.\nFileSDbAcqReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments that caused a physical\nread.\nFileSCiAcqReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segments that caused a physical\nread.\nFileTJtAcqReads FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegments that caused a physical read.\nFileAPtAcqReads FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments that caused a physical read.\nFilePDbPres FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegments prefetched.\nFilePCiPres FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegments prefetched.\nFileSDbPres FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segments prefetched.\nFileSCiPres FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segments prefetched.\nFileTJtPres FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegments prefetched.\nFileAPtPres FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segments prefetched.\nFilePDbPreReads FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment prefetches that caused a physical\nread.\nFilePCiPreReads FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment prefetches that caused a physical\nread.\nFileSDbPreReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segment prefetches that caused\na physical read.\nFileSCiPreReads FLOAT NOT NULL -(20)9 Number of regular or restartable spool\nindex disk segment prefetches that caused\na physical read.\nLake - Monitor Resources and Performance\nPage 55 of 420View Column Data T ype Format Comment\nFileTJtPreReads FLOAT NOT NULL -(20)9 Number of transient journal table disk\nsegment prefetches that caused a physical\nread.\nFileAPtPreReads FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segment prefetches that caused a\nphysical read.\nFilePDbDyRRels FLOAT NOT NULL -(20)9 Number of dirty permanent data block disk\nsegment resident releases.\nFilePCiDyRRels FLOAT NOT NULL -(20)9 Number of dirty permanent cylinder index\ndisk segment resident releases.\nFileSDbDyRRels FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ndata block disk segment resident releases.\nFileSCiDyRRels FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ncylinder index disk segment resident\nreleases.\nFileTJtDyRRels FLOAT NOT NULL -(20)9 Number of dirty transient journal table or\nWAL data block or WAL cylinder index disk\nsegment resident releases.\nFileAPtDyRRels FLOAT NOT NULL -(20)9 Number of dirty append table and\npermanent journal data block or cylinder\nindex disk segment resident releases.\nFilePDbFWrites FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFilePCiFWrites FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFileSDbFWrites FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segment forced releases or\nspeciﬁc I/O requests causing an immediate\nphysical write.\nFileSCiFWrites FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index disk segment forced\nreleases or speciﬁc I/O requests causing an\nimmediate physical write.\nFileTJtFWrites FLOAT NOT NULL -(20)9 Number of transient journal table or WAL\ndata block or WAL cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFileAPtFWrites FLOAT NOT NULL -(20)9 Number of append table and permanent\njournal data block or cylinder index disk\nsegment forced releases or speciﬁc I/O\nrequests causing an immediate physical\nwrite.\nFilePDbDyAWrites FLOAT NOT NULL -(20)9 Number of dirty permanent data block disk\nsegments aged out of memory causing a\ndelayed physical write.\nFilePCiDyAWrites FLOAT NOT NULL -(20)9 Number of dirty permanent cylinder index\ndisk segments aged out of memory causing\na delayed physical write.\nFileSDbDyAWrites FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ndata block disk segments aged out of\nmemory causing a delayed physical write.\nFileSCiDyAWrites FLOAT NOT NULL -(20)9 Number of dirty regular or restartable spool\ncylinder index disk segments aged out of\nmemory causing a delayed physical write.\nLake - Monitor Resources and Performance\nPage 56 of 420View Column Data T ype Format Comment\nFileTJtDyAWrites FLOAT NOT NULL -(20)9 Number of dirty transient journal table or\nWAL data block or WAL cylinder index disk\nsegments aged out of memory causing a\ndelayed physical write.\nFileAPtDyAWrites FLOAT NOT NULL -(20)9 Number of dirty append table or permanent\njournal table data block or cylinder index\ndisk segments aged out of memory causing\na delayed physical write.\nFilePDbCnRRels FLOAT NOT NULL -(20)9 Number of clean permanent data block disk\nsegment resident releases.\nFilePCiCnRRels FLOAT NOT NULL -(20)9 Number of clean permanent cylinder index\ndisk segment resident releases.\nFileSDbCnRRels FLOAT NOT NULL -(20)9 Number of clean regular or restartable\nspool data block disk segment resident\nreleases.\nFileSCiCnRRels FLOAT NOT NULL -(20)9 Number of clean regular or restartable\nspool cylinder index disk segment resident\nreleases.\nFileTJtCnRRels FLOAT NOT NULL -(20)9 Number of clean transient journal table or\nWAL data block or WAL cylinder index disk\nsegment resident releases.\nFileAPtCnRRels FLOAT NOT NULL -(20)9 Number of clean append table or\npermanent journal table data block or\ncylinder index disk segment resident\nreleases.\nFilePDbFDrps FLOAT NOT NULL -(20)9 Number of permanent data block disk\nsegment forced releases causing an\nimmediate memory drop.\nFilePCiFDrps FLOAT NOT NULL -(20)9 Number of permanent cylinder index disk\nsegment forced releases causing an\nimmediate memory drop.\nFileSDbFDrps FLOAT NOT NULL -(20)9 Number of regular or restartable spool data\nblock disk segment forced releases\ncausing an immediate memory drop.\nFileSCiFDrps FLOAT NOT NULL -(20)9 Number of regular or restartable spool\ncylinder index disk segment forced\nreleases causing an immediate memory\ndrop.\nFileTJtFDrps FLOAT NOT NULL -(20)9 Number of transient journal table or WAL\ndata block or WAL cylinder index disk\nsegment forced releases causing an\nimmediate memory drop.\nFileAPtFDrps FLOAT NOT NULL -(20)9 Number of append table or permanent\njournal table data block or cylinder index\ndisk segment forced releases causing an\nimmediate memory drop.\nFilePDbCnADrps FLOAT NOT NULL -(20)9 Number of clean permanent data block disk\nsegments aged out of memory.\nFilePCiCnADrps FLOAT NOT NULL -(20)9 Number of clean permanent cylinder index\ndisk segments aged out of memory.\nFileSDbCnADrps FLOAT NOT NULL -(20)9 Number of clean regular or restartable\nspool data block disk segments aged out of\nmemory.\nFileSCiCnADrps FLOAT NOT NULL -(20)9 Number of clean regular or restartable\nspool cylinder index disk segments aged\nout of memory.\nFileTJtCnADrps FLOAT NOT NULL -(20)9 Number of clean transient journal table or\nWAL data block or WAL cylinder index disk\nsegments aged out of memory.\nFileAPtCnADrps FLOAT NOT NULL -(20)9 Number of clean append table or\npermanent journal table data block or\nLake - Monitor Resources and Performance\nPage 57 of 420View Column Data T ype Format Comment\ncylinder index disk segments aged out of\nmemory.\nFileLockEnters FLOAT NOT NULL -(20)9 Number of lock requests on disk segments.\nFileLockBlocks FLOAT NOT NULL -(20)9 Number of lock requests that were blocked.\nLocks with immediate grants = Total locks -\nLocks blocked.\nFileLockDeadlocks FLOAT NOT NULL -(20)9 Number of deadlocks detected on lock\nrequests.\nFileCylMigrs FLOAT NOT NULL -(20)9 Number of cylinder migrations.\nFileCylAllocs FLOAT NOT NULL -(20)9 Number of new cylinders allocated.\nFileCylFrees FLOAT NOT NULL -(20)9 Number of logical or physical cylinders\nfreed.\nFileMCylPacks FLOAT NOT NULL -(20)9 Number of MiniCylPack operations\nperformed.\nFileCylDefrags FLOAT NOT NULL -(20)9 Number of cylinder defragments\nperformed.\nFileWCylAllocs FLOAT NOT NULL -(20)9 Number of new WAL cylinders allocated.\nFileWCylFrees FLOAT NOT NULL -(20)9 Number of times the File System logically\nfrees a cylinder.\nFileFcrRequests FLOAT NOT NULL -(20)9 Number of requests for the File System to\nuse Cylinder Read.\nRequests issued to FSG = FileFcrRequests\n- FileFcrDeniedUser.\nSuccessful Cylinder Reads =\nFileFcrRequests - FileFcrDeniedUser -\nFileFcrDeniedKern.\nFileFcrRequestsAdaptive FLOAT NOT NULL -(20)9 Number of adaptive-style Cylinder Read\nrequests from File System.\nFileFcrDeniedUser FLOAT NOT NULL -(20)9 Number of Cylinder Read requests denied\nby the File System.\nFileFcrDeniedCache FLOAT NOT NULL -(20)9 Number of Cylinder Read requests denied\nby FSG due to insufﬁcient cache.\nFileFcrDeniedThreshUser FLOAT NOT NULL -(20)9 Number of Cylinder Read requests denied\nby the File System due to insufﬁcient data\nblocks.\nFileFcrBlocksRead FLOAT NOT NULL -(20)9 Number of data blocks read in by\nsuccessful Cylinder Read operations. The\naverage number of data blocks in a\nsuccessful Cylinder read = Average data\nblocks/ Cylinder Read = FileFcrBlocksRead\n/ (FileFcrRequests - FileFcrDeniedUser -\nFileFcrDeniedKern).\nFileFcrBlocksDeniedUser FLOAT NOT NULL -(20)9 Number of data blocks contained in the File\nSystem rejected requests for Cylinder\nRead.\nFileFcrBlocksDeniedCache FLOAT NOT NULL -(20)9 Number of data blocks contained in\nCylinder Read requests rejected by the\nFSG subsystem due to insufﬁcient cache.\nFileFcrBlocksDeniedThreshUser FLOAT NOT NULL -(20)9 Number of data blocks contained in\nCylinder Read requests rejected for\nthreshold by the File System.\nFileFcrDeniedKern FLOAT NOT NULL -(20)9 Number of Cylinder Read requests denied\nby the FSG subsystem.\nFileFcrDeniedThreshKern FLOAT NOT NULL -(20)9 Number of Cylinder Read requests denied\nby the FSG subsystem due to insufﬁcient\ndata blocks.\nLake - Monitor Resources and Performance\nPage 58 of 420View Column Data T ype Format Comment\nFileFcrBlocksDeniedKern FLOAT NOT NULL -(20)9 Number of data blocks contained in the\nFSG rejected requests for Cylinder Read.\nFileFcrBlocksDeniedThreshKern FLOAT NOT NULL -(20)9 Number of data blocks contained in\nCylinder Read requests rejected for\nthreshold by the FSG subsystem.\nFileSyncScans FLOAT NOT NULL -(20)9 Number of attempts to synchronize a full\ntable scan.\nFileSyncSubtables FLOAT NOT NULL -(20)9 Number of subtables scanned by one or\nmore full table scanners that are willing to\nsynchronize scans.\nFileSyncScanners FLOAT NOT NULL -(20)9 Number of tasks involved in full table scans\nthat are willing to synchronize with other\nscanners.\nFileSyncGroups FLOAT NOT NULL -(20)9 Number of groups of scanners involved in\nfull table scans. A group consists of\nscanners who are able to use the same\nread I/O to get data from disk.\nMsgWorkQLenMax FLOAT NOT NULL -(20)9 Maximum number of work requests waiting\nduring each interval.\nMsgChnLastDone FLOAT NOT NULL -(20)9 Number of last done events that occurred\nfor this vproc. The last AMP to ﬁnish an\noperation may send a last done broadcast\nmessage indicating the work is done for this\nstep. An AMP with the most last done\nmessages can be a bottleneck in the\nsystem.\nMsgWorkQLen FLOAT NOT NULL -(20)9 Number of work requests waiting at the\ncurrent time.\nCPUUServPart00 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 0 (Kernel:\nPDE daemons).\nCPUUServPart01 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 1 (System\nDebugger).\nCPUUServPart02 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 2 (Console\nSupervisor).\nCPUUServPart03 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 3 (Console\nInteractive programs).\nCPUUServPart04 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 4 (Console\nInteractive programs).\nCPUUServPart05 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 5 (Console\nInteractive programs).\nCPUUServPart06 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 6 (Console\nInteractive programs).\nCPUUServPart07 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 7 (Service:\nConsole utilities).\nCPUUServPart08 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 8 (CNSproc:\nHost Utility console).\nCPUUServPart09 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 9 (File System\nprocesses).\nLake - Monitor Resources and Performance\nPage 59 of 420View Column Data T ype Format Comment\nCPUUServPart10 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 10 (Gateway\nprocesses).\nCPUUServPart11 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 11 (AWT).\nCPUUServPart12 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 12 (Session\ncontrol tasks).\nCPUUServPart13 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 13\n(Dispatcher/Parser).\nCPUUServPart14 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 14 (Unused).\nCPUUServPart15 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 15 (Startup\ntasks).\nCPUUServPart16 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 16 (Unused).\nCPUUServPart17 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 17 (RSS\nStartup).\nCPUUServPart18 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 18 (DDF\nservices).\nCPUUServPart19 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 19 (Metadata\nServices Gateway rsgmain).\nCPUUServPart20 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 20 (Unused).\nCPUUServPart21 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 21 (Unused).\nCPUUServPart22 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 22 (Unused).\nCPUUServPart23 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 23 (Unused).\nCPUUServPart24 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 24 (Unused).\nCPUUServPart25 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 25 (Unused).\nCPUUServPart26 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 26 (Unused).\nCPUUServPart27 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 27 (Unused).\nCPUUServPart28 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 28 (Unused).\nCPUUServPart29 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 29 (Unused).\nCPUUServPart30 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 30 (Unused).\nCPUUServPart31 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 31 (Allocator\nservices).\nCPUUServPart32 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 32 (Node\nAgent services).\nCPUUServPart33 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 33 (Clique\nCoordinator services).\nLake - Monitor Resources and Performance\nPage 60 of 420View Column Data T ype Format Comment\nCPUUServPart34 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 34 (Unused).\nCPUUServPart35 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 35 (Unused).\nCPUUServPart36 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 36 (Unused).\nCPUUServPart37 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 37 (Unused).\nCPUUServPart38 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 38 (Unused).\nCPUUServPart39 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 39 (Unused).\nCPUUServPart40 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 40 (Unused).\nCPUUServPart41 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 41 (Unused).\nCPUUServPart42 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 42 (Unused).\nCPUUServPart43 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 43 (Unused).\nCPUUServPart44 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 44 (Unused).\nCPUUServPart45 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 45 (Unused).\nCPUUServPart46 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 46 (Unused).\nCPUUServPart47 FLOAT NOT NULL -(20)9 System-level CPU time in centiseconds\nspent doing work for partition 47\n(Replication Gateway rsgdbsmain).\nCPUUExecPart00 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 0 (Kernel: PDE\ndaemons).\nCPUUExecPart01 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 1 (System\nDebugger).\nCPUUExecPart02 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 2 (Console\nSupervisor).\nCPUUExecPart03 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 3 (Console\nInteractive programs).\nCPUUExecPart04 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 4 (Console\nInteractive programs).\nCPUUExecPart05 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 5 (Console\nInteractive programs).\nCPUUExecPart06 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 6 (Console\nInteractive programs).\nCPUUExecPart07 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 7 (Service: Console\nutilities).\nCPUUExecPart08 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 8 (CNSproc: Host\nUtility console).\nLake - Monitor Resources and Performance\nPage 61 of 420View Column Data T ype Format Comment\nCPUUExecPart09 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 9 (File System\nprocesses).\nCPUUExecPart10 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 10 (Gateway\nprocesses).\nCPUUExecPart11 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 11 (AWT).\nCPUUExecPart12 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 12 (Session control\ntasks).\nCPUUExecPart13 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 13\n(Dispatcher/Parser).\nCPUUExecPart14 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 14 (Unused).\nCPUUExecPart15 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 15 (Startup tasks).\nCPUUExecPart16 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 16 (Unused).\nCPUUExecPart17 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 17 (RSS Startup).\nCPUUExecPart18 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 18 (DDF services).\nCPUUExecPart19 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 19 (Metadata Exec\nGateway rsgmain).\nCPUUExecPart20 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 20 (Unused).\nCPUUExecPart21 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 21 (Unused).\nCPUUExecPart22 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 22 (Unused).\nCPUUExecPart23 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 23 (Unused).\nCPUUExecPart24 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 24 (Unused).\nCPUUExecPart25 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 25 (Unused).\nCPUUExecPart26 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 26 (Unused).\nCPUUExecPart27 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 27 (Unused).\nCPUUExecPart28 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 28 (Unused).\nCPUUExecPart29 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 29 (Unused).\nCPUUExecPart30 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 30 (Unused).\nCPUUExecPart31 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 31 (Allocator\nservices).\nCPUUExecPart32 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 32 (Node Agent\nservices).\nCPUUExecPart33 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 33 (Clique\nCoordinator services).\nLake - Monitor Resources and Performance\nPage 62 of 420View Column Data T ype Format Comment\nCPUUExecPart34 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 34 (Unused).\nCPUUExecPart35 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 35 (Unused).\nCPUUExecPart36 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 36 (Unused).\nCPUUExecPart37 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 37 (Unused).\nCPUUExecPart38 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 38 (Unused).\nCPUUExecPart39 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 39 (Unused).\nCPUUExecPart40 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 40 (Unused).\nCPUUExecPart41 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 41 (Unused).\nCPUUExecPart42 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 42 (Unused).\nCPUUExecPart43 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 43 (Unused).\nCPUUExecPart44 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 44 (Unused).\nCPUUExecPart45 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 45 (Unused).\nCPUUExecPart46 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 46 (Unused).\nCPUUExecPart47 FLOAT NOT NULL -(20)9 User-level CPU time in centiseconds spent\ndoing work for partition 47 (Replication\nGateway rsgdbsmain).\nAllocatorExtentAllocReqs FLOAT NOT NULL -(20)9 Number of cylinder allocation requests\nreceived by the allocator.\nAllocatorExtentFreeReqs FLOAT NOT NULL -(20)9 Number of cylinder free requests received\nby the allocator.\nAllocatorMapIOsStarted FLOAT NOT NULL -(20)9 Number of map I/Os initiated by the\nallocator.\nAllocatorMapIOsDone FLOAT NOT NULL -(20)9 Number of map I/Os completed by the\nallocator.\nNodeAgentMigrationsStarted FLOAT NOT NULL -(20)9 Number of migration requests started by\nthe Node Agent.\nNodeAgentMigrationsDone FLOAT NOT NULL -(20)9 Number of migration requests completed\nby the Node Agent.\nNodeAgentStatProcessed FLOAT NOT NULL -(20)9 Number of statistics buffers processed by\nthe Node Agent.\nReadsHot FLOAT NOT NULL -(20)9 Number of reads issued to all cylinders that\nare considered HOT.\nReadsWarm FLOAT NOT NULL -(20)9 Number of reads issued to all cylinders that\nare considered WARM.\nReadsCold FLOAT NOT NULL -(20)9 Number of reads issued to all cylinders that\nare considered COLD.\nWritesHot FLOAT NOT NULL -(20)9 Number of writes issued to all cylinders that\nare considered HOT.\nWritesWarm FLOAT NOT NULL -(20)9 Number of writes issued to all cylinders that\nare considered WARM.\nWritesCold FLOAT NOT NULL -(20)9 Number of writes issued to all cylinders that\nare considered COLD.\nLake - Monitor Resources and Performance\nPage 63 of 420View Column Data T ype Format Comment\nReadResponseHotMax FLOAT NOT NULL -(20)9 Maximum read response time of all\ncylinders that are considered HOT.\nReadResponseWarmMax FLOAT NOT NULL -(20)9 Maximum read response time of all\ncylinders that are considered WARM.\nReadResponseColdMax FLOAT NOT NULL -(20)9 Maximum read response time of all\ncylinders that are considered COLD.\nWriteResponseHotMax FLOAT NOT NULL -(20)9 Maximum write response time of all\ncylinders that are considered HOT.\nWriteResponseWarmMax FLOAT NOT NULL -(20)9 Maximum write response time of all\ncylinders that are considered WARM.\nWriteResponseColdMax FLOAT NOT NULL -(20)9 Maximum write response time of all\ncylinders that are considered COLD.\nReadResponseHotMin FLOAT NOT NULL -(20)9 Minimum read response time of all cylinders\nthat are considered HOT.\nReadResponseWarmMin FLOAT NOT NULL -(20)9 Minimum read response time of all cylinders\nthat are considered WARM.\nReadResponseColdMin FLOAT NOT NULL -(20)9 Minimum read response time of all cylinders\nthat are considered COLD.\nWriteResponseHotMin FLOAT NOT NULL -(20)9 Minimum write response time of all cylinders\nthat are considered HOT.\nWriteResponseWarmMin FLOAT NOT NULL -(20)9 Minimum write response time of all cylinders\nthat are considered WARM.\nWriteResponseColdMin FLOAT NOT NULL -(20)9 Minimum write response time of all cylinders\nthat are considered COLD.\nIoRespMax FLOAT NOT NULL -(20)9 Maximum I/O response time in milliseconds\non an AMP.\nMIWriteLocks FLOAT NOT NULL -(20)9 Number of write locks acquired on a MI.\nMIWriteLockTime FLOAT NOT NULL -(20)9 MI write lock hold time in milliseconds.\nMIWriteLockTimeMax FLOAT NOT NULL -(20)9 Maximum MI write lock hold time in\nmilliseconds.\nMISleeps FLOAT NOT NULL -(20)9 Number of times that processes are\nblocked waiting for a lock on the MI.\nMISleepTime FLOAT NOT NULL -(20)9 Total amount of time in milliseconds that\nprocesses are blocked waiting for a lock on\nthe MI.\nMISleepTimeMax FLOAT NOT NULL -(20)9 Maximum amount of time in milliseconds\nthat processes are blocked waiting for a\nlock on the MI.\nDBMergeTried FLOAT NOT NULL -(20)9 Number of times the data block being\nmodiﬁed tried to be merged with adjacent\ndata blocks as part of the modiﬁcation.\nDBMergeDone FLOAT NOT NULL -(20)9 Number of successful data block merges\ndone. The number of times the data block\nbeing modiﬁed successfully merged with\nsome number of adjacent data blocks as\npart of the modiﬁcation.\nDBMergeFailed = DBMergeTried -\nDBMergeDone.\nDBMergeElim FLOAT NOT NULL -(20)9 Number of data blocks eliminated due to\ndata block merges. If n data blocks are\nmerged into one large block, where n is the\nnumber of data blocks, this number is\nincremented by n-1.\nDBMergeExtraIO FLOAT NOT NULL -(20)9 Number of additional physical I/Os\nperformed in the data block merge process\nbeyond those done if no data block merges\nwere attempted. This includes any extra\nLake - Monitor Resources and Performance\nPage 64 of 420View Column Data T ype Format Comment\nI/Os regardless of whether a merge attempt\nsucceeded or not.\nFileACPCylsSkipped FLOAT NOT NULL -(20)9 Number of cylinders AutoCylPack skipped\nwhen scanning the MI because nothing\nneeded to be done.\nFileACPCylsMigr FLOAT NOT NULL -(20)9 Number of successful migrations performed\nby AutoCylPack.\nFileACPCylsUnFSEOnly FLOAT NOT NULL -(20)9 Number of cylinders AutoCylPack could not\nmigrate because of a locking conﬂict or a\ncylinder being modiﬁed or marked down.\nInstead, AutoCylPack cleans-up the unfree\nsector entries (UnFSEs) on all cylinders,\nexcept for those that are down.\nFileACPCylsPostponed FLOAT NOT NULL -(20)9 Number of cylinders AutoCylPack could not\nmigrate due to conﬂicts with foreground\ntasks modifying the cylinder at around the\nsame time as AutoCylPack. AutoCylPack\npostpones the work until the next time it\nscans the MI from the beginning.\nFileCompDBs FLOAT NOT NULL -(20)9 Number of data blocks compressed.\nFileUnCompDBs FLOAT NOT NULL -(20)9 Number of data blocks uncompressed.\nFileCompTempDBs FLOAT NOT NULL -(20)9 Number of data blocks compressed by the\nAutoTempComp background task .\nFileUncompTempDBs FLOAT NOT NULL -(20)9 Number of data blocks uncompressed by\nthe AutoTempComp background task .\nFileCompCylMigrs FLOAT NOT NULL -(20)9 Number of cylinder migrates done by the\nAutoTempComp background task. The\nAutoTempComp background task is\nresponsible for ﬁnding the cylinders to\ncompress or decompress based on their\ntemperature.\nFileUnCompCylMigrs FLOAT NOT NULL -(20)9 Number of cylinder migrates done by the\nAutoTempComp background task.\nFsgCacheWaits FLOAT NOT NULL -(20)9 Number of times the File System waits for\nmemory to become available in the ﬁle\nsegment cache when trying to read data\nfrom disk.\nFsgCacheWaitTime FLOAT NOT NULL -(20)9 Amount of time the File System waits for\nmemory to become available in the ﬁle\nsegment cache when trying to read data\nfrom disk.\nFsgCacheWaitTimeMax FLOAT NOT NULL -(20)9 Maximum amount of time the File System\nwaits for memory to become available in the\nFile System cache when trying to read data\nfrom disk.\nUdfServ FLOAT NOT NULL -(20)9 Reported system-level UDF CPU time in\ncentiseconds.\nUdfExec FLOAT NOT NULL -(20)9 Reported user execution UDF CPU time in\ncentiseconds.\nFileSorts FLOAT NOT NULL -(20)9 Number of sort requests, including the\nlarge memory sort requests.\nFileLargeMemSorts FLOAT NOT NULL -(20)9 Number of large memory sort requests\nexecuted. Large memory sort uses large\nbuffers (1 MB buffers) and up to 1 GB of\nmemory.\nFileLargeMemSortsDenied FLOAT NOT NULL -(20)9 Number of large memory sort requests\ndenied.\nFileWALBufBusy FLOAT NOT NULL -(20)9 Number of times a WAL append operation\nresulted in a buffer switch that waited for\nthe next buffer to exit a Busy state.\nLake - Monitor Resources and Performance\nPage 65 of 420View Column Data T ype Format Comment\nFileWALSize FLOAT NOT NULL -(20)9 Current size of the WAL log in cylinders.\nWhen WAL cylinders are allocated or freed,\nthe counter is increased or decreased by\nthe corresponding number of cylinders.\nSpaceProactiveAllocs FLOAT NOT NULL -(20)9 Total number of proactive space allocations\nmade in the AMP VPROC.\nSpaceGroupAllocs FLOAT NOT NULL -(20)9 Total number of group space allocations\ninitiated in the AMP VPROC.\nSpaceMsgsCnt FLOAT NOT NULL -(20)9 Total number of space allocation and de-\nallocation messages processed by the\nspace accounting task.\nFileCompDBs_HW FLOAT NOT NULL -(20)9 Number of data blocks compressed by HW\ncard.\nFileUnCompDBs_HW FLOAT NOT NULL -(20)9 Number of data blocks uncompressed by\nHW card.\nTJPurges FLOAT NOT NULL -(20)9 Number of purge passes in which a block-\nby-block scan is done.\nTJDbPurgeReads FLOAT NOT NULL -(20)9 Number of blocks mapped in during the\npurge scan.\nTJDbPurgeDeletes FLOAT NOT NULL -(20)9 Number of blocks mapped in during the\nscan that were included in the ranges of\nblocks that were deleted.\nUdfMemInuseKB FLOAT NOT NULL -(20)9 Current total KB of resident memory in use\nby the UDF secure server processes,\nexcluding the STO child processes.\nUdfVmSizeKB FLOAT NOT NULL -(20)9 Current total KB of virtual memory occupied\nby the UDF secure server processes,\nexcluding the STO child processes.\nTDEnabledCPUs FLOAT NOT NULL -(20)9 Number of CPUs available for Teradata\ntasks at the end of the reporting period.\nMonitor Compute Cluster Events\nCompute clusters are elastic compute resources that can be created, started, stopped, hibernated and released dynamically to provide the necessary compute resources when\nneeded, and removed when no longer needed. To better understand the behavior of these compute resources, you can leverage the views and underlying tables to gain insight into\nthe state of your compute clusters and the events that changed a compute cluster state.\nUse these views for these monitoring purposes:\nUnderstand how compute clusters are automatically scaling\nEvaluate the compute proﬁle deﬁnitions for your compute groups\nAssess whether the compute clusters are of the right instance size\nMake sure your compute clusters are starting up and cooling down appropriately\nForeign table deﬁnitions and view deﬁnitions reside in the td_metric_svc database.\nLearn about the data each view contains:\nComputeProﬁleHistoryV[X]\nComputeProﬁleHistoryEventsV[X]\nComputeProfileHistoryV[X]\nDatabase: td_metric_svc\nIf you need detailed information about the events that determine a change to the state of your compute cluster, use this view to:\nDetermine when a compute cluster autoscaled up or down.\nIdentify events that bring a compute cluster online or ofﬂine.\nValidate the identify overlap between different compute proﬁles in a compute group.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\nEventTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the compute cluster\nevent was recorded.\nLake - Monitor Resources and Performance\nPage 66 of 420View Column Data T ype Format Comment\nInstanceName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the name of the instance.\nComputeGroupName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the compute group name to which\nthe compute proﬁle is associated to.\nComputeProﬁleName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the name of the compute proﬁle.\nComputeGroupID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the ID of the compute group.\nComputeID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the ID of the compute cluster.\nSystemID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the internal ID of the customer\nSystem.\nState VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the status of the compute cluster.\nComputeMapName VARCHAR(512) UNICODE NOT\nCASESPECIFIC|X(512) Returns the name of the compute map.\nComponent_ID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the operational group compute\ncluster ID.\nNodeCount SMALLINT -(5)9 Returns the node count of the compute\nmap.\nInstanceType VARCHAR(30) LATIN UPPERCASE X(30) Returns the instance type of the compute\nmap.\nAMPsPerNode SMALLINT -(5)9 Returns the AMPs per Node of the compute\nmap.\nComputeProfileHistoryEventsV[X]\nDatabase: td_metric_svc\nIf you need detailed information about the duration during which compute resources are in a given state, use this view to:\nCompute the amount of time during a month when compute clusters were available.\nIdentify time periods when compute clusters were hibernated.\nView Column Data T ype Format Comment\nInstanceName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the name of the instance.\nComputeGroupName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the compute group name to which\nthe compute proﬁle is associated to.\nComputeProﬁleName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the name of the compute proﬁle.\nComputeID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the ID of the compute cluster.\nComputeGroupID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the ID of the compute group.\nSystemID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the internal ID of the customer\nSystem.\nStartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the timestamp for the compute\ncluster event online.\nEndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the timestamp for the compute\ncluster event ofﬂine/dropped.\nComputeMapName VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the name of the compute map.\nComponent ID VARCHAR(512) UNICODE NOT\nCASESPECIFICX(512) Returns the operational group compute\ncluster ID.\nNodeCount SMALLINT -(5)9 Returns the node count of the compute\nmap.\nInstanceType VARCHAR(30) LATIN UPPERCASE X(30) Returns the instance type of the compute\nmap.\nLake - Monitor Resources and Performance\nPage 67 of 420View Column Data T ype Format Comment\nAMPsPerNode SMALLINT -(5)9 Returns the AMPs per node of the compute\nmap.\nMonitor Queries\nUse these query logging views to monitor past query performance. To monitor active running queries, use VantageCloud Lake. See Monitoring and Managing Queries.\nThese query logging views are based on the similarly named foreign tables in your object storage that contain monitoring data transferred from your system.\nLearn about the data each query logging view contains:\ndbqlexplainV\ndbqlobjV\ndbqlogV\ndbqlsqlV\ndbqlstepV\ndbqlsummaryV\ndbqlutilityV\ndbqlexplainV\nDatabase: td_metric_svc\nContains the explain information in an unformatted string without line breaks.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the query log was\ngenerated.\nParentReqStartTime TIMESTAMP YYYY-MM-DDBHH:MI:SS.S(6) Returns the time when the parent request\nwas submitted.\nQueryID DECIMAL -(18)9 Returns the QueryId column contains the\ngenerated query id for the given query.\nParentQueryID DECIMAL -(18)9 Returns the parent system generated query\nid for this query.\nZoneID BYTE(4) NOT NULL X(8) Returns the zone ID.\nExpRowNo INTEGER NOT NULL --,---,---,--9 Returns row number if explain text is greater\nthan 64KB and the system generates\nmultiple rows.\nExplainText VARCHAR(31000) UNICODE NOT\nCASESPECIFIC NOT NULLX(31000) Returns a full Explain Text segment.\nThe view also contains ExtraFieldX columns that are reserved for future use.\nExample: dbqlexplainV - SELECT\nThis SELECT statement retrieves the QueryID and ExplainText for a QueryID.\nLake - Monitor Resources and Performance\nPage 68 of 420SELECT Queryid, Explaintext\n     FROM td_metric_svc.dbqlexplainV WHERE Queryid = 201205134619838011;\nThe output from the SELECT statement (the ExplainText) does not contain any format; it is one long string.\ndbqlobjV\nDatabase: td_metric_svc\nStores information on the target objects of the query being logged. One row is logged for each object referenced by the query.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the query log was\ngenerated.\nParentReqStartTime TIMESTAMP YYYY-MM-DDBHH:MI:SS.S(6) Returns the time when the parent request\nwas submitted.\nQueryID DECIMAL(18,0) NOT NULL -(18)9 Returns the QueryId column contains the\ngenerated query id for the given query.\nParentQueryID DECIMAL -(18)9 Returns the parent system generated query\nid for this query.\nObjectDatabaseName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Name of the database that owns the target\nobject.\nObjectTableName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of table or view.\nObjectColumnName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the column.\nObjectID BYTE(4) NOT NULL X(8) Returns the internal ID of the object.\nObjectNum INTEGER --,---,---,--9 Returns the number of the index in the\ntable.\nObjectType CHAR(3) LATIN NOT CASESPECIFIC NOT\nNULLX(3) Returns a character code indicating the\ntype of object targeted. D is for database\nlevel, T for table level, Q for Backup or\nrestore of selected partitions or J for journal.\nFreqofUse INTEGER --,---,---,--9 Returns the number of times the object was\naccessed, as determined by the Optimizer,\nto process the query.\nTypeofUse BYTEINT -(3)9 Returns the use of the object.\nTargetIndicator CHAR(1) LATIN X(1) Indicates whether the object was the target\nof a write operation.\nThe view also contains ExtraFieldX columns that are reserved for future use.\nExample: dbqlobjV - SELECT\nLake - Monitor Resources and Performance\nPage 69 of 420The following SELECT statement retrieves the object information of a query:\nSELECT QueryID, ObjectDatabaseName (Named ObjDBName), ObjectTableName (Named ObjTblName), ObjectColumnName (Named ObjColName), ObjectID (\nFROM td_metric_svc.dbqlobjV where queryid = 201205134619838031;\nResult:\nQueryID            ObjDBName    ObjTblName  ObjColName ObjID    ObjNum   ObjType  FreqofUse\n------------------ -----------  ----------  ---------- -------- -------  -------- ------\n201205134619838031 D_PERSONNEL  ?            ?         00001604   0        DB      1\n201205134619838031 D_PERSONNEL  DEPARTMENT   ?         00009005   0        Tab     1\n201205134619838031 D_PERSONNEL  DEPARTMENT   DeptNo    00009005   1,025    Col     2\n201205134619838031 D_PERSONNEL  DEPARTMENT   DeptName  00009005   1,026    Col     1\n201205134619838031 D_PERSONNEL  DEPARTMENT   EmpCount  00009005   1,027    Col     1\n201205134619838031 D_PERSONNEL  DEPARTMENT   Loc       00009005   1,028    Col     1\ndbqlogV\nDatabase: td_metric_svc\nThe main table containing information about queries being logged.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the query log was\ngenerated.\nQueryID DECIMAL(18,0) NOT NULL -(18)9 Returns a system-wide unique ID to identify\nthe query.\nUserID BYTE(4) NOT NULL X(8) Returns the ID of the user.\nAcctString VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the user unexpanded logon\naccount string.\nExpandAcctString VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the expanded logon string of the\nuser.\nSessionID INTEGER NOT NULL --,---,---,--9 Returns the unique identiﬁcation number of\nthe session.\nLogicalHostID SMALLINT NOT NULL -(5)9 Returns a unique identiﬁer of the logon\nsource for the logged query. A value of zero\nindicates an internal session.\nRequestNum INTEGER NOT NULL --,---,---,--9 Returns the client request number for all\nqueries.\nInternalRequestNum INTEGER NOT NULL --,---,---,--9 Returns the internal request number used\nby the database system.\nLogonDateTime TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the date and time that the session\nwas logged on.\nAcctStringTime FLOAT 99:99:99 Returns the result from the &T code when\nthe user has speciﬁed Account String\nLake - Monitor Resources and Performance\nPage 70 of 420View Column Data T ype Format Comment\nExpansion (ASE).\nAcctStringHour SMALLINT -(5)9 Returns the result from the &H code when\nthe user has speciﬁed Account String\nExpansion (ASE).\nAcctStringDate DATE YYYY/MM/DD Returns the result from the &D code when\nthe user has speciﬁed Account String\nExpansion (ASE).\nLogonSource CHAR(128) LATIN NOT CASESPECIFIC X(128) Returns the logon source string text.\nAppID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Returns the application ID.\nClientID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Returns the client ID.\nClientAddr CHAR(45) UNICODE NOT CASESPECIFIC X(45) Returns the IP address of the client who\nsubmitted the query.\nQueryBand VARCHAR(12304) UNICODE NOT\nCASESPECIFICX(12304) Returns the query band under which the\nrequest was submitted if it was submitted\nunder a query band.\nProﬁleID BYTE(4) X(8) Returns the unique number assigned to the\ncost proﬁle instance in the system.\nStartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the time the query is submitted.\nFirstStepTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the time the ﬁrst step for this query\nis dispatched.\nFirstRespTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the timestamp when the ﬁrst\nresponse packet is sent to host.\nLastStateChange TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the time of the last state change\nthrough the Teradata dynamic workload\nmanagement software.\nNumSteps SMALLINT ---,--9 Returns the total number of (level 1) steps\nfor this query.\nNumStepswPar SMALLINT ---,--9 Returns the number of (level 1) steps with\nparallel steps.\nMaxStepsInPar SMALLINT ---,--9 Returns the maximum number of (level 2)\nsteps done in parallel for this query.\nNumResultRows FLOAT ----,---,---,---,--9 Returns the total number of rows returned\nfor the query.\nTotalIOCount FLOAT ----,---,---,---,--9 Returns the number of IOs from AMPs that\nwere generated by the query.\nAMPCPUTime FLOAT ----,---,---,---,--9.999 Returns the total AMP CPU time in seconds\nused for query.\nParserCPUTime FLOAT ----,---,---,---,--9.999 Returns the total parser and dispatcher\nCPU time in seconds (with .001 resolution)\nused for the query.\nUtilityByteCount BIGINT --,---,---,---,---,---,--9 Returns the number of bytes transferred by\nclient as part of FastLoad or MultiLoad job.\nUtilityRowCount FLOAT ----,---,---,---,--9 Returns the number of rows loaded by\nFastLoad or MultiLoad.\nErrorCode INTEGER --,---,---,--9 Returns error code if the query caused a\nParser syntax error.\nErrorText VARCHAR(1024) UNICODE NOT\nCASESPECIFICX(1024) Returns the text from the error if ErrorCode\nis not 0.\nWarningOnly CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns warning code T for true if the error\nwas reported while running TDWM in the\nwarning mode.\nDelayTime FLOAT ----,---,---,---,--9.999 Returns the seconds a query was delayed\nby the Teradata dynamic workload\nmanagement software.\nAbortFlag CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns T (yes) if this query was aborted.\nCacheFlag CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns blank if the query is not found in\nstep cache. The possible values are T, G, S,\nLake - Monitor Resources and Performance\nPage 71 of 420View Column Data T ype Format Comment\nand A.\nStatementType CHAR(20) LATIN NOT CASESPECIFIC X(20) Returns the type of statement in the request\n(a 20 character ﬁeld is used to describe the\nstatement).\nQueryText VARCHAR(10000) UNICODE NOT\nCASESPECIFICX(10000) Returns the query text. The default size is\n200 characters.\nNumOfActiveAMPs INTEGER --,---,---,--9 Returns the number of AMPS that were\nactive for this query.\nMaxAMPCPUTime FLOAT ----,---,---,---,--9.999 Returns the CPU time in seconds (with .001\nresolution) of the AMP with the highest CPU\nusage in the query.\nMaxCPUAmpNumber INTEGER --,---,---,--9 Returns the number of the AMP with the\nhighest CPU activity.\nMinAmpCPUTime FLOAT ----,---,---,---,--9.999 Returns the CPU time in seconds (with .001\nresolution) of the AMP with the lowest CPU\nusage for the query..\nMaxAmpIO FLOAT ----,---,---,---,--9 Returns the I/O count of the highest I/O\nused AMP in the query.\nMaxIOAmpNumber INTEGER --,---,---,--9 Returns the number of the AMP with the\nhighest IO usage for this query.\nMinAmpIO FLOAT ----,---,---,---,--9 Returns the I/O count of the lowest I/O used\nAMP in the query.\nSpoolUsage BIGINT --,---,---,---,---,---,--9 Returns peak spool usage (bytes) of any\nstep in the query (DataCollectAlg=3).\nOtherwise, number of bytes used for spool\nin the query.\nWDID INTEGER --,---,---,--9 Returns the workload deﬁnition (WD)\nnumber assigned to the query.\nOpEnvID INTEGER --,---,---,--9 Returns the ID of the operational\nenvironment currently activated by the\nTeradata dynamic workload management\nsoftware.\nSysConID INTEGER --,---,---,--9 Returns the ID of the system condition\ncurrently activated by the Teradata dynamic\nworkload management software.\nLSN INTEGER --,---,---,--9 Returns the Logon Sequence Number used\nfor a load utility.\nNoClassiﬁcation CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns T(yes) if the query was not\nclassiﬁed.\nWDOverride CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns T(yes) if the WD was overridden by\nthe user.\nResponseTimeMet CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns T (yes) if the query met service\nlevel goals.\nExceptionValue INTEGER --,---,---,--9 Returns the type of Teradata dynamic\nworkload management software exception\noccurred.\nFinalWDID INTEGER --,---,---,--9 Returns the workload deﬁnition in which the\nquery completed execution.\nTDWMEstMaxRows FLOAT ----,---,---,---,--9 Returns the estimated maximum rows as\ngenerated by Optimizer.\nTDWMEstLastRows FLOAT ----,---,---,---,--9 Returns the estimated last step row number\nas generated by Optimizer.\nTDWMEstTotalTime FLOAT ----,---,---,---,--9 Returns the estimated total time in\nmilliseconds as generated by Optimizer.\nThe resolution of estimated time is .01 in\nviews and .001 on disk.\nTDWMAllAmpFlag CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns T (yes) if one of the steps in the\nquery was an all-AMP step.\nLake - Monitor Resources and Performance\nPage 72 of 420View Column Data T ype Format Comment\nTDWMConfLevelUsed CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns the minimum conﬁdence level that\nthe Teradata dynamic workload\nmanagement software is allowed to use in\nlooking at estimated data.\nTDWMRuleID INTEGER --,---,---,--9 Returns rule identiﬁer of the query.\nUserName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the user who issued\nthe query.\nDefaultDatabase VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the current default\ndatabase used in the query.\nAMPCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized AMP CPU time in\nseconds for co-existence systems.\nParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized parser CPU time in\nseconds (with .001 resolution) for co-\nexistence systems.\nMaxAMPCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized CPU time in\nseconds (with .001 resolution) of the AMP\nwith maximum CPU usage in the query.\nMaxCPUAmpNumberNorm INTEGER --,---,---,--9 Returns the number of the AMP with the\nhighest CPU activity.\nMinAmpCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized CPU Time in\nseconds (with .001 resolution) of the AMP\nwith minimum CPU usage in the query.\nEstResultRows FLOAT ----,---,---,---,--9 Returns estimated number of rows returned\nby this query.\nEstProcTime FLOAT ----,---,---,---,--9.999 Returns the estimated processing time in\nseconds (with .001 resolution) from the\nOptimizer.\nEstMaxRowCount FLOAT ----,---,---,---,--9 Maximum of estimated row count for the\nsteps in this query.\nProxyUser VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the proxy user.\nProxyRole VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the role name of a proxy\nconnection.\nStatementGroup VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the grouping the statement belongs\nto (DDL, DML, or SELECT). For a multiple-\nstatement request, this value indicates the\nnumber of different statement types in the\nrequest.\nSessionTemporalQualiﬁer VARCHAR(1024) UNICODE NOT\nCASESPECIFICX(1024) Returns the session temporal qualiﬁer in\neffect when the query is logged.\nCalendarName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the active business\ncalendar.\nSessionWDID INTEGER --,---,---,--9 Returns the workload ID class associated\nwith the session. It determines the priority of\nthe session when the TDWM workload\nclassiﬁcation is active.\nDataCollectAlg BYTEINT -(3)9 Returns CPU/IO collection algorithm used\nby DBQL. Possible values include: 1-\nClassic Algo|2- Use Algo 2|3- Use Algo 3.\nParserExpReq FLOAT ----,---,---,---,--9.999 Returns the number of seconds the parser\nwaited on an express request.\nCallNestingLevel BYTEINT -(3)9 Returns the level of nesting when running in\nstored procedures.\nNumRequestCtx BYTEINT -(3)9 Returns the number of request contexts\nassociated with the session.\nKeepFlag CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns value (Y) or (N) to indicate whether\nto keep the response parcel until the client\nresponds that it is no longer needed.\nLake - Monitor Resources and Performance\nPage 73 of 420View Column Data T ype Format Comment\nQueryRedriven CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns value (Y) or (N) to indicate if the\nquery was re-driven.\nReDriveKind CHAR(10) LATIN NOT CASESPECIFIC X(10) Returns the type of reset protection with\nwhich the query was re-driven. (MN)-\nMemory, (DF)-Dictionary table Fallback\nresponses, (DN)-Dictionary Table Non-\nfallback responses.\nCPUDecayLevel SMALLINT ---,--9 Returns the most severe decay level\nreached for CPU usage during the life of the\nrequest at node level.\nIODecayLevel SMALLINT ---,--9 Returns the most severe decay level\nreached for IO usage during the life of the\nrequest at node level.\nTacticalCPUException INTEGER --,---,---,--9 Returns the number of nodes that\nencountered a CPU exception.\nTacticalIOException INTEGER --,---,---,--9 Returns the number of nodes that\nencountered an I/O exception.\nSeqRespTime FLOAT ----,---,---,---,--9.999 Contains sum of the response time of all\nsteps as if they had been run sequentially in\nunits of seconds.\nReqIOKB FLOAT ----,---,---,---,--9.999 Returns total logical I/O usage in kilobytes.\nReqPhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os.\nReqPhysIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in\nkilobytes.\nNumFragments INTEGER --,---,---,--9 Returns the number of fragments in a IPE\nplan execution of request.\nCheckpointNum FLOAT ----,---,---,---,--9 Returns the checkpoint interval number for\nMLOADX.\nUnityTime FLOAT ----,---,---,---,--9.999 Returns the time in seconds the stored\nprocedure request was being processed by\nUnity.\nLockDelay FLOAT ----,---,---,---,--9.999 Returns the maximum wait time to get a\nlock on object in centiseconds.\nLastRespTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the last response Timestamp.\nDisCPUTime FLOAT ----,---,---,---,--9.999 Returns the CPU time in seconds used by\nthe dispatcher.\nStatements INTEGER --,---,---,--9 Returns the Number of statements in the\nrequest.\nDiscCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the Normalized dispatcher CPU\ntime in seconds.\nTxnMode CHAR(10) LATIN NOT CASESPECIFIC X(10) Returns the transaction mode of this query\n(ANSI, BTET).\nRequestMode CHAR(5) LATIN NOT CASESPECIFIC X(5) Returns the request mode of this query.\nUtilityInfoAvailable CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns (Y) to Indication if a request also\nhas utility information available in the\nDBQLUtilityTbl table.\nUnitySQL CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns (Y) to indicates Unity requested the\nSQL be modiﬁed. This is set when Unity\nasks for Unity transaction table to be\nupdated.\nThrottleBypassed CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns whether the request was only\nallowed to run due to the throttlebypass\nfeature of TDWM.\nDBQLStatus INTEGER --,---,---,--9 Returns internal DBQL logging status. Zero\nindicates no status conditions\n(DataCollectAlg=3).\nIterationCount INTEGER --,---,---,--9 Returns the iteration count for data parcel\nassociated with a request.\nLake - Monitor Resources and Performance\nPage 74 of 420View Column Data T ype Format Comment\nVHLogicalIO FLOAT ----,---,---,---,--9.999 Returns the total number of Very Hot logical\nI/Os for the whole request.\nVHPhysIO FLOAT ----,---,---,---,--9.999 Returns the total number of Very Hot\nPhysical I/Os for the whole request.\nVHLogicalIOKB FLOAT ----,---,---,---,--9.999 Returns the total Very Hot logical I/Os in\nkilobytes for the whole request.\nVHPhysIOKB FLOAT ----,---,---,---,--9.999 Returns the total Very Hot Physical I/Os in\nkilobytes for the whole request.\nTDWMEstMemUsage FLOAT ----,---,---,---,--9.999 Returns the estimated memory usage in\nMBs for query.\nMaxStepMemory FLOAT ----,---,---,---,--9.999 Returns the maximum memory in MBs used\nby any one step in the request.\nTotalServerByteCount BIGINT --,---,---,---,---,---,--9 Total bytes sent and received from the\nforeign server.\nProxyUserID BYTE(4) X(8) Returns the internal ID of the proxy user if\nthe proxy user is a permanent user.\nTxnUniq BYTE(4) X(8) Returns the transaction Uniq portion used\nwith ProcId.\nLockLevel VARCHAR(10) LATIN NOT CASESPECIFIC X(10) Returns the highest level lock associated\nwith this request.\nTTGranularity VARCHAR(30) UNICODE NOT\nCASESPECIFIC NOT NULLX(30) Returns the Granularity of Transaction Time\nfor the session speciﬁed by the most recent\nSET SESSION TTGranularity request or\nSession default.\nProﬁleName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the proﬁle, if any,\nunder which the user submitted the query.\nWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the workload deﬁnition (WD) name\nassigned to the query.\nFlexThrottle CHAR(1) LATIN NOT CASESPECIFIC X(1) Flag 'T' indicates this query was released\nfrom the TDWM delay queue due to the Flex\nThrottle feature.\nEstMaxStepTime FLOAT ----,---,---,---,--9.999 The estimated maximum step time in\nseconds from the Optimizer.\nParamQuery CHAR(1) LATIN NOT CASESPECIFIC X(1) Flag 'T' indicates the query is\nparameterized.\nRemoteQuery CHAR(1) LATIN NOT CASESPECIFIC X(1) Flag 'T' indicates a remote query has been\nsubmitted.\nPersistentSpool BIGINT --,---,---,---,---,---,--9 Persistent part of SpoolUsage.\nMinRespHoldTime FLOAT ----,---,---,---,--9.999 Seconds response was held to meet the\nminimum response time.\nTotalFirstRespTime FLOAT ----,---,---,---,--9.999 DelayTime + Execution Time +\nMinRespHoldTime (in seconds).\nMaxOneMBRowSize INTEGER --,---,---,--9 The actual size in bytes of the largest 1MB\nrow in the set of rows returned for the query.\nNumResultOneMBRows FLOAT ----,---,---,---,--9 The number of 1MB rows (1MB > size >\n64KB) in the set of rows returned for the\nquery.\nMaxNumMapAMPs INTEGER --,---,---,--9 The number of AMPs in the largest\ncontiguous map used by the request.\nMinNumMapAMPs INTEGER --,---,---,--9 The number of AMPs in the smallest\ncontiguous map used by this request.\nSysDefNumMapAMPs INTEGER --,---,---,--9 Number of AMPs in the system-default\nmap.\nFeatureUsage VARBYTE(256) X(512) This column logs the bitmap of features\nbeing used by the request.\nReqMaxSpool BIGINT --,---,---,---,---,---,--9 Maximum spool usage by the request.\nLake - Monitor Resources and Performance\nPage 75 of 420View Column Data T ype Format Comment\nNumAMPsImpacted INTEGER --,---,---,--9 Number of AMPs contributed to the\nReqMaxSpool.\nUsedIota FLOAT ----,---,---,---,--9.999 Return IO Tokens used by the requests.\nOpEnvName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) The TDWM operating environment name\nassociated with the OpEnvId.\nSysConName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) The TDWM System Health Condition name\nassociated with the SysConId.\nFinalWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the workload deﬁnition in which the\nquery completed execution.\nSessionWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) The TDWM workload name used for parsing\nactivity.\nMapAmpsMapNo INTEGER --,---,---,--9 MapNo with the maximum number of AMPs.\nAutoDBAData CHAR(1) LATIN NOT CASESPECIFIC X(1) Values indicate if the request contains\nAutoDBA Data.\nUAFName CHAR(10) LATIN NOT CASESPECIFIC X(10) Name of an Analytic Function being run by\nEXECUTE FUNCTION. The default is NULL.\nUnityQueryType BYTEINT -(3)9 Indicates if it is a replayed SQL or CDA.\nTacticalRequest CHAR(1) LATIN NOT CASESPECIFIC X(1) 'T' indicating that the request was tactical,\nNULL otherwise.\nDefaultDBCacheUsed CHAR(1) LATIN NOT CASESPECIFIC X(1) 'T' indicating that default DB is used in the\nstep cache, NULL otherwise.\nReqAWTTime FLOAT ----,---,---,---,--9.999 AWT elapsed time in seconds for the\nrequest.\nMaxReqAwtTime FLOAT ----,---,---,---,--9.999 Max AWT elapsed time in seconds for the\nrequest.\nMaxReqAWTTimeAmpNum INTEGER --,---,---,--9 AMP number that had max AWTTime for the\nrequest.\nMinReqAWTTime FLOAT ----,---,---,---,--9.999 Min AWT elapsed time in seconds for the\nrequest.\nUDFVMData FLOAT ----,---,---,---,--9.999 UDF Virtual memory data size for the\nrequest.\nUDFVMPeak FLOAT ----,---,---,---,--9.999 UDF Virtual memory peak for the request.\nTotalUDFMemUsage FLOAT ----,---,---,---,--9.999 Total memory used by UDF for the request.\nMaxReqUDFMemUsage FLOAT ----,---,---,---,--9.999 Max memory used by UDF for the request.\nMaxReqUDFMemUsageAmpNum INTEGER --,---,---,--9 AMP number that had max memory used\nby UDF for this request.\nPGRCTimeToGetPlan FLOAT ----,---,---,---,--9.999 Time taken for communication between\ncache management threads and session\nthread to get plan from target PE when\nPartitioned Global Request Cache feature is\nON.\nNosRecordsReturned BIGINT --,---,---,---,---,---,--9 Number of records returned by a Native\nObject Store request.\nNosRecordsSkipped BIGINT --,---,---,---,---,---,--9 Number of records skipped by a Native\nObject Store request.\nNosPhysReadIO BIGINT --,---,---,---,---,---,--9 Total physical read IOs for Native Object\nStore ﬁles.\nNosPhysReadIOKB BIGINT --,---,---,---,---,---,--9 Total KB of physical read IOs for Native\nObject Store ﬁles.\nNosRecordsReturnedKB FLOAT ----,---,---,---,--9.999 Total KB of records returned for Native\nObject Store ﬁles.\nNosTotalIOWaitTime FLOAT ----,---,---,---,--9.999 Total of the Native Object Store IO wait time\nfor the request.\nNosMaxIOWaitTime FLOAT ----,---,---,---,--9.999 Max Native Object Store IO wait time for the\nrequest.\nLake - Monitor Resources and Performance\nPage 76 of 420View Column Data T ype Format Comment\nNosCPUTime FLOAT ----,---,---,---,--9.999 CPU time for reading Native Object Store\nﬁles for the request. This time is already\nincluded in other non-NOS CPU ﬁelds.\nNosTables INTEGER --,---,---,--9 Total number of Native Object Store tables\naccessed in the request. Access through\nREAD_NOS does not increment this ﬁeld,\nalthough it does increment the other NOS\nﬁelds.\nNosFiles INTEGER --,---,---,--9 Number of Native Object Store ﬁle reads\nwere attempted on by this request.\nNosFilesSkipped INTEGER --,---,---,--9 Number of Native Object Store ﬁles that\nwere skipped.\nStepCacheHash INTEGER --,---,---,--9 Step cache hash value of this request if\ncached.\nTDWMMSRCount INTEGER --,---,---,--9 Statement count ignoring BT, ET, ParNull,\nParMTmp.\nDeferTime FLOAT ----,---,---,---,--9.999 The number of seconds a query was\ndeferred by workload management due to\nARM rules.\nDeferRuleID INTEGER --,---,---,--9 TDWM Rule ID of one of the ARM rules\nwhich caused this request to be deferred.\nTDWMAdmissionTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) The time when a request is admitted into\nthe system by workload management (that\nis, after ARM processing).\nStmtDMLRowCount VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Row count for DML (Update/Insert/Delete)\nstatements.\nUnityQueryForeignInfo VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Contains UnityForeignQueryID and\nUnityForeignSystemID.\nNumJoinSteps SMALLINT ---,--9 Returns the total number of join steps for\nthis query.\nNumSumSteps SMALLINT ---,--9 Returns the total number of sum steps for\nthis query.\nPGRCTgtPENum SMALLINT ---,--9 Returns the target PE number which holds\nthe PSTEPS for this request when PGRC\nfeature is ON.\nNosPhysWriteIO BIGINT --,---,---,---,---,---,--9 Total physical IOs were written for Native\nObject Store ﬁles for this request.\nNosPhysWriteIOKB BIGINT --,---,---,---,---,---,--9 Total KB of physical IOs written for Native\nObject Store ﬁles for this request.\nNosCacheReadIO BIGINT --,---,---,---,---,---,--9 Total Cache Read IOs for Native Object\nStore ﬁles for this request.\nNosCacheReadIOKB BIGINT --,---,---,---,---,---,--9 Total Cache read IOs in KB for Native\nObject Store ﬁles for this request.\nNosPhysDataReadIO BIGINT --,---,---,---,---,---,--9 Total physical data read IOs for Native\nObject Store ﬁles for this request.\nNosPhysDataReadIOKB BIGINT --,---,---,---,---,---,--9 Total physical Data read IOs in KB for\nNative Object Store ﬁles for this request.\nNosPrefetchReadIO BIGINT --,---,---,---,---,---,--9 Total Read Ahead IOs for Native Object\nStore ﬁles for this request.\nNosPrefetchReadIOKB BIGINT --,---,---,---,---,---,--9 Total Read Ahead IOs in KB for Native\nObject Store ﬁles for this request.\nNosFilesWritten BIGINT --,---,---,---,---,---,--9 The number of ﬁle writes attempted by\nNative Object Store in this request.\nNosFilesDeleted BIGINT --,---,---,---,---,---,--9 The total number of ﬁles deleted for Native\nObject Store ﬁles for this request.\nNosDeleteIO BIGINT --,---,---,---,---,---,--9 Total IOs to delete for Native Object Store\nﬁles for this request.\nLake - Monitor Resources and Performance\nPage 77 of 420View Column Data T ype Format Comment\nNosDeleteIOKB BIGINT --,---,---,---,---,---,--9 Total IOs in KB to delete for Native Object\nStore ﬁles for this request.\nNosNumDeleteSuccess INTEGER --,---,---,--9 The number of ﬁles successfully deleted by\nNative Object Store for this request.\nNosNumDeleteFailure INTEGER --,---,---,--9 The number of failed ﬁle deletes by Native\nObject Store for this request.\nReqLocSpoolUsage BIGINT --,---,---,---,---,---,--9 Total local spool usage for the request in\nbytes.\nReqPhysLocIO FLOAT ----,---,---,---,--9.999 Total local physical IO count for the request.\nReqPhysLocIOKB FLOAT ----,---,---,---,--9.999 Total local physical IO for the request in\nkilobytes.\nReqPeakAmpPrvMem FLOAT ----,---,---,---,--9.999 Total peak private memory in MB based on\nrequested size used by anyone AMP in the\nrequest.\nReqPeakAmpPrvMemAmpNum INTEGER --,---,---,--9 AMP number that reported total peak\nprivate memory based on the requested\nsize used in the request.\nReqPeakAmpShrMem FLOAT ----,---,---,---,--9.999 Total peak shared memory in MB based on\nrequested size used by anyone AMP in the\nrequest.\nReqPeakAmpShrMemAmpNum INTEGER --,---,---,--9 AMP number that reported total peak\nshared memory based on the requested\nsize used in the request.\nTDWMEstMemResLimit FLOAT ----,---,---,---,--9.999 Memory estimate (in megabytes) used for\nchecking memory resource limit.\nMaxPSFWDID INTEGER --,---,---,--9 Maximum PSF WDID seen by this request.\nMaxPSFWDIDAmpNum INTEGER --,---,---,--9 Maximum PSF WDID AMP Number of this\nrequest.\nHPTotalPipelines INTEGER --,---,---,--9 The total number of steps in the plan that\nare being processed using the pipeline.\nHPMaxPipelines INTEGER --,---,---,--9 The maximum number of steps in a pipeline\nunit indicates that many AWTs are needed\nto process the query.\nParentQueryID DECIMAL(18,0) -(18)9 Returns the Parent QueryId column\ncontains the parent system generated\nquery id for the given query.\nNosSpCIsReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool Cis returned by a\nNative Object Store Spool request.\nNosSpCIsReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of CIs returned for Native Object\nStore spool requests.\nNosSpDBChunksReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool Datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBChunksReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool datablock chunks\nreturned by a Native Object Store spool\nrequest.\nNosSpDBsReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool Datablocks returned\nby a Native Object Store spool request.\nNosSpDBsReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool datablocks returned\nby a Native Object Store spool request.\nNosSpBlksFSGAcqs BIGINT --,---,---,---,---,---,--9 Number of NOS spool datablocks read from\nFSG.\nNosSpBlksFSGAcqsKB BIGINT --,---,---,---,---,---,--9 Total KB of the Number of NOS spool\ndatablocks read from FSG.\nNosSpTablesRead INTEGER --,---,---,--9 Number of NOS Spool tables accessed.\nThis value must be the same as the number\nof NOS Spool MIs requested.\nLake - Monitor Resources and Performance\nPage 78 of 420View Column Data T ype Format Comment\nNosSpCPUTime FLOAT ----,---,---,---,--9.999 CPU time for reading Native Object Store\nspool blocks (MI, CI, DBChunks). Units of\nseconds.\nNosSpMaxIOWaitTime FLOAT ----,---,---,---,--9.999 Max Native Object Store spool IO wait time\nfor any individual IO. Units of seconds. Both\nread and write.\nNosSpTotalIOWaitTime FLOAT ----,---,---,---,--9.999 Total of the Native Object Store spool IO\nwait time across all steps. Units of seconds.\nBoth read and write.\nNosSpTablesWritten INTEGER --,---,---,--9 Number of NOS spool tables written. This\ncorresponds to the number of TMIs written.\nNosSpCIsWritten BIGINT --,---,---,---,---,---,--9 Number of NOS Spool CIs written.\nNosSpCIsWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS Spool CIs written.\nNosSpDBChunksWritten BIGINT --,---,---,---,---,---,--9 Number of NOS spool DB chunks written.\nNosSpDBChunksWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool DB chunks written.\nNosSpDBsWritten BIGINT --,---,---,---,---,---,--9 Number of NOS DBs written.\nNosSpDBsWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool DBs written.\nOTFQuery CHAR(1) LATIN NOT CASESPECIFIC X(1) Indicates OTF Query execution method.\nThe possible values are ‘J' (Java) or 'N’\n(Native) or NULL.\nExample: dbqlogV - SELECT\nThe following SELECT statement retrieves all rows that match the speciﬁed query ID from the dbqlogV view.\nselect * from td_metric_svc.dbqlogV where queryid =  307190925762023013;\nExamples\nExample: dbqlogV - Tracking Data Volume for Speciﬁc Load Jobs\nExample: dbqlogV - See the Number of Rows Inserted, Updated, or Deleted for DML Statements\ndbqlsqlV\nDatabase: td_metric_svc\nStores the full SQL text of the query. One query string may require more than one row.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the query log was\ngenerated.\nLake - Monitor Resources and Performance\nPage 79 of 420View Column Data T ype Format Comment\nParentReqStartTime TIMESTAMP YYYY-MM-DDBHH:MI:SS.S(6) Returns the time when the parent request\nwas submitted.\nQueryID DECIMAL(18,0) NOT NULL -(18)9 Returns the QueryId column contains the\ngenerated query id for the given query.\nParentQueryID DECIMAL -(18)9 Returns the parent system generated query\nid for this query.\nZoneID BYTE(4) NOT NULL X(8) Returns the zone ID.\nSqlRowNo INTEGER NOT NULL --,---,---,--9 Returns row number in the case of multiple\nrows are used for the SQL.\nSqlTextInfo VARCHAR(31000) UNICODE NOT\nCASESPECIFIC NOT NULLX(31000) A full SQL text segment, a string of up to\napproximately 31,000 characters.\nThe view also contains ExtraFieldX columns that are reserved for future use.\nExample: dbqlsqlV - SELECT\nThe following SELECT statement retrieves the SQL text information of a query.\n                 SELECT QueryID, SqlRowNo, SqlTextInfo from td_metric_svc.dbqlsqlV\n                   WHERE QueryId=201205134619838024;\nResult:\nQueryID            SqlRowNo SqlTextInfo\n------------------ -------- ----------------------------\n201205134619838024 1        CREATE TABLE table1A,\n                             FALLBACK, NO BEFORE JOURNAL, \n                             NO AFTER JOURNAL (i INTEGER, \n                             i2 INTEGER)  \n                             PRIMARY INDEX( i );\nThe SQL text is not edited to remove any blanks; it is stored the same way you entered it.\ndbqlstepV\nDatabase: td_metric_svc\nStores information about each processing step used to satisfy the query. One row is logged for each step, including parallel steps.\nView Column Data T ype Format Description\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Return the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time the query log was\ngenerated.\nParentReqStartTime TIMESTAMP YYYY-MM-DDBHH:MI:SS.S(6) Returns the time when the parent request\nwas submitted.\nQueryID DECIMAL(18,0) NOT NULL -(18)9 Returns the QueryId column contains the\ngenerated query id for the given query.\nLake - Monitor Resources and Performance\nPage 80 of 420View Column Data T ype Format Description\nParentQueryID DECIMAL -(18)9 Returns the parent system generated query\nid for this query.\nStepLev1Num SMALLINT NOT NULL ---,--9 Returns the level 1 step number.\nStepLev2Num SMALLINT NOT NULL ---,--9 Returns the level 2 step number.\nStepName CHAR(6) LATIN NOT CASESPECIFIC NOT\nNULLX(6) Returns an abbreviation of the step name.\nStepStartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the date and time to the nearest\nmicrosecond when the step is sent to the\nAMP.\nStepStopTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns the date and time to the nearest\nmicrosecond when the step returns from the\nAMP.\nEstProcTime FLOAT ----,---,---,---,--9.999 Returns the estimated processing time in\nseconds (with .001 resolution) from the\nOptimizer.\nEstCPUCost FLOAT ----,---,---,---,--9.999 Returns an estimate (from the Optimizer) of\nthe CPU time in milliseconds for the step.\nCPUTime FLOAT ----,---,---,---,--9.999 Returns the total CPU time in seconds (with\n.001 resolution) used on AMPs for the step\nor set of parallel steps. For parallel steps,\nthe ﬁrst step contains the total CPU time.\nIOcount FLOAT ----,---,---,---,--9 Returns the number of IOs from AMPs that\nwere generated by the step or set of\nparallel steps which follow if the second\nstep level is 1.\nEstRowCount FLOAT ----,---,---,---,--9 Returns the estimated row count from the\nOptimizer.\nRowCount FLOAT ----,---,---,---,--9 Returns the number of inserted rows if\nStepName is MRM (Merge Row Multiple) or\nEXE (MultiLoad), or number of rows step\nreturns with all other steps.\nRowCount2 FLOAT ----,---,---,---,--9 Returns the number of updated rows if\nStepName is MRM (Merge Row Multiple) or\nEXE (MultiLoad), or number of loaded rows\nwith all other steps.\nRowCount3 FLOAT ----,---,---,---,--9 Returns the number of deleted rows if\nStepName is EXE (MultiLoad).\nNumOfActiveAMPs INTEGER --,---,---,--9 Returns the number of AMPS that were\nactive for this query.\nMaxAmpCPUTime FLOAT ----,---,---,---,--9.999 Returns the CPU time in seconds (with .001\nresolution) of the AMP with the highest CPU\nutilization in the step.\nMaxCPUAmpNumber INTEGER --,---,---,--9 Returns the number of the AMP with the\nhighest CPU activity.\nMinAmpCPUTime FLOAT ----,---,---,---,--9.999 Returns the CPU time in seconds (with .001\nresolution) of the AMP with the lowest CPU\nutilization in the step.\nMaxAmpIO FLOAT ----,---,---,---,--9 Returns the I/O count of the highest I/O\nutilized AMP in the step.\nMaxIOAmpNumber INTEGER --,---,---,--9 Returns the number of the AMP with the\nhighest IO usage for this step.\nMinAmpIO FLOAT ----,---,---,---,--9 Returns the I/O count of the the I/O count of\nthe highest I/O utilized AMP in the step.\nSpoolUsage BIGINT --,---,---,---,---,---,--9 Returns peak spool usage (bytes) of this\nstep (DataCollectAlg=3). Otherwise,\nnumber of bytes of spool used by the step.\nMaxAMPSpool BIGINT --,---,---,---,---,---,--9 Returns the highest spool usage on an\nAMP.\nLake - Monitor Resources and Performance\nPage 81 of 420View Column Data T ype Format Description\nMaxSpoolAmpNumber INTEGER --,---,---,--9 Returns the number of the AMP with high\nspool usage.\nMinAMPSpool BIGINT --,---,---,---,---,---,--9 Returns the lowest Spool usage on an AMP.\nStepWD INTEGER --,---,---,--9 Returns the identiﬁer of the workload for the\nstep.\nLSN INTEGER --,---,---,--9 Logon Sequence Number used by the load\nutility.\nUtilityTableID BYTE(4) X(8) Returns the table ID for the load utilities.\nRowsWC omprColumns FLOAT ----,---,---,---,--9 Returns the number of rows with\ncompressed columns.\nEstIOCost FLOAT ----,---,---,---,--9.999 Returns an estimate (from the Optimizer) of\nservice time in milliseconds for IO for the\nstep.\nEstNetCost FLOAT ----,---,---,---,--9.999 Returns an estimate (from the Optimizer) of\nthe BYNET service time in milliseconds for\nthe step.\nEstHRCost FLOAT ----,---,---,---,--9.999 Returns an estimate (from the Optimizer) of\nother costs for the step.\nCPUtimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized CPU time in\nseconds (with .001 resolution) used on co-\nexistence systems.\nMaxAmpCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized CPU time in\nseconds (with .001 resolution) of the AMP\nwith maximum CPU utilization in the step.\nMaxCPUAmpNumberNorm INTEGER --,---,---,--9 Returns the number of the AMP with highest\nCPU activity.\nMinAmpCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized CPU Time in\nseconds (with .001 resolution) of the AMP\nwith minimum CPU utilization in the step.\nNumCombinedPartitions BIGINT --,---,---,---,---,---,--9 Returns the number of combined partitions\naccessed (not eliminated).\nNumContexts INTEGER --,---,---,--9 Returns the number of contexts allocated to\nsimultaneously access partitions of a\nsource or target table with column\npartitioning.\nNumCPReferences INTEGER --,---,---,--9 Returns the number of column partitions\nreferenced in a source or target table that\nhas column partitioning.\nEstRowCountSkew FLOAT ----,---,---,---,--9 Returns the number of estimated skew\nrows.\nEstRowCountSkewMatch FLOAT ----,---,---,---,--9 Returns the number of estimated skew\nmatch spools row.\nFragmentNum INTEGER --,---,---,--9 Returns the number of fragments in a IPE\nplan execution of request.\nStepInstance INTEGER --,---,---,--9 Returns the Step instance number for\niterative steps in order of dispatch. If a step\nis dispatched 3 times, 3 steps are logged\nwith the same step number and step\ninstance 1, 2, 3 to distinguish them.\nStepStatus CHAR(10) LATIN NOT CASESPECIFIC X(10) Returns the Step status.\nDispatchSeq INTEGER --,---,---,--9 Returns the Dispatch sequence.\nLockDelay FLOAT ----,---,---,---,--9.999 Returns the maximum wait time to get a\nlock on object in centi-seconds.\nIOKB FLOAT ----,---,---,---,--9.999 Returns the Logical AMP I/Os in KB\ngenerated by the step, or set of parallel\nsteps if the second step level is 1.\nStatementNum INTEGER --,---,---,--9 Returns the statement number with which\nthe step is associated.\nLake - Monitor Resources and Performance\nPage 82 of 420View Column Data T ype Format Description\nTriggerNestLevel SMALLINT -(5)9 Returns the composite of TriggerNestLevel\ndetails.\nTriggerKind VARCHAR(128) LATIN NOT CASESPECIFICX(128) Returns the composite of TriggerKind\ndetails.\nSSReceiverCount INTEGER --,---,---,--9 Returns the total number of AMP receiver\nthat gets redistributed rows through Single\nSender Receiver (SSR) feature. If a step\ndoes not use SSR, the SSRReceiverCount is\n0.\nVHLogicalIO FLOAT ----,---,---,---,--9.999 Returns the number of Very Hot Logical\nAMP I/Os generated by the step, or set of\nparallel steps if the second step level is 1.\nVHPhysIO FLOAT ----,---,---,---,--9.999 Returns the number of Very Hot Physical\nAMP I/Os generated by the step, or set of\nparallel steps if the second step level is 1.\nVHLogicalIOKB FLOAT ----,---,---,---,--9.999 Returns the Very Hot Logical AMP I/Os in\nKB generated by the step, or set of parallel\nsteps if the second step level is 1.\nVHPhysIOKB FLOAT ----,---,---,---,--9.999 Returns the Very Hot Physical AMP I/Os in\nKB generated by the step, or set of parallel\nsteps if the second step level is 1.\nPhysIO FLOAT ----,---,---,---,--9.999 Returns the number of Physical AMP I/Os\ngenerated by the step, or set of parallel\nsteps if the second step level is 1.\nPhysIOKB FLOAT ----,---,---,---,--9.999 Returns the Physical AMP I/Os in KB\ngenerated by the step, or set of parallel\nsteps if the second step level is 1.\nServerByteCount BIGINT --,---,---,---,---,---,--9 Total bytes sent and got from the foreign\nserver by the step.\nStream_Metrics VARBYTE(256) X(512) Reserved for future use.\nOneMBRowCount FLOAT ----,---,---,---,--9 The number of 1MB rows (1MB > size >\n64KB) in the set of rows returned by the\nstep.\nPersistentSpool BIGINT --,---,---,---,---,---,--9 Persistent part of SpoolUsage.\nMaxOneMBRowSize INTEGER --,---,---,--9 The actual size in bytes of the largest 1MB\nrow in the set of rows returned for the query.\nMaxNumMapAMPs INTEGER --,---,---,--9 The number of AMPs in the largest map\nused by the request.\nMinNumMapAMPs INTEGER --,---,---,--9 Number of AMPs in the smallest contiguous\nmap used by this request.\nSysDefNumMapAMPs INTEGER --,---,---,--9 Number of AMPs in the system-default\nmap.\nSourceMapNo INTEGER --,---,---,--9 The map number for the source table in the\nstep.\nDestMapNo INTEGER --,---,---,--9 The map number for the output table in the\nstep.\nStepObjectInfo VARBYTE(1024) X(2048) Contains binary encoded information about\ntables, spools, and join indexes accessed\nby the step.\nUsedIota FLOAT ----,---,---,---,--9.999 Return IO Tokens used by the step.\nPermUsage BIGINT --,---,---,---,---,---,--9 Returns the permanent space in bytes\nadded or deleted by the step.\nMaxAMPPerm BIGINT --,---,---,---,---,---,--9 Returns the maximum permanent space in\nbytes added or deleted by an AMP in the\nstep.\nMaxPermAmpNumber FLOAT ----,---,---,---,--9.999 Returns the AMP number that added or\ndeleted the maximum permanent space in\nthe step.\nLake - Monitor Resources and Performance\nPage 83 of 420View Column Data T ype Format Description\nSpaceDelay FLOAT ----,---,---,---,--9.999 Returns the maximum wait time in centi-\nseconds to get space from the global\nspace accounting system.\nMaxSpaceDelayAmpNumber INTEGER --,---,---,--9 Returns the AMP number that waited the\nmaximum to get space.\nUAFName CHAR(10) LATIN NOT CASESPECIFIC X(10) Name of an Analytic Function being run by\nEXECUTE FUNCTION in this step. The\ndefault is NULL.\nInMemBulkQualStatus BYTEINT| -(3)9 Represents whether bulk qualiﬁcation is\ndone in this step or not.\nNosRecordsReturned BIGINT --,---,---,---,---,---,--9 Number of records returned by a Native\nObject Store step.\nNosRecordsSkipped BIGINT --,---,---,---,---,---,--9 Number of records skipped by a Native\nObject Store step.\nNosPhysReadIO BIGINT --,---,---,---,---,---,--9 Total physical IOs for Native Object Store\nﬁles for this step.\nNosPhysReadIOKB FLOAT ----,---,---,---,--9.999 Total KB of physical IOs for Native Object\nStore ﬁles in this step.\nNosRecordsReturnedKB FLOAT ----,---,---,---,--9.999 Total KB of records returned for Native\nObject Store ﬁles in this step.\nNosTotalIOWaitTime FLOAT ----,---,---,---,--9.999 Total of the Native Object Store IO wait time\nin seconds in this step.\nNosCPUTime FLOAT ----,---,---,---,--9.999 CPU time in seconds for reading Native\nObject Store ﬁles in this step. This time is\nalready included in other non-NOS CPU\nﬁelds.\nNosMaxIOWaitTime FLOAT ----,---,---,---,--9.999 Maximum Native Object Store IO wait time\nfor any individual IO in seconds.\nNosFiles INTEGER --,---,---,--9 Number of ﬁle reads attempted by Native\nObject Store in this step.\nNosFilesSkipped INTEGER --,---,---,--9 Number of Native Object Store ﬁles that\nwere skipped in this step.\nAWTTime FLOAT ----,---,---,---,--9.999 AWT elapsed time in seconds for the step.\nMaxAWTTime FLOAT ----,---,---,---,--9.999 Max AWT elapsed time in seconds for the\nstep.\nMaxAWTTimeAmpNum INTEGER --,---,---,--9 AMP number that had max AWTTime for the\nstep.\nMinAWTTime FLOAT ----,---,---,---,--9.999 Minimum AWT elapsed time in seconds for\nthe step.\nUDFMemUsage FLOAT ----,---,---,---,--9.999 Memory used by UDF for this step.\nMaxUDFMemUsage FLOAT ----,---,---,---,--9.999 Maximum memory used by UDF for this\nstep.\nMaxUDFMemUsageAmpNum INTEGER --,---,---,--9 AMP number that had max memory used\nby UDF for this step.\nUDFVMPeak FLOAT ----,---,---,---,--9.999 UDF Virtual memory peak for the step.\nUDFVMData FLOAT ----,---,---,---,--9.999 UDF Virtual memory data size for the step.\nLocSpoolUsage BIGINT --,---,---,---,---,---,--9 Total local spool usage for this step in\nbytes.\nPhysLocIO FLOAT ----,---,---,---,--9.999 Total local physical IO count for this step.\nPhysLocIOKB FLOAT ----,---,---,---,--9.999 Total local physical IO for this step in\nkilobytes.\nNosPhysWriteIO BIGINT --,---,---,---,---,---,--9 Total physical IOs for Native Object Store\nﬁles for this step.\nNosPhysWriteIOKB BIGINT --,---,---,---,---,---,--9 Total KB of physical IOs for Native Object\nStore ﬁles for this step.\nLake - Monitor Resources and Performance\nPage 84 of 420View Column Data T ype Format Description\nNosCacheReadIO BIGINT --,---,---,---,---,---,--9 Total Cache Read IOs for Native Object\nStore ﬁles for this step.\nNosCacheReadIOKB BIGINT --,---,---,---,---,---,--9 Total KB of Cache read IOs for Native\nObject Store ﬁles for this step.\nNosPhysDataReadIO BIGINT --,---,---,---,---,---,--9 Total physical data read IOs for Native\nObject Store ﬁles for this step.\nNosPhysDataReadIOKB BIGINT --,---,---,---,---,---,--9 Total KB of physical Data read IOs for\nNative Object Store ﬁles for this step.\nNosPrefetchReadIO BIGINT --,---,---,---,---,---,--9 Total Read Ahead IOs for Native Object\nStore ﬁles for this step.\nNosPrefetchReadIOKB BIGINT --,---,---,---,---,---,--9 Total KB of Read Ahead IOs for Native\nObject Store ﬁles for this step.\nNosFilesWritten BIGINT --,---,---,---,---,---,--9 Number of ﬁle writes attempted by Native\nObject Store in this step.\nNosFilesDeleted BIGINT --,---,---,---,---,---,--9 Total number of ﬁles deleted for Native\nObject Store ﬁles for this step.\nNosNumDeleteSuccess INTEGER --,---,---,--9 Number of ﬁles successfully deleted by\nNative Object Store for this step.\nNosNumDeleteFailure INTEGER --,---,---,--9 Number of ﬁles failed to be deleted by\nNative Object Store for this step.\nNosDeleteIO BIGINT --,---,---,---,---,---,--9 Total IOs to delete for Native Object Store\nﬁles for this step.\nNosDeleteIOKB BIGINT --,---,---,---,---,---,--9 Total KB to delete IOs for Native Object\nStore ﬁles for this step.\nMaxPSFWDID INTEGER --,---,---,--9 Maximum PSF WDID seen by this step.\nMaxPSFWDIDAmpNum INTEGER --,---,---,--9 AMP Number of Max PSF WDID for this\nstep.\nPeakAmpStpPrvMem FLOAT ----,---,---,---,--9.999 Peak private memory in MB based on\nrequested size used by this step.\nPeakAmpStpPrvMemAmpNum INTEGER --,---,---,--9 AMP Number of peak private memory\nbased on requested size used by this step.\nPeakAmpStpShrMem FLOAT ----,---,---,---,--9.999 Peak shared memory in MB based on\nrequested size used by this step.\nPeakAmpStpShrMemAmpNum INTEGER --,---,---,--9 AMP number of peak shared memory\nbased on requested size used by this step.\nHPPCSRatio FLOAT ----,---,---,---,--9.999 The producer-consumer speed ratio for this\nstep.\nHPNumBuffers INTEGER --,---,---,--9 The number of buffers used by the step as\na producer to write the rows.\nNosSpCIsReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool CIs returned by a\nNative Object Store spool for this step.\nNosSpCIsReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS Spool CIs returned by a\nNative Object Store spool for this step.\nNosSpDBChunksReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool Datablock chunks\nreturned by a Native Object Store spool for\nthis step.\nNosSpDBChunksReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool datablock chunks\nreturned by a Native Object Store spool for\nthis step.\nNosSpDBsReturned BIGINT --,---,---,---,---,---,--9 Number of NOS Spool Datablocks returned\nby a Native Object Store spool for this step.\nNosSpDBsReturnedKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool datablocks returned\nby a Native Object Store spool for this step.\nNosSpBlksFSGAcqs BIGINT --,---,---,---,---,---,--9 Number of NOS spool data blocks read\nfrom FSG for this step.\nLake - Monitor Resources and Performance\nPage 85 of 420View Column Data T ype Format Description\nNosSpBlksFSGAcqsKB BIGINT --,---,---,---,---,---,--9 Total KB of the Number of NOS spool\ndatablocks read from FSG for this step.\nNosSpCPUTime FLOAT ----,---,---,---,--9.999 CPU time for reading Native Object Store\nspool blocks (MI, CI, DBChunks). Units of\nseconds for this step.\nNosSpMaxIOWaitTime FLOAT ----,---,---,---,--9.999 Max Native Object Store spool IO wait time\nfor any individual IO for this step. Units of\nseconds. Both read and write.\nNosSpTotalIOWaitTime FLOAT ----,---,---,---,--9.999 Total of the Native Object Store spool IO\nwait time for this step. Units of seconds.\nBoth read and write.\nNosSpTablesWritten INTEGER --,---,---,--9 Number of NOS spool tables written. This\ncorresponds to the number of TMIs written\nfor this step.\nNosSpCIsWritten BIGINT --,---,---,---,---,---,--9 Number of NOS Spool CIs written for this\nstep.\nNosSpCIsWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS Spool CIs written for this\nstep.\nNosSpDBChunksWritten BIGINT --,---,---,---,---,---,--9 Number of NOS spool DB chunks written for\nthis step.\nNosSpDBChunksWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool DB chunks written\nfor this step.\nNosSpDBsWritten BIGINT --,---,---,---,---,---,--9 Number of NOS DBs written for this step.\nNosSpDBsWrittenKB BIGINT --,---,---,---,---,---,--9 Total KB of NOS spool DBs written for this\nstep.\nSpoolProd BIGINT --,---,---,---,---,---,--9 Spool produced by this step in bytes.\nSpoolCons BIGINT --,---,---,---,---,---,--9 Spool consumed by this step in bytes.\nThe view also contains ExtraFieldX columns that are reserved for future use.\nExample\nExample: dbqlstepV - Detect the Longest Running Query in a Time Frame\ndbqlsum maryV\nDatabase: td_metric_svc\nStores information about queries that meet the criteria for a rule specifying the LIMIT SUMMARY or LIMIT THRESHOLD option.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nLake - Monitor Resources and Performance\nPage 86 of 420View Column Data T ype Format Comment\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) (Prime Key) Time and date when the DBQL\nsummary cache was written.\nUserID BYTE(4) X(8) Returns the ID of the user.\nZoneID BYTE(4) NOT NULL X(8) Returns the zone ID.\nAcctString VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the user unexpanded logon\naccount string.\nLogicalHostID SMALLINT -(5)9 Returns a unique identiﬁer of the logon\nsource for the logged query. A value of zero\nindicates an internal session.\nAppID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Returns the application ID.\nClientID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Returns the client ID.\nClientAddr CHAR(45) LATIN NOT CASESPECIFIC X(45) Returns the IP address of the client who\nsubmitted the query.\nProﬁleID BYTE(4) X(8) Returns the unique number assigned to the\ncost proﬁle instance in the system.\nSessionID INTEGER NOT NULL --,---,---,--9 Returns the session identiﬁer.\nQueryCount INTEGER NOT NULL --,---,---,--9 Returns the number of queries run in a 10-\nminute interval. Used with the \"SUMMARY\"\nor \"THRESHOLD\" SQL option only.\nValueType CHAR(1) LATIN NOT CASESPECIFIC X(1) Returns the type that was used to\ndetermine the threshold from the following\nvalues. C = CPU seconds, I = IO count, S =\nElapsed time in seconds.\nQuerySeconds FLOAT NOT NULL ----,---,---,---,--9.999 Returns the total number of seconds used\nby QueryCount. QuerySeconds can be\nused to get an average.\nTotalIOCount FLOAT ----,---,---,---,--9 Returns the number of IOs from AMPs that\nwere generated by the query in summary\nmode.\nAMPPCUTime FLOAT ----,---,---,---,--9.999 Returns the total AMP CPU time in seconds\nused for query in summary mode.\nParserCPUTime FLOAT ----,---,---,---,--9.999 Returns the total parser and dispatcher\nCPU time in seconds (with .001 resolution)\nused for the query in summary mode.\nAMPCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized AMP CPU time in\nseconds for co-existence systems in\nsummary mode.\nParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Returns the normalized parser CPU time in\nseconds (with .001 resolution) for co-\nexistence systems in summary mode.\nLowHist FLOAT NOT NULL ----,---,---,---,--9.999 For SUMMARY option, lowest value\nspeciﬁed as query execution differentiation.\nFor THRESHOLD option, threshold\nspeciﬁed by the user.\nHighHist FLOAT NOT NULL ----,---,---,---,--9.999 Returns the highest value speciﬁed as a\nquery execution time differentiation. Used\nwith the \"SUMMARY\" SQL option only. If\nTHRESHOLD is used, HighHist is 0.\nUsedIota FLOAT ----,---,---,---,--9.999 Return IO Tokens used by the requests that\nare logged in summary mode.\nReqPhysIO FLOAT ----,---,---,---,--9.999 Returns the total number of Physical I/Os for\nthe whole request in summary mode.\nResPhysIOKB FLOAT ----,---,---,---,--9.999 Returns the total Physical I/Os in kilobytes\nfor the whole request in summary mode.\nStartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Records the timestamp of the ﬁrst query\nincluded for this summary row.\nStopTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Records the timestamp of the last query\nincluded for this summary row.\nLake - Monitor Resources and Performance\nPage 87 of 420View Column Data T ype Format Comment\nUserName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the userid, if any,\nunder which the user submitted the query.\nProﬁleName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the proﬁle, if any,\nunder which the user submitted the query.\nTotalIOKB FLOAT ----,---,---,---,--9.999 Total I/Os in kilobytes used by the requests\nin summary mode during the collection\nperiod.\nExample: dbqlsummaryV - SELECT\nThe following SELECT statement retrieves the summary information of a session:\nselect * from td_metric_svc.dbqlsummaryV sample 1;\nResult:\n              ProcID   30718\n    CollectTimeStamp  2016-11-04 12:45:35.460000\n              UserID  00000100\n          AcctString  DBC\n       LogicalHostID       1\n               AppID  DBCCONS\n            ClientID  PTEUSER\n          ClientAddr  10.25.176.76\n           ProfileID  ?\n           SessionID           1,386\n          QueryCount               1\n           ValueType  I\n        QuerySeconds                     0.000\n        TotalIOCount                     0\n          AMPCPUTime         .000\n       ParserCPUTime         .004\n      AMPCPUTimeNorm         .000\n   ParserCPUTimeNorm         .253\n             LowHist                     0.000\n            HighHist                    10.000\n            UsedIota                     0.000\n           ReqPhysIO                     0.000\n         ReqPhysIOKB                     0.000\n           StartTime  2016-11-04 12:38:20.390000\n            StopTime  2016-11-04 12:38:20.390000\n            UserName  DBC\ndbqlutilityV\nDatabase: td_metric_svc\nEach row stores information about one completed load and export or Data Stream Architecture job.\nView Column Data T ype Format Comment\nLocation VARCHAR(2048) UNICODE CASESPECIFICX(2048) Path to metric data objects.\npath_component_id VARCHAR(8000) UNICODE CASESPECIFICX(8000) Operational group (primary cluster or\ncompute cluster) ID.\npath_collecttimestamp VARCHAR(8000) UNICODE CASESPECIFICX(8000) Timestamp of when collected the given\nmetrics.\npath_year VARCHAR(8000) UNICODE CASESPECIFICX(8000) The year in which the data was recorded in\nthe table.\npath_month VARCHAR(8000) UNICODE CASESPECIFICX(8000) The month in which the data was recorded\nin the table.\npath_day VARCHAR(8000) UNICODE CASESPECIFICX(8000) The date on which the data was recorded in\nthe table.\npath_hour VARCHAR(8000) UNICODE CASESPECIFICX(8000) The hour at which the data was recorded in\nthe table.\npath_minute VARCHAR(8000) UNICODE CASESPECIFICX(8000) The minute at which the data was recorded\nin the table.\nLake - Monitor Resources and Performance\nPage 88 of 420View Column Data T ype Format Comment\npath_ver VARCHAR(8000) UNICODE CASESPECIFICX(8000) The version of Vantage software that was\nrunning on the operational group.\nProcID DECIMAL(5,0) NOT NULL -(5)9 Returns the process ID of the dispatcher.\nCollectTimeStamp TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Returns the time that the log entry was\ngenerated.\nUtilityName VARCHAR(30) UNICODE NOT\nCASESPECIFICX(30) Returns the name of the utility.\nFastExportNoSpool CHAR(1) LATIN NOT CASESPECIFIC X(1) For utilities implementing FastExport\nprotocol, 'Y' indicates No Spool mode 'N'\nindicates Spool mode.\nExtendedMLoad CHAR(1) LATIN NOT CASESPECIFIC X(1) 'Y' indicates MLOADX being used 'N'\nindicates MLOADX not being used.\nDSAOperation CHAR(1) LATIN NOT CASESPECIFIC X(1) 'D' indicates DUMP operation 'R' indicates\nRESTORE operation.\nUtilityRequest VARCHAR(2048) UNICODE NOT\nCASESPECIFICX(2048) The main utility SQL request for the job. It\ncontains the target database and table\nnames. The possible statements are:\nBEGIN LOADING (FastLoad), BEGIN\nMLOAD (MLOAD/MLOADX), SELECT\n(FastExport), DUMP/RESTORE (DSA).\nJobName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) DSA job name. Not used for other utilities at\nthis time.\nJobInstance INTEGER --,---,---,--9 DSA job execution ID. Not used for other\nutilities at this time.\nLSN INTEGER --,---,---,--9 Logon Sequence Number used by the utility\njob.\nUserName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Name of the user who ran the utility job.\nSessionID INTEGER NOT NULL --,---,---,--9 Session ID of the control SQL session.\nLogicalHostID SMALLINT NOT NULL -(5)9 Logical Host ID of the control SQL session.\nLogonDateTime TIMESTAMP(6) NOT NULL YYYY-MM-DDBHH:MI:SS.S(6) Date (YYYY-MM-DD) and Time (HH:MM:SS)\nof the control SQL session logon.\nWDID INTEGER --,---,---,--9 Workload deﬁnition assigned to the main\nutility work.\nFinalWDID INTEGER --,---,---,--9 Workload deﬁnition under which the main\nutility work completed.\nSessionWDID INTEGER --,---,---,--9 Workload deﬁnition used for query parsing.\nTDWMRuleID INTEGER --,---,---,--9 RuleId of the TDWM rule that caused a\ndelay.\nCPUDecayLevel SMALLINT ---,--9 Contains most severe decay level reached\nfor CPU usage.\nIODecayLevel SMALLINT ---,--9 Contains most severe decay level reached\nfor I/O usage.\nUserID BYTE(4) NOT NULL X(8) Identiﬁer of the user who submitted the\nutility job.\nZoneID BYTE(4) NOT NULL X(8) Zone ID of the user who submitted the utility\njob.\nAcctString VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Unexpanded Account String of the user\nwho submitted the utility job.\nExpandAcctString VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) If account expansion was invoked, account\nstring in expanded format.\nAcctStringTime FLOAT 99:99:99 Time (HH:MM:SS) if account string contains\n$T.\nAcctStringHour SMALLINT -(5)9 Hour (HH) if account string contains $H.\nAcctStringDate DATE YY/MM/DD Date (YY/MM/DD) if account string contains\n$D.\nLake - Monitor Resources and Performance\nPage 89 of 420View Column Data T ype Format Comment\nLogonSource CHAR(128) LATIN NOT CASESPECIFIC X(128) Identiﬁcation of the place from where the\nuser accessed the system.\nAppID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Application ID of the utility job.\nClientID CHAR(30) UNICODE NOT CASESPECIFIC X(30) Client ID of the utility job.\nClientAddr CHAR(45) LATIN NOT CASESPECIFIC X(45) Client address of the utility job.\nQueryBand VARCHAR(12304) UNICODE NOT\nCASESPECIFICX(12304) Query band used in the utility job.\nProﬁleID BYTE(4) X(8) Proﬁle ID used for the utility job.\nProxyUser VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Proxy user used for the utility job.\nProxyRole VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Proxy role used for the utility job.\nOpEnvID INTEGER --,---,---,--9 Operational Environment ID in which the\nutility job was executed.\nSysConID INTEGER --,---,---,--9 System Condition ID in which the utility job\nwas executed.\nNoClassiﬁcation CHAR(1) LATIN NOT CASESPECIFIC X(1) Reserved for future use.\nWDOverride CHAR(1) LATIN NOT CASESPECIFIC X(1) Reserved for future use.\nResponseTimeMet CHAR(1) LATIN NOT CASESPECIFIC X(1) Reserved for future use.\nDelayTime FLOAT ----,---,---,---,--9.999 Number of seconds the utility job was\ndelayed by TDWM.\nWDDelayTime INTEGER --,---,---,--9 Reserved for future use.\nJobStartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Job start time.\nJobEndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Job end time.\nRowsInserted FLOAT ----,---,---,---,--9 Number of rows inserted by the utility job.\nRowsUpdated FLOAT ----,---,---,---,--9 Number of rows updated by the utility job.\nRowsDeleted FLOAT ----,---,---,---,--9 Number of rows deleted by the utility job.\nRowsExported FLOAT ----,---,---,---,--9 Number of rows exported by the utility job.\nNumSesOrBuildProc SMALLINT -(5)9 Number of sessions used. For DSA, number\nof build processes used.\nMaxDataWaitTime FLOAT ----,---,---,---,--9 The highest wait time in seconds from\nexternal source for input data or output\nrequests.\nMaxDataWaitTimeID INTEGER --,---,---,--9 ID associated with the highest wait time.\nPhase0StartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 0 start date and time of the\nutility job.\nPhase0EndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 0 end date and time of the\nutility job.\nPhase0TotalCPUTime FLOAT ----,---,---,---,--9.999 Phase 0 total CPU Time in seconds.\nPhase0TotalCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 0 total normalized CPU Time in\nseconds.\nPhase0ParserCPUTime FLOAT ----,---,---,---,--9.999 Phase 0 Parser and Dispatcher CPU time in\nseconds.\nPhase0ParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 0 normalized Parser and Dispatcher\nCPU time in seconds.\nPhase0TotalIO FLOAT ----,---,---,---,--9 Phase 0 logical I/O count.\nPhase0IOKB FLOAT ----,---,---,---,--9.999 Phase 0 logical I/O in KB.\nPhase0PhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os in\nphase 0 of the utility job.\nPhase0PhsyIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in kilobytes\nin phase 0 of the utility job.\nPhase0UsedIota FLOAT ----,---,---,---,--9.999 Returns used IOTAs in phase 0 of the utility\njob.\nLake - Monitor Resources and Performance\nPage 90 of 420View Column Data T ype Format Comment\nPhase1StartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 1 start date and time of the\nutility job.\nPhase1EndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 1 end date and time of the\nutility job.\nPhase1TotalCPUTime FLOAT ----,---,---,---,--9.999 Phase 1 total CPU Time in seconds.\nPhase1TotalCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 1 total normalized CPU Time in\nseconds.\nPhase1MaxCPUTime FLOAT ----,---,---,---,--9.999 Phase 1 highest AMP CPU time in seconds.\nPhase1MaxCPUAmpNumber INTEGER --,---,---,--9 Phase 1 - ID of AMP with highest CPU time.\nPhase1MaxCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 1 highest normalized AMP CPU time\nin seconds.\nPhase1MaxCPUAmpNumberNorm INTEGER --,---,---,--9 Phase 1 - ID of AMP with highest\nnormalized CPU time.\nPhase1ParserCPUTime FLOAT ----,---,---,---,--9.999 Phase 1 Parser and Dispatcher CPU time in\nseconds.\nPhase1ParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 1 normalized Parser and Dispatcher\nCPU time in seconds.\nPhase1RSGCPUTime FLOAT ----,---,---,---,--9.999 Phase 1 RSG CPU time in seconds.\nPhase1RSGCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 1 normalized RSG CPU time in\nseconds.\nPhase1TotalIO FLOAT ----,---,---,---,--9 Phase 1 logical I/O count.\nPhase1MaxIO FLOAT ----,---,---,---,--9 Phase 1 highest logical I/O count.\nPhase1MaxIOAmpNumber INTEGER --,---,---,--9 Phase 1 - ID of AMP with highest logical I/O\ncount.\nPhase1IOKB FLOAT ----,---,---,---,--9.999 Phase 1 logical I/O in KB.\nPhase1PhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os in\nphase 1 of the utility job.\nPhase1PhsyIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in kilobytes\nin phase 1 of the utility job.\nPhase1MaxAWTUsage BYTEINT -(3)9 Phase 1 highest AWT usage.\nPhase1MaxAMPMemoryUsage FLOAT ----,---,---,---,--9 Phase 1 highest AMP memory usage in\nMBs.\nPhase1MaxRSGMemoryUsage FLOAT ----,---,---,---,--9 Phase 1 highest RSG memory usage in\nMBs.\nPhase1RowCount FLOAT ----,---,---,---,--9 Phase 1 row count.\nPhase1BlockCount FLOAT ----,---,---,---,--9 Phase 1 block count.\nPhase1ByteCount FLOAT ----,---,---,---,--9 Phase 1 byte count.\nPhase1UsedIota FLOAT ----,---,---,---,--9.999 Returns used IOTAs in phase 1 of the utility\njob.\nPhase2StartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 2 start date and time of the\nutility job.\nPhase2EndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 2 end date and time of the\nutility job.\nPhase2TotalCPUTime FLOAT ----,---,---,---,--9.999 Phase 2 total CPU Time in seconds.\nPhase2TotalCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 2 total normalized CPU Time in\nseconds.\nPhase2MaxCPUTime FLOAT ----,---,---,---,--9.999 Phase 2 highest AMP CPU time in seconds.\nPhase2MaxCPUAmpNumber INTEGER ---,--9 Phase 2 - ID of AMP with highest CPU time.\nPhase2MaxCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 2 highest normalized AMP CPU time\nin seconds.\nPhase2MaxCPUAmpNumberNorm FLOAT ----,---,---,---,--9.999 Phase 2 - ID of AMP with highest\nnormalized CPU time.\nLake - Monitor Resources and Performance\nPage 91 of 420View Column Data T ype Format Comment\nPhase2ParserCPUTime FLOAT ----,---,---,---,--9.999 Phase 2 Parser and Dispatcher CPU time in\nseconds.\nPhase2ParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 2 normalized Parser and Dispatcher\nCPU time in seconds.\nPhase2RSGCPUTime FLOAT ----,---,---,---,--9.999 Phase 2 RSG CPU time in seconds.\nPhase2RSGCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 2 normalized RSG CPU time in\nseconds.\nPhase2TotalIO FLOAT ----,---,---,---,--9 Phase 2 logical I/O count.\nPhase2MaxIO FLOAT ----,---,---,---,--9 Phase 2 highest logical I/O count.\nPhase2MaxIOAmpNumber INTEGER --,---,---,--9 Phase 2 - ID of AMP with highest logical I/O\ncount.\nPhase2IOKB FLOAT ----,---,---,---,--9.999 Phase 2 logical I/O in KB.\nPhase2PhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os in\nphase 2 of the utility job.\nPhase2PhsyIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in kilobytes\nin phase 2 of the utility job.\nPhase2MaxAWTUsage BYTEINT -(3)9 Phase 2 highest AWT usage.\nPhase2MaxAMPMemoryUsage FLOAT ----,---,---,---,--9 Phase 2 highest AMP memory usage in\nMBs.\nPhase2MaxRSGMemoryUsage FLOAT ----,---,---,---,--9 Phase 2 highest RSG memory usage in\nMBs.\nPhase2RowCount FLOAT ----,---,---,---,--9 Phase 2 row count.\nPhase2BlockCount FLOAT ----,---,---,---,--9 Phase 2 block count.\nPhase2ByteCount FLOAT ----,---,---,---,--9 Phase 2 byte count.\nPhase2UsedIota FLOAT ----,---,---,---,--9.999 Returns used IOTAs in phase 2 of the utility\njob.\nPhase3StartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 3 start date and time of the\nutility job.\nPhase3EndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 3 end date and time of the\nutility job.\nPhase3TotalCPUTime FLOAT ----,---,---,---,--9.999 Phase 3 total CPU Time in seconds.\nPhase3TotalCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 3 total normalized CPU Time in\nseconds.\nPhase3ParserCPUTime FLOAT ----,---,---,---,--9.999 Phase 3 Parser and Dispatcher CPU time in\nseconds.\nPhase3ParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 3 normalized Parser and Dispatcher\nCPU time in seconds.\nPhase3RSGCPUTime FLOAT ----,---,---,---,--9.999 Phase 3 RSG CPU time in seconds.\nPhase3RSGCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 3 normalized RSG CPU time in\nseconds.\nPhase3TotalIO FLOAT ----,---,---,---,--9 Phase 3 logical I/O count.\nPhase3IOKB FLOAT ----,---,---,---,--9.999 Phase 3 logical I/O in KB.\nPhase3PhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os in\nphase 3 of the utility job.\nPhase3PhsyIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in kilobytes\nin phase 3 of the utility job.\nPhase3MaxAWTUsage BYTEINT -(3)9 Phase 3 highest AWT usage.\nPhase3MaxAMPMemoryUsage FLOAT ----,---,---,---,--9 Phase 3 highest AMP memory usage in\nMBs.\nPhase3MaxRSGMemoryUsage FLOAT ----,---,---,---,--9 Phase 3 highest RSG memory usage in\nMBs.\nPhase3UsedIota FLOAT ----,---,---,---,--9.999 Returns used IOTAs in phase 3 of the utility\njob.\nLake - Monitor Resources and Performance\nPage 92 of 420View Column Data T ype Format Comment\nPhase4StartTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 4 start date and time of the\nutility job.\nPhase4EndTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) Returns phase 4 end date and time of the\nutility job.\nPhase4TotalCPUTime FLOAT ----,---,---,---,--9.999 Phase 4 total CPU Time in seconds.\nPhase4CPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 4 total normalized CPU Time in\nseconds.\nPhase4ParserCPUTime FLOAT ----,---,---,---,--9.999 Phase 4 Parser and Dispatcher CPU time in\nseconds.\nPhase4ParserCPUTimeNorm FLOAT ----,---,---,---,--9.999 Phase 4 normalized Parser and Dispatcher\nCPU time in seconds.\nPhase4TotalIO FLOAT ----,---,---,---,--9 Phase 4 logical I/O count.\nPhase4IOKB FLOAT ----,---,---,---,--9.999 Phase 4 logical I/O in KB.\nPhase4PhysIO FLOAT ----,---,---,---,--9.999 Returns the number of physical I/Os in\nphase 4 of the utility job.\nPhase4PhysIOKB FLOAT ----,---,---,---,--9.999 Returns total physical I/O usage in kilobytes\nin phase 4 of the utility job.\nPhase4UsedIota FLOAT ----,---,---,---,--9.999 Returns used IOTAs in phase 4 of the utility\njob.\nStream_Metrics VARBYTE(256) X(512) Reserved for future use.\nReservedField1 VARBYTE(10000) X(20000) Reserved for future use.\nReservedField2 VARBYTE(10000) X(20000) Reserved for future use.\nProﬁleName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the proﬁle, if any,\nunder which the user submitted the utility\njob.\nWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the workload deﬁnition (WD) name\nassigned to the utility job.\nFinalWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the workload deﬁnition name in\nwhich the utility job completed execution.\nSessionWDName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns workload deﬁnition name\nassociated with the session.\nOpEnvName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the operating\nenvironment activated by the Teradata\ndynamic workload management software.\nSysConName VARCHAR(128) UNICODE NOT\nCASESPECIFICX(128) Returns the name of the system condition\nactivated by the Teradata dynamic\nworkload management software.\nDeferTime FLOAT ----,---,---,---,--9.999 The number of seconds a query was\ndeferred by workload management due to\nan ARM. This is the number of seconds\nfrom the time the dispatcher gets the query\n(after parsing) until it is moved to the Delay\nQueue, or rejected, or allowed to run.\nDeferRuleID INTEGER --,---,---,--9 TDWM Rule ID of one of the ARM rules\nwhich caused this request to be deferred.\nTDWMAdmissionTime TIMESTAMP(6) YYYY-MM-DDBHH:MI:SS.S(6) The time when a request is admitted into\nthe system by workload management (i.e.,\nafter ARM processing).\nExample\nExample: dbqlutilityV - Retrieve Start Time, End Time, and Row Counts\nQuery Monitoring Examples\nExample: dbqlogV - Tracking Data Volume for Speciﬁc Load Jobs\nExample: dbqlogV - See the Number of Rows Inserted, Updated, or Deleted for DML Statements\nExample: dbqlstepV - Detect the Longest Running Query in a Time Frame\nExample: dbqlutilityV - Retrieve Start Time, End Time, and Row Counts\nLake - Monitor Resources and Performance\nPage 93 of 420Example: dbqlogV - Tracking Data Volume for Specific Load Jobs\nThis example shows how to track data volume for speciﬁc load jobs.\nSELECT UtilityByteCount,UtilityRowCount from td_metric_svc.dbqlogV where UtilityByteCount is not NULL or UtilityRowCount is not NULL;\nResult:\n UtilityByteCount  UtilityRowCount\n-----------------  ---------------\n              431               25\n               52                1\nExample: dbqlogV - See the Number of Rows Inserted, Updated, or Deleted for DML Statements\nThis example shows how to use the StmtDMLRowCount column to see the number of rows inserted, updated, or deleted for DML statements.\nCREATE TABLE T3\n  (a Integer, b VARCHAR(3), c VARCHAR(3)\n);\nRun a multiple-statement request, such as:\nINSERT INTO T3(1, 'abc', 'def')\n; INSERT INTO T3(1, 'ghi', 'jkl')\n; MERGE INTO T3 AS t USING \n(SELECT 1 AS a,'stf' AS b,'xyz' AS c)  AS s on t.a = s.a\nWHEN MATCHED THEN UPDATE SET c = s.c\nWHEN NOT MATCHED THEN INSERT VALUES (s.a,s.b,s.c)\n; MERGE INTO T3 AS t USING \n(SELECT 1 AS a,'stf' AS b,'xyz' AS c)  AS s on t.a = s.a\nWHEN MATCHED THEN UPDATE SET c = s.c\nWHEN NOT MATCHED THEN INSERT VALUES (s.a,s.b,s.c)\n; DELETE FROM T3;\nThe multiple-statement request inserted 2 rows to table T3, updated 4 rows in table T3, and deleted 2 rows from table T3:\nSELECT StmtDMLRowCount FROM td_metric_svc.dbqlogV;\nResult:\nStmtDMLRowCount \n---------------------------------------\n{\"Insert\":2,\"Update\":4,\"Delete\":2}\nExample: dbqlstepV - Detect the Longest Running Query in a Time Frame\nThis example detects the longest running query in a particular time frame.\n1. Run the following command to determine what queryid has the longest query:\nSELECT\nqlog.StartTime\n,qlog.QueryId AS QueryId\n,((FirstRespTime - StartTime HOUR(4)) (FLOAT)) * 3600. +\n       ((FirstRespTime - ((FirstRespTime - StartTime HOUR(4) )) - StartTime\n       SECOND(4) ) (FLOAT)) as ResponseTime\n,qlog.NumResultRows\n,qlog.TotalIoCount\n,qlog.AmpCpuTime\n,qlog.SpoolUsage\n,qlog.ERRORCODE\n,qlog.ErrorText\n,qlog.Username\n,qlog.QueryText\nFROM\ntd_metric_svc.DBQLogV qlog\nwhere starttime between '2022-10-31 15:36:21.62' and '2022-10-31 16:07:14.88'\norder by ResponseTime Desc;\nResult: In the output, queryid 307160898229181140 has the longest running query with a response time of 262.453597. This is partial output and the output is displayed\nvertically for readability.\nStartTime: 2022-10-31 15:40:58\nQueryId 307160898229181140\nResponseTime 262.453597\nNumResultRows 5\nLake - Monitor Resources and Performance\nPage 94 of 420TotalIOCount 1442598\nAMPCPUTime 251.908\nSpoolUsage 22623870976\nErrorcode 0\nErrorText\nUserName MEDIUM_USER1\nQueryText \"-- using 6 as a seed to the RNG ...\nStartTime: 2022-10-31 15:36:22\nQueryId 307160898229181080\nResponseTime 260.520936\nNumResultRows 20122\nTotalIOCount 481829\nAMPCPUTime 2106.304\nSpoolUsage 16922267648\nErrorcode 0\nErrorText\nUserName MEDIUM_USER1\nQueryText \"-- using 6 as a seed to the RNG ...\nStartTime: 2022-10-31 15:38:29\nQueryId 307160898229181121\nResponseTime 255.513717\nNumResultRows 19979\nTotalIOCount 469941\nAMPCPUTime 2094.62\nSpoolUsage 16930865152\nErrorcode 0\nErrorText\nUserName MEDIUM_USER1\nQueryText \"SELECT\n        O_ORDERPRIORITY,\n        COUNT(*) ...\"\n[ ... ]\n2. Determine what step in the query took the longest. To determine this, query the DBQLStepV table for the queryid found in the previous step (307160898229181140):\nselect\nQueryID as QueryID\n,StepLev1Num\n,StepLev2Num\n,StepName\n, StepStartTime\n,((StepStopTime - StepStartTime HOUR(4)) (FLOAT)) * 3600. +\n       ((StepStopTime - ((StepStopTime - StepStartTime HOUR(4) )) - StepStartTime\n       SECOND(4) ) (FLOAT)) as StepResponseTime\n, 'Primary Cluster' as Component\n, EstProcTime\n, EstCPUCost\n, NumOfActiveAMPs\n, CPUTime\n, MaxAmpCPUTime\n, MinAmpCPUTime\n, CASE WHEN CPUTime < 1 OR (CPUTime / (HASHAMP()+1)) =0 THEN 0\nELSE MaxAmpCPUTime/(CPUTime / (HASHAMP()+1)) END (DEC(8,2))\nAS CPUSKW\n, IOCount\n, MaxAmpIO\n, MinAmpIO\n, CASE WHEN CPUTime < 1 OR (IOCount / (HASHAMP()+1)) =0 THEN 0\nELSE MaxAmpIO/(IOCount / (HASHAMP()+1)) END (DEC(8,2)) AS IOSKW\n, SpoolUsage\n, MaxAMPSpool\n, MinAMPSpool\nfrom\ntd_metric_svc.DBQLStepV ql\nwhere\nqueryid=307160898229181140 /* this is the queryid of interest */\n--and path_component_id like '%pog%'\norder by StepStartTime;\nLake - Monitor Resources and Performance\nPage 95 of 420Result: From the output we can see that StepLev1Num 9 has the longest response time. This step is performing an aggregation (SUM in the StepName column). This is partial\noutput and the output is displayed vertically for readability.\nQueryId 307160898229181140\nStepLev1Num 1\nStepLev2Num 0\nStepName MLK\nStepStartTime 2022-10-31 15:40:58\nStepResponseTime 0.000266\nComponent Primary Cluster\nEstProcTime 0\nEstCPUCost 0\nNumOfActiveAMPs 1\nCPUTime 0\nMaxAmpCPUTime 0\nMinAmpCPUTime 0\nCPUSKW 0.00\nIOCount 4\nMaxAmpIO 4\nMinAmpIO 0\nIOSKW 0.00\nSpoolUsage\nMaxAMPSpool\nMinAMPSpool\nQueryId 307160898229181140\nStepLev1Num 2\nStepLev2Num 0\nStepName MLK\nStepStartTime 2022-10-31 15:40:58\nStepResponseTime 0.000531\nComponent Primary Cluster\nEstProcTime 0\nEstCPUCost 0\nNumOfActiveAMPs 1\nCPUTime 0\nMaxAmpCPUTime 0\nMinAmpCPUTime 0\nCPUSKW 0.00\nIOCount 4\nMaxAmpIO 4\nMinAmpIO 0\nIOSKW 0.00\nSpoolUsage\nMaxAMPSpool\nMinAMPSpool\n[ ... ]\nQueryId 307160898229181140\nStepLev1Num 9\nStepLev2Num 0\nStepName SUM\nStepStartTime 2022-10-31 15:41:03\nStepResponseTime 234.083157\nComponent Primary Cluster\nEstProcTime 96.69273423\nEstCPUCost 21776.148969\nNumOfActiveAMPs 96\nCPUTime 2281.164\nMaxAmpCPUTime 36.54\nMinAmpCPUTime 14.352\nCPUSKW 0.77\nIOCount 1235766\nMaxAmpIO 18911\nMinAmpIO 8238\nIOSKW 0.73\nSpoolUsage 22623870976\nMaxAMPSpool 413634560\nMinAMPSpool149807104\n[ ... ]\nLake - Monitor Resources and Performance\nPage 96 of 420Example: dbqlutilityV - Retrieve Start Time, End Time, and Row Counts\nThe following SELECT statement retrieves the start time, end time, and row counts for FastLoad or TPT Load jobs submitted by USER1 since December 1, 2013:\nSELECT UtilityName, LSN, JobStartTime, JobEndTime, RowsInserted\nFROM td_metric_svc.dbqlutilityV\nWHERE UserName = 'USER1'\n AND (UtilityName = 'FASTLOAD' OR\n      UtilityName = 'TPTLOAD')\n AND JobStartTime > '2013-12-01'\nORDER BY JobStartTime;\nResult:\nUtilityName LSN JobStartTime               JobEndTime                 RowsInserted\n----------- --- -------------------------- -------------------------- ------------\nFASTLOAD    47  2013-12-02 09:19:22.150000 2013-12-02 09:30:59.670000 100,000\nFASTLOAD    48  2013-12-02 09:19:24.250000 2013-12-02 09:30:44.820000 100,000\nTPTLOAD     54  2013-12-02 10:07:41.700000 2013-12-02 10:07:48.940000 81,920\nTroubleshooting: Query Logging Views for Teradata Employees\nQuery logging data is off-loaded to your own object storage. For help with troubleshooting using that data or query optimization, you can grant Teradata access to views in the table\nthat follows. These views are for Teradata use only.\nThe Teradata employee must ﬁrst be granted SELECT on td_metric_svc:\nGRANT SELECT ON td_metric_svc to td_user;\nView Description\ndbqlexplain_operationsv Contains the explain information in an unformatted string without line breaks. This view is used by Teradata employees only.\ndbqlobj_operationsv Stores information on the target objects of the query being logged. One row is logged for each object referenced by the query. This\nview is used by Teradata employees only.\ndbqlog_operationsv The main table containing information about queries being logged. This view is used by Teradata employees only.\ndbqlsql_operationsv Stores the full SQL text of the query. One query string may require more than one row. This view is used by Teradata employees only.\ndbqlstep_operationsv Stores information about each processing step used to satisfy the query. One row is logged for each step, including parallel steps.\nThis view is used by Teradata employees only.\ndbqlsummary_operationsv Stores information about queries that meet the criteria for a rule specifying the LIMIT SUMMARY or LIMIT THRESHOLD option. This\nview is used by Teradata employees only.\ndbqlutility_operationsv Each row stores information about one completed load/export or Data Stream Architecture job. This view is used by Teradata\nemployees only.\nManaging Your Workloads\nVantageCloud Lake requires signiﬁcantly less workload management techniques as compared to other Vantage offerings. There are several reasons for this:\nCompute clusters offer a natural boundary between different types of work that are active at the same time. Because of this, workloads from speciﬁc departments or certain\napplications can be isolated on their own set of compute clusters. This many-cluster architecture removes the need to rely on complex workload management rules to protect\nhigh priority work from less important work as would be the case when they are both contending for the same platform resources.\nCompute groups give departments the opportunity to control their own resource consumption and cost, decentralizing control over work in a way that is not possible on a single\nplatform shared by all departments. Within a given department or application, there may be no need for priority differentiation. When prioritization is required, it is likely to be\nsatisﬁed by a modest number of simple priority assignments within each compute group.\nCompute groups come with their own internally created throttle rules, which limit the number of queries that are allowed to run on the compute clusters belonging to that\ncompute group. For this reason, sophisticated workload management such as placing hard limits on resource usage or reserving certain types of resource for just the high\npriority work is not needed.\nAuto-scale capabilities within compute groups unleash additional resource on demand, and the degree of elasticity can be automatically increased or decreased by time of day\nto match changing patterns in the workﬂow of a department. Because of the ﬂexibility of auto-scale, there is no need for workload management rules that keep track of resource\nusage in real time and tighten workload rules when times of high utilization are reached.\nThe emphasis of workload management on VantageCloud Lake is simplicity and ease of use, relying as much as possible on the natural boundaries created by distinct primary\nclusters and compute clusters. The initial default workload management settings are expected to satisfy the needs of the majority of VantageCloud Lake users.\nWorkload Management Priorities\nDeﬁning System Throttle or System Filter Rules\nWorkload Management Priorities\nThe goal of default workloads is to offer simplicity, ease of use, and uniformity across processing components.\nWith default workloads, all active queries running on VantageCloud Lake that are not otherwise assigned a priority are automatically given a priority based on their query\ncharacteristics. Whatever the Teradata optimizer determines is the estimated processing time for a query determines what priority it will be assigned. The optimizer produces these\nquery estimates when it builds a query plan.\nLake - Monitor Resources and Performance\nPage 97 of 420New automatically assigned workloads have been introduced into VantageCloud Lake workload management. With these new default workloads (illustrated the the second table\nbelow), all active queries running on VantageCloud Lake that are not otherwise assigned a priority are automatically given a priority based on their query characteristics. Whatever the\nTeradata optimizer determines is the estimated processing time for a query determines which of these new default priorites will be assigned. The optimizer produces these query\nestimates when it builds a query plan.\nFor example, all queries expected to be very short (that have an estimated processing time 1 second or less) start executing at a very high priority. However, if any of these queries\nconsumes more than a very small amount of CPU or I/O they will be demoted to a lower priority. On the other hand queries with more substantial estimated processing times will be\nassigned a starting priority that is somewhat lower in priority. If they run longer than expected, they will also be demoted to a lower priority. A total of four different default priorities are in\nplace to support automated prioritization and demotion.\nThis automatic priority assignment can be overridden by assigning particular users one of the other default priorities based on account string. Queries submitted by users who have\nbeen assigned a priority in their account string will all execute at that speciﬁed priority and will never be demoted.\nYou can override the automatically-assigned priorities by assigning speciﬁc users to one of the ﬁve non-automatic priorities that are based on account strings, as shown in this table:\nWorkload Name Workload Priority or Access Level Timeshare Access Rate Workload Classiﬁcation\nT-WD Timeshare Top 8 ACCOUNT='$R' 1\nH-WD Timeshare High 4 ACCOUNT = '$H'\nM-WD Timeshare Medium 2 ACCOUNT='$M'\nL-WD Timeshare Low 1 ACCOUNT = '$L'\nTactical-WD Tactical Not applicable ACCOUNT = '$TA'\n1 With the introduction of Teradata Active System Management (TASM) over a decade ago, the highest default priority in Teradata was changed from \"Rush\" to \"Timeshare Top\" and is\nrepresented today by the T-WD workload name. However, to be backward compatible, the user account string value that maps to the T-WD workload was left as '$R', which\nrepresents the earlier Rush workload. Any user associated with an account string starting with '$R' will be mapped to the Timeshare Top workload named T-WD.\nThese workloads use estimated processing time as classiﬁcation and contain exceptions that demote queries to a lower priority based on a threshold of CPU usage.\nWorkload Name Workload Priority or\nAccess LevelTimeshare Access Rate Workload Classiﬁcation Exception Exception Action\nTC Tactical Not applicable Total (estimated) processing\ntime <=1\nAnd not ALL-AMPSStandard tactical exceptionChange to TT\nTT Timeshare Top 8 Total (estimated) processing\ntime <= 1 secondTotal CPU > 5 seconds Change to HH\nHH Timeshare High 4 Total (estimated) processing\ntime > 1 second <= 10\nsecondsTotal CPU > 45 seconds Change to MM\nMM Timeshare Medium 2 Total (estimated) processing\ntime > 10 seconds <= 120\nsecondsTotal CPU > 240 seconds Change to LL\nLL Timeshare Low 1 Total (estimated) processing\ntime > 120 secondsNot applicable Not applicable\nAccess rate expresses the relative increase in resources (CPU and I/O) made available to queries running at that access level (Timeshare High, for example), compared to the level of\nresources available to queries running in the Timeshare Low access level. For example, a query running in Timeshare Top (T-WD) will receive 8 times the resources as a query running\nin Timeshare Low, 4 times the resource as a query running in Timeshare Medium, and 2 times the resource running in Timeshare High.\nThis example shows how to assign a user to the workload H-WD, which runs at the Timeshare High priority:\nMODIFY USER medium_user1 AS account='$H';\nThe account string name must be placed in the User or the Proﬁle record in the Data Dictionary. From that point on, all the queries issued by the user will be run at that priority on both\nthe primary cluster and on the compute cluster. If a query is submitted by a user who does not have an account string speciﬁed in their User or Proﬁle record, that query will run in one\nof the automated priority workloads based on estimated processing time.\nPassing Priorities Between Primary Clusters and Compute Clusters\nA query is associated with one of the four Timeshare workloads if the user who submitted the query carries one of the expected account strings in their User or Proﬁle record. If the\nuser has been assigned this account '$H', for example, all of their queries will execute under the control of H-WD workload and run at a high priority.The workload name and the\naccount string are passed across the Query Fabric to the compute cluster at the time the primary cluster is transferring control to the compute cluster. This makes sure that any priority\nthat has been established on the primary cluster will be honored on the compute cluster as well.\nDefining System Throttle or System Filter Rules\nSystem throttles are a widely used workload management functionality that allow administrators to limit concurrency of queries entering the database based on speciﬁed\ncharacteristics of the query. System throttles only work on primary clusters. A system ﬁlter rejects queries before the query begins execution, based on information contained within the\noptimized plan of the query or session logon details (tables accessed, user, IP address, and so on).\nLake - Monitor Resources and Performance\nPage 98 of 420Additional system throttles can be used to make sure that only a few resource-intensive queries execute at the same time, so more resources are available for shorter and more\nbusiness-critical applications. System throttles are useful to control concurrency of queries performing advanced analytics or accessing external object storage data through the Native\nObject Store feature, where lower concurrency moderates resource demands.\nSee Workload Management: Ruleset APIs for information on applying APIs and implementation examples.\nBring Your Own Viewpoint\nThe Bring Your Own Viewpoint (BYOVP) model establishes basic connectivity between an existing multisystem Viewpoint implementation of Viewpoint, and the primary cluster of a\nVantageCloud Lake environment.\nTo use Bring Your Own Viewpoint (BYOVP) model, make sure you have:\nAn existing Multi-System Viewpoint in a customer tenant.\nViewpoint 22.10.00.00 or later version.\nMulti-System Viewpoint Support for the BYOVP Model\nMulti-System Viewpoint Availability by Deployment Option\nConsiderations in Using Viewpoint\nData Collector Support for BYOVP\nMulti-System Viewpoint Support for the BYOVP Model\nThe following table outlines the supported BYOVP versions for various VantageCloud Lake platforms on AWS, Azure, and Google Cloud.\nMulti-System V iewpoint V ersion VantageCloud Lake on AWS VantageCloud Lake on Azure VantageCloud Lake on Google Cloud\n24.08.00.00 Yes Yes Yes\n24.04.00.00 Yes Yes Yes\n23.10.00.00 Yes Yes No\n23.04.00.00 Yes Yes No\n22.10.00.00 Yes Yes No\nEarlier Versions No No No\nMulti-System Viewpoint Availability by Deployment Option\nThe following table outlines the platforms supporting the installation of BYOVP from the Cloud marketplace and subsequent connection with VantageCloud Lake on AWS, Azure, and\nGoogle Cloud.\nMulti-System V iewpoint\nVersionTMS/VMS VMW are VaaS on\nAWSAWS\nMarketplaceVaaS on\nAzureAzure\nMarketplaceVaaS on Google\nCloudGoogle Cloud\nMarketplace\n24.08.00.00 Yes Yes No Yes No Yes No Yes\n24.04.00.00 Yes Yes No Yes No Yes No Yes\n23.10.00.00 Yes Yes No Yes No Yes No No\n23.04.00.00 Yes Yes No Yes No Yes No No\n22.10.00.00 Yes Yes No Yes No No No No\nEarlier Versions No No No No No No No No\nAdding VantageCloud Lake  to Multi-System V iewpoint based on deployment options on AWS and Azure\nThe following table details the procedure and steps required to install a BYOVP instance from Cloud Marketplace and establish a connection with the corresponding VantageCloud\nLake.\nIt is important to understand that there is no provision for cross-cloud connectivity between BYOVP and VantageCloud Lake. For example, BYOVP on AWS and VantageCloud Lake on\nAzure.\nThe following table lists the deployment options and the path considered.\nDeployment T ype Via\nTMS/VMS Public IP of primary cluster Router\nVMware Public IP of primary cluster Router\nVaaS on AWS NA\nLake - Monitor Resources and Performance\nPage 99 of 420Deployment T ype Via\nAWS marketplace\nBYOVP Installation for AWS. See BYOVP AWS Marketplace Installation.\nPrivate Link Connectivity between BYOVP and VantageCloud Lake. See KB0049074 in\nhttps://support.teradata.com.\nVaaS on Azure NA\nAzure marketplace\nBYOVP Installation for Azure. See BYOVP Azure Marketplace Installation.\nPrivate Link Connectivity between BYOVP and VantageCloud Lake. See KB0050394 in\nhttps://support.teradata.com.\nVaaS on Google Cloud NA\nGoogle Cloud Marketplace\nDeployment steps for BYOVP from Google Cloud Marketplace. See KB0057982 in\nhttps://support.teradata.com.\nPrivate Service Connect (PSC) between BYOVP and VantageCloud Lake. See KB0057989\nin https://support.teradata.com.\nConsiderations in Using Viewpoint\nThe Viewpoint portlets available for monitoring in the VantageCloud Lake environment are speciﬁcally designed to monitor the primary cluster. It's important to note that these portlets\ndo not currently support monitoring of the compute cluster, and OFS Storage is not included in the monitoring capabilities for VantageCloud Lake.\nWhen adding the primary cluster of VantageCloud Lake to the monitoring system, the process is similar to adding any other Teradata systems. For more detailed instructions on this\nprocedure, you can refer to the Teradata® Viewpoint User Guide.\nDuring a Blue/Green upgrade, the behavior of BYOVP remains consistent as there are no changes in the Sessions Manager's public IP address. The following Viewpoint portlets have\nbeen veriﬁed for compatibility with the VantageCloud Lake environment\nParent Group Supportability on V antageCloud Lake Portlet Name\nSession Management\nThe QueryGrid is a native cloud component on\nthe VantageCloud Lake architecture. So, BYOVP\nfor VantageCloud Lake does not support\nQueryGrid Query Monitoring.Supported Query Monitor\nQuery Groups\nMy Queries\nQuery Spotlight\nLock Viewer\nNot Supported Query Log\nApplication Queries\nNot Applicable for Monitoring or Managing Completed Queries\nSystem Overview\nMSS (Metric streaming service) ofﬂoads all the\nRSS data to S3 buckets. So, the Elastic\nPerformance on Demand (EPOD) functionality\ndoes not work on the VantageCloud LakeSupported Canary Response Times\nProductivity\nSpace Usage\nSystem Health\nToday's Statistics\nAlert Viewer\nNot Supported Elastic Performance\nNot Applicable for Monitoring or Managing Hadoop Services\nViewpoint Monitoring\nNode Overview Supported Node Resources\nNot Applicable for Monitoring or Managing Node Monitor\nTrends\nThe portlets cannot monitor any DBQL query\nlogging metrics. They also cannot monitor the\nfollowing RSS metrics:\nAverage Memory Available\nCPU/Disk Ratio\nFSG Cache MissSupported Metrics Analysis\nLake - Monitor Resources and Performance\nPage 100 of 420Parent Group Supportability on V antageCloud Lake Portlet Name\nIndex Ratio\nLogical MB/Sec\nMinimum Memory Available\nParallelism\nRead I/O\nTotal AMP CPU\nTotal Node CPUMetric Heatmap\nWorkload Management Supported\nTASM rulesets may be applied to Primary Cluster\nworkloads only. The architectural changes in\nVantageCloud Lake may deprecate some workload\nmanagement strategies. See Managing Your\nWorkloads for more details.\nBy default, the administrator logins (TDWM user) are\ndisabled on VantageCloud Lake. To use Workload\nManagement, enable the administrator login for TDWM\nuser.Workload Designer\nWorkload Health\nWorkload Monitor\nUtilities\nThe VantageCloud Lake Console already has the\nSQL Client to run the queries of VantageCloud\nLake Environment. So, the SQL Scratchpad can\nbe alternative.Supported SQL Scratchpad\nNot Supported Remote Console\nNot Applicable for Monitoring or Managing Viewpoint Calendar\nApplications Supported Data Labs\nAs part of the BYOVP, you can bring your own Data Lab to lake (BYODL).\nData Labs portlet including the existing DataLabs API (with API\nExtensions) supports only for the primary cluster of VantageCloud Lake.\nYou can perform the following actions for Data Labs using the Viewpoint\nportlet:\nProvisioning, conﬁguring, and editing lab groups and labs\nUsers and roles accessing to the lab\nGranting access permissions to view reports\nTeradata user or role generating reports\nGenerating veriﬁed reports by lab groups\nGetting lab group access information in lab details\nProvisioning and conﬁguring lab groups, deleting, and editing a lab,\nincreasing, or decreasing Lab sizes, and generating reports with veriﬁed\nREST APIs.\nNot Supported Stats Manager\nPerformance Data Collection (PDCR)\nNot Applicable for Monitoring or Managing Bar Operations\nData Mover\nMaps Manager\nUnity Director\nUnity Director Setup\nQueryGrid\nAdministration Portlets Supported Monitored Systems\nRoles Manager\nUser Manager\nPortlet Library\nBackup\nCertiﬁcates\nAlert Setup\nQuery Group Setup\nGeneral\nLake - Monitor Resources and Performance\nPage 101 of 420Parent Group Supportability on V antageCloud Lake Portlet Name\nShared Pages\nNot Applicable for Monitoring or Managing LDAP Servers\nServer Management\nBAR Setup\nData Mover Setup\nData Collector Support for BYOVP\nThe following table outlines the comprehensive functionality of Viewpoint that has been veriﬁed on VantageCloud Lake in relation to all the Teradata Data Collectors. The majority of\nthese collectors are tailored for Viewpoint Administration purposes and can be effectively utilized in conjunction with VantageCloud Lake for monitoring purposes\nData Collector Validation\nAccount Information Collector\nSupports with respect to primary cluster only collection.Alert Request Collector\nAWT Information Collector\nDatabase Space Collector\nDictionary Collector\nDisk Space Collector\nLock Information Collector\nSessions Collector\nSystem Conﬁg Collector\nTable Space Collector\nTASM Conﬁg Collector\nTASM Distribution Collector\nTASM Exception Collector\nTASM State Collector\nTASM Summary\nElastic Limit Collector Not supported for VantageCloud Lake monitoring as these collectors are dependent on\nRSS data which is being purged from RSS tables. And also EPOD is not\ndesigned/applicable for VantageCloud Lake architecture.Elastic Usage Collector\nResource Usage Supported for few metrics through MONITOR PHYSICAL RESOURCE PM/API. Metrics\nwhich are dependent on RSS tables is not supported for monitoring VantageCloud Lake\ninstance as the RSS data is being purged from RSS tables.System Statistics\nQuery Log Collector Not supported for VantageCloud Lake monitoring as these collectors are dependent on\nDBQL data which is being purged from DBQL tables.Query Count Collector\nStatistics Manager Collector Not applicable for VantageCloud Lake monitoring.\nVirtual Storage Collector\nPerformance Monitoring and Workload Management APIs\nThis document for the Teradata Vantage APIs describes the following types of APIs and how to use them to interface with your custom applications when other tools (such as resource\nusage reports) or client applications do not provide the information you need:\nWorkload Management API\nWorkload management APIs can be used for creating third-party applications and custom applications requiring the acquisition and use of Teradata workload management and\nperformance data.\nThe workload management PM/APIs described in this document use monitor software versions 11 and earlier (see MONITOR VERSION for details). These PM/APIs allow you to\ncreate new applications and enhance existing custom applications.\nAutomated Statistics Management APIs\nThe Automated Statistics Management APIs allow callers to control its behavior and monitor its tuning activity.\nThe following content is mainly applicable to the standard nodes of the primary cluster in VantageCloud Lake and may not apply to compute clusters on the primary cluster.\nFor information about the primary cluster and compute clusters, see Managing Compute Resources.\nLake - Monitor Resources and Performance\nPage 102 of 420Types of APIs\nWorkload Management: PM/API\nWorkload Management API Features and Examples\nSystem PMPC APIs\nWorkload Management: Single Operational View APIs\nTeradata Dynamic Workload Management APIs: PM/APIs\nWorkload Management: Query Band APIs\nWorkload Management: Embedded Services System APIs\nWorkload Management: Ruleset APIs\nWorkload Management: Ruleset Views\nDashboard Reporting APIs\nManual Control and Customization APIs\nAutomated Statistics Management APIs\nSample PM/API Application\nMONITOR SESSION Response Combinations\nTypes of APIs\nThe following describes the different types of APIs and the requirements for using them.\nWorkload Management API\nWorkload Management API\nWorkload management API consists of interfaces to PM/APIs and open APIs. You can use these interfaces to:\nMonitor system and session-level activities.\nMonitor Teradata Active System Management (ASM) activity.\nTrack system usage and manage task priorities.\nModify Workload Management ruleset.\nAPI Categories\nPM/APIs and open APIs, also called SQL interfaces, are divided into the following categories:\nSystem PMPC\nTeradata Dynamic Workload Management\nQuery Band\nRuleset\nEmbedded services system is another category that applies only to some of the SQL interfaces (for example, the GetPSFVersion and TD_get_COD_limits functions).\nThe following diagram shows how:\nThe System PMPC, Teradata Dynamic Workload Management, and Query Band PM/API requests (such as Call-Level Interface Version 2 [CLIv2] and the Teradata JDBC Driver)\ninterface to the PMPC subsystem through the MONITOR partition.\nThese PM/APIs are supported by both Call-Level Interface Version 2 (CLIv2) and the Teradata JDBC Driver. See Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe System PMPC and Teradata Dynamic Workload Management SQL interfaces (such as, user-deﬁned functions and external stored procedures) connect to the PMPC\nsubsystem through the SQL partition, except TDWMApply, TDWMRuleControl, and TDWMSetLimits. These APIs connect to the database system through the SQL partition and\nare not shown in the following diagram.\nThe embedded services system and most Query Band SQL interfaces connect to the SQL partition, except MonitorQueryband. This SQL interface is the only Query Band API\nthat connects to the PMPC subsystem through the SQL partition and is not shown in the following diagram.\nLake - Monitor Resources and Performance\nPage 103 of 420\nSee also:\nWorkload Management API Features and Examples\nSystem PMPC APIs\nTeradata Dynamic Workload Management APIs: PM/APIs\nWorkload Management: Query Band APIs\nWorkload Management: Embedded Services System APIs\nWorkload Management: Ruleset APIs\nPM/APIs\nPM/APIs provide access to PMPC routines resident in Teradata Vantage™. The PMPC subsystem is available through a logon partition called MONITOR, using a specialized PM/ API\nsubset of CLIv2 or Teradata JDBC Driver.\nPM/APIs have the following features:\nCLIv2 or Teradata JDBC Driver data is acquired in near real time, with less overhead and minimal possibility of being blocked. These capabilities allow frequent in-process\nperformance analysis.\nCLIv2 request saves the raw data in an in-memory buffer where a client application program can easily retrieve the data for real-time analysis or importing into custom reports.\nThe Teradata JDBC Driver returns the data as a JDBC ResultSet where a client application program can easily retrieve the data.\nCLIv2 or Teradata JDBC Driver request provides access to data that the resource usage does not. For example, session-level resource usage data, and data on application\nlocks and which application is being blocked.\nUsing PM/APIs may not be the right choice for all performance monitoring requirements. Standard performance monitoring tools and reports, such as resource usage reports, may be\nsufﬁcient.\nOpen APIs\nThe workload management open API provides an SQL interface to the PMPC subsystem and Teradata system through user-deﬁned functions, embedded services functions, and\nexternal stored procedures. Most of the SQL interfaces available to the PMPC subsystem provide similar functionality to the CLIv2 or Teradata JDBC Driver requests.\nMost open APIs do not follow transaction rules. If a transaction calls a UDF or external stored procedure and the transaction rolls back, the action of the UDF or external stored\nprocedure is not rolled back. However, the external stored procedures that update the TDWM database must follow the transaction rules. If a transaction calls one of these external\nstored procedures and the transaction is aborted, the update is rolled back.\nDifferences between Open APIs and PM/APIs\nThe following table describes the differences between open APIs (that is, SQL interfaces consisting of UDFs or external stored procedures) and PM/APIs.\nOpen APIs PM/APIs\nAre issued in the current SQL partition Require logging on to the MONITOR partition. To view a diagram of the process, see API\nCategories.\nRequire EXECUTE privilege on the function or external stored procedure Require MONITOR privileges.\nUse SQL parsing, dispatching steps, and UDF processing Require use of a custom application in C, Java, or another programming language.\nRun in priority of account string or by the Teradata dynamic workload management\nsoftware classiﬁcationRun in the system priority.\nCan be placed on a Teradata dynamic workload management software delay queue\nand can block system resourcesDo not block.\nLake - Monitor Resources and Performance\nPage 104 of 420Open APIs PM/APIs\nUse AMP Worker Tasks (AWTs) Are not subject to running out of resources (AWTs).\nPM/APIs Requirements for Using the API\nIf you are using CLIv2, you must install CLIv2 on a client machine where the PM/API application is running.\nIf you are using the Teradata JDBC Driver, you must import the SQL Interface package and load the Teradata JDBC Driver. For complete instructions, see Teradata JDBC Driver\nReference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nRequired Privileges\nEach API described in this document, except for the MONITOR VERSION request and the embedded services system functions, has its own required privileges.\nFollowing are examples of the required privileges.\nTo connect with the Teradata JDBC Driver, it is necessary that you are granted privileges for running PM/API requests. For example, you must issue GRANT MONITOR TO guest\nbefore connecting as a guest user and running any PM/API request.\nTo issue the ABORT SESSION and MONITOR SESSION requests, you must have the ABORTSESSION and MONSESSION privileges respectively as part of your default role or\nthese privileges must be granted directly to you.\nTo issue the MONITOR AWT RESOURCE, MONITOR VIRTUAL RESOURCE, and MONITOR PHYSICAL RESOURCE requests, you must have the MONRESOURCE privilege as\npart of your default role or this privilege must be granted directly to you.\nTo access the UDFs and external stored procedures, the DBA must grant EXECUTE FUNCTION and EXECUTE PROCEDURE privileges to you. These privileges are not granted\nby default.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nRelated Information\nTopic Reference\nthe different System PMPC PM/APIs and open APIs System PMPC APIs.\nthe different Teradata Dynamic Workload Management PM/APIs and open APIs Teradata Dynamic Workload Management APIs: PM/APIs.\nthe different Workload Management ruleset APIs Workload Management: Ruleset APIs\nthe different Query band PM/APIs and open APIs Workload Management: Query Band APIs.\nthe different embedded services system functions Workload Management: Embedded Services System APIs.\nhow to code an application that uses the CLIv2 requests in this document\nTeradata® Call-Level Interface Version 2 Reference for Mainframe-Attached\nSystems, B035-2417.\nTeradata® Call-Level Interface Version 2 Reference for Workstation-Attached\nSystems, B035-2418.\nusing the Teradata JDBC Driver to access the database\nTeradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nWorkload Management: PM/API\nThe following describes how each MONITOR request processes the following PM/APIs issued to Vantage by an end-user application interface on a client:\nSystem PMPC\nTeradata Dynamic Workload Management\nQuery Band\nThe client can be either a mainframe-attached or workstation-attached.\nPM/API Processing\nComparisons between PM/API and Teradata SQL Requests\nPM/API Dynamic Data\nPM/API Processing\nYou can use the following Teradata proprietary APIs and libraries to write end-user application interfaces to PM/API routines.\nCLIv2, an interface between the end-user application written in C and the Teradata Director Program. Teradata Director Program is the interface between CLIv2 and the\ndatabase. For an example of CLIv2, see Sample PM/API Application.\nThe Teradata JDBC Driver, an interface between the end-user application written in Java and the database.\nLake - Monitor Resources and Performance\nPage 105 of 420Whether the client application interface you develop is a simple utility or a complex system, the process is the same. Because the PM/API is accessed by either CLIv2 or the Teradata\nJDBC Driver, requests and responses are processed in much the same way as for a Teradata SQL application. No changes are required in CLIv2 or the Teradata JDBC Driver to\nsupport PM/API. Therefore, PM/API capabilities are available on any client platform that supports CLIv2 or the Teradata JDBC Driver.\nRelated Information\nTopic Reference\nCLIv2\nTeradata® Call-Level Interface Version 2 Reference for Mainframe-Attached Systems, B035-2417\nTeradata® Call-Level Interface Version 2 Reference for Workstation-Attached Systems, B035-2418\nTeradata JDBC Driver\nTeradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nCreating a Request with CLIv2\nYour client application program tells CLIv2 what to do by creating a request string consisting of:\nA request parcel (when the response is desired in record mode) or an IndicReq parcel (when the response is desired in indicator mode).\nWhen set in CLI or CLIv2, the response mode option uses the correct request parcel format.\nA USING Data String, which contains the input data.\nUnlike Teradata SQL, PM/API does not use a USING Phrase to name the variables and reserve space in the request parcel. Instead, each MONITOR request has a USING Data\nString of a ﬁxed format that determines the order of items, their data types, and lengths.\nBecause a USING Data String is required, either a data parcel must follow a request parcel or an IndicData parcel must follow an IndicReq parcel.\nAn IndicData parcel is recommended, because there are ﬁelds in the USING Data String that can be NULL.\nGenerating an IndicReq parcel returns a response that contains a PclDataInfo parcel, which describes the number of response columns. Each Record parcel returned begins with\npresence bits that supply the NULL indicators for the result columns.\nTo pass PM/API requests to the database as the text portion (body ﬁeld) of the request parcel, the application program calls the CLIv2 DBCHCL routine with the DBCAREA function\ncode (4) set to the Initiate Request operation.\nCode your application program to do the following before calling CLIv2 for the Initiate Request operation:\nSet the request pointer to the address of a character string containing the request name.\nFor the IDENTIFY request, set the request pointer to the address of a character string containing one of the following:\nIDENTIFY SESSION\nIDENTIFY DATABASE\nIDENTIFY USER\nIDENTIFY TABLE\nSet the request length to the length in bytes of the character string.\nSet the USING Data pointer to the address of the USING Data String.\nSet the USING Data Length to the length in bytes of the USING Data String.\nSetting Indicator or Record Mode\nYou can send the USING Data String in either indicator mode or record mode. CLI must inform CLIv2 which mode is used by setting the appropriate use presence bits option in the\nDBCAREA.\nThe use presence bits option is typically set to a default value for the site.\nGoal Procedure\nChange default value\n1. Set change options to Y in the application program.\n2. Set the use presence bits option in the DBCAREA to Y.\nThis also allows the application program to send NULL data to the Teradata system.\nHave USING Data String sent in record mode\n1. Set change options to Y in the application program.\n2. Set the use presence bits option to N in the DBCAREA in the application program.\nExecuting a Request with the T eradata JDBC Driver\nThe client application uses a PreparedStatement, an object that represents a prepared SQL statement, for the PM/API requests. The client application:\nSpeciﬁes the PM/API request text as the Connection PreparedStatement method’s SQL argument. The Connection interface represents a session with a speciﬁc database.\nIs not permitted to specify multiple requests separated by semicolons.\nCan only specify a single PM/API request.\nLake - Monitor Resources and Performance\nPage 106 of 420Speciﬁes the input data of the PM/API request with the PreparedStatement setter methods (for example, setString or setObject).\nMust use the PreparedStatement execute() method to run the PM/API request because each PM/API request may return multiple results. The execute() method handles these\ncomplex results.\nSee Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nResponse Processing with CLIv2\nPM/API requests are processed similarly to Teradata SQL requests because CLIv2 is used for both. Response processing is similar in both parcel ordering and buffer allocation. For an\nexample CLI program, see Sample PM/API Application.\nThe response can be returned from the database in either indicator or record mode, depending on how the response mode option is set in CLIv2. You can set response mode to be\nindependent of input data mode. For example, sending the input data in record mode may be more convenient, but the response may require indicator mode if NULL is expected.\nResponse mode is typically set to a default value for the site. If you want to change the default value set, change options to Y in the application program. CLIv2 uses the correct\nrequest parcel format.\nReturn Data Mode Response Mode Option in DBCAREA\nIndicator mode I (Indicator)\nRecord mode R (Record)\nField mode, represented by F, is not supported in a PM/API request.\nRetrieving Results with the T eradata JDBC Driver\nEach PM/API request may return multiple results. The client application must use the PreparedStatement execute() method to execute the PM/API request.\nThe client application calls the PreparedStatement getResultSet() method to retrieve the ResultSet from the PM/API request. A ResultSet provides access to a table of data generated\nby executing a PM/API request. The table rows are retrieved in sequence. Within a row, its column values can be accessed in any order.\nIf the PM/API request returned multiple results, the client application calls the PreparedStatement getMoreResults() method to advance to the next result. Then, the client application\ncalls the PreparedStatement getResultSet() method to retrieve the result set.\nSee Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nParcel Ordering\nThe response returned from a MONITOR request is a series of parcels constructed by the database and sent to the client.\nThe basic parcel layout for a successful response is the same for most MONITOR requests, except the following:\nMONITOR SQL\nMONITOR VERSION\nMONITOR requests such as the following:\nMONITOR SESSION\nMONITOR VIRTUAL CONFIG\nMONITOR PHYSICAL CONFIG\nMONITOR VIRTUAL RESOURCE\nMONITOR PHYSICAL RESOURCE\nbehave like multiple-statement requests, for which multiple record parcels are returned. For request-speciﬁc parcel layout, see System PMPC APIs.\nThe following table shows the parcel layout for an unsuccessful response is the same for all MONITOR requests -- either a Failure or an Error parcel is returned.\nParcel Name Parcel Number Field Length Comments/Key Parcel Body Fields\nFailure 9 15 to 267 Message code and message text: description of cause of failure; request could not be processed.\nFor example, the request is aborted.\nError 49 15 to 267 Message code and message text: description of cause of error. Application can ﬁx the problem and\nresubmit the request. For example, response buffer is too small to hold entire response row.\nBuffer Allocation with CLIv2\nA PM/API application, like a Teradata SQL application, requires space for a:\nResponse buffer, containing the parcels transmitted back from the database.\nRequest buffer, containing the parcels sent to the database.\nSpace for these two buffers is allocated for the application by CLIv2 based on the setting of DBCAREA arguments at the time a session is established. Default buffer sizes are\ncontrolled by the HSHSPB (control block containing site speciﬁc information), which is created during installation when CLI defaults are speciﬁed. The minimum size of a response\nbuffer is 32,000 bytes.\nIf your response buffer is not large enough, your application program may get an error message. For details on error messages, see Database Messages.\nLake - Monitor Resources and Performance\nPage 107 of 420Logging On\nA PM/API application logs on similar to a Teradata SQL application. However, there are differences.\nThe partition name is MONITOR:\nIn a Java application, specify the Teradata JDBC Driver PARTITION=MONITOR connection parameter. For details, see Teradata JDBC Driver Reference, available at\nhttps://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nIn a CLIv2 application, set the following:\nRun pointer to the address of the character string containing the word MONITOR.\nRun length to the length in bytes of the character string containing the word MONITOR.\nYour logon fails if:\nYou do not have the appropriate MONITOR privilege.\nThe PE or client that the MONITOR session is logged on to is already supporting its maximum number of four MONITOR sessions.\nOn the PE, the load balancing mechanism does not support MONITOR partition sessions. Session Control allocates MONITOR session requests to the PE on which a MONITOR\nsession is logged until the four sessions per PE limit is reached.\nThe system-wide limitation of 128 concurrent MONITOR sessions is reached.\nLogging Off\nA PM/API application logs off the same way a Teradata SQL application does with one exception. If you log off a session that has a local session monitoring rate (SesMonitorLoc) of\nnonzero, the rate is changed to zero. This change is added to the DBC.SW_Eve nt_Log table (accessible from the DBC.Software_Event_LogV view), which is similar to what occurs if\nyou had issued a SET SESSION RATE request before logging off.\nA Java application calls the Connection close() method of the Teradata JDBC Driver to log off. The Connection close() method immediately releases a database and the JDBC\nresources instead of waiting for their automatically release. See Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nWarning and Error Messages\nFor a general discussion on common warning and error messages that may be returned in response to requests, see Common Warning and Error Messages.\nFor detailed information on the meaning of individual error and warning messages and the response required, see Database Messages.\nComparisons between PM/API and Teradata SQL Requests\nThere are both similarities and differences between PM/API applications and Teradata SQL applications, such as Basic Teradata Query (BTEQ), special utilities (for example, Teradata\nFastLoad), and third-party software.\nSimilarities\nThe similarities between a PM/API based application and a Teradata SQL-based application include:\nData types supported for input and output data in PM/API applications are a subset of those data types supported by Teradata SQL.\nFixed length character data is blank padded on the right.\nNULL returned for the PclRecordType response parcel is equal to NULL returned by Teradata SQL (see Response Groups).\nDifferences\nThe differences between a PM/API based application and a Teradata SQL-based application are:\nA PM/API application issues requests through a session partition named MONITOR.\nThe MONITOR partition returns an error message if you use any of the following Teradata SQL partition capabilities:\nKeep Response processing mode\nRun a rewind operation\nRun the start-up operation\nField mode request\nCleanUp request\nP (Prepare) or S (Setup) request processing option of the DBCAREA\nKeywords used by the MONITOR PM/API requests are different from keywords in Teradata SQL. However, both have the same rules for identiﬁers.\nMONITOR query processing, unlike Teradata SQL, produces dynamic data.\nData String, which deﬁnes the input data, is required in a PM/API application when using CLIv2, but optional in Teradata SQL.\nKeywords/Reserved W ords\nThe following keywords are database-reserved words:\nABORTSESSION\nMONITOR\nMONRESOURCE\nMONSESSION\nSETRESRATE\nLake - Monitor Resources and Performance\nPage 108 of 420SETSESSRATE\nThe following keywords are database non-reserved words that are permitted as object names, but discouraged because of the possible confusion that may result:\nMONSQL\nMONVERSION\nFor a complete list of words that are unavailable for use as object names, see Restricted Words.\nUsing T eradata SQL  GRANT and REVOKE Statements\nIf you are using a Teradata SQL-based application, you can issue the GRANT (SQL Form) and REVOKE (SQL Form) statements.\nA change in privileges can temporarily block the request of an active MONITOR session, because the system must look up the new privileges before accepting more requests from the\naffected user. If the system query is blocked by a lock on a database dictionary table, or if there is another system processing bottleneck, you cannot issue MONITOR requests until\nyou acquire the new set of privileges. However, MONITOR requests submitted from the system console are not blocked by a change in privileges, because no privileges are necessary\nto issue MONITOR requests on the system console.\nUsing ABORT SESSION Request\nIf you are using a PM/API based application, you can issue the CLIv2 or the Teradata JDBC Driver ABORT SESSION request.\nWith the proper privileges granted, you can stop and log off a database user.\nABORT SESSION Error Message\nTargets a current database request or session Transaction is aborted.\nTargets a request or session after the user has logged off from\nthe databaseSession is not logged on.\nThe error message is not returned to the user of the affected session until ABORT SESSION completes rolling back the current transaction or, if applicable, the session is logged off.\nThe status of an active session determines when the user gets the error message.\nCondition When You Issue ABORT REQUEST Error Message\nA request is outstanding for the user session. Sent as a response to the current request.\nNo request is outstanding, but a session is in progress.Sent to user when the system gets the next request.\nFor more information on this request, see ABORT SESSION.\nPM/API Dynamic Data\nWhen you issue a request through the Monitor partition, current and dynamic data is reported. PM/API requests place data in a global repository (in memory), not in an intermediary\nspool ﬁle (on disk). AMP, PE, node, and session-level usage data are each collected in independent data collection global areas.\nTherefore, changes in the resource collection rate have no impact on session-level data, and the reverse. Any MONITOR request, except MONITOR VIRTUAL CONFIG, MONITOR\nPHYSICAL CONFIG, and IDENTIFY, may cause the memory repository to be updated on demand (speciﬁcally, once each collection period). All users share the data in the repository,\nwhich is used to generate responses to both queries and CONTINUE requests.\nMonitoring Rates\nBe aware of the rate at which your PM/API client application requests performance data. If a PM/API client application requests data more frequently than the corresponding data\ncollection rate, an individual request can include data from one collection period mixed in with data from a subsequent collection period initiated by a different MONITOR user because\ncommon global data is shared.\nHowever, the impact need not be detrimental. The data collected from one request when compared to the next request may not show a change in resource usage. Follow the simple\nrule that the PM/API client application must request data at the same rate, or a less frequent rate, than the rate at which the database collects that data.\nThe monitoring rate is a PM/API collection rate that sets the interval in seconds at which resource usage data is collected within memory.\nA physical monitoring rate is the same as a virtual monitoring rate.\nThere are signiﬁcant differences in the way resource usage and session usage data are collected and reported by the MONITOR partition. For details, see Data Collection and\nCollection and Logging Rates.\nSession-Level Data\nSession-level data is collected cumulatively. The collection period is used to limit the frequency of this update.\nFor example, if you set the SET SESSION RATE to 120 seconds and issue a MONITOR SESSION request every 120 seconds, session usage data is collected and cumulatively totaled\nevery 120 seconds.\nSession-level data is lost in the event of a system outage.\nData reported includes data for the beginning 120 seconds and for subsequent intervals.\nFor more information on how session usage data is collected, see System-Level Monitoring.\nLake - Monitor Resources and Performance\nPage 109 of 420Resource Usage Data\nResource usage data is collected based on activity during a collection period and does not reﬂect cumulative data for a sequence of collection periods. For example, if you set the SET\nRESOURCE RATE to 120 seconds and issue a MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request, resource usage data is collected at 120-second\nintervals.\nIf you do not examine the data within 120 seconds or enable resource usage tables for logging, the data is lost when overwritten by data collected during the next 120-second\ncollection interval.\nFeatures of Using Resource Usage Data\nResource usage data features are:\nAccess is using SQL, not C or another programming language\nMore detailed\nWritten to tables so past data values are available\nCan be accumulated over a long period of time and can be used for the following:\nExamining trends and patterns\nPlanning system upgrades\nDeciding when to add new applications to heavily used systems\nBuilding baseline resource usage proﬁles for operations\nLogging Resource Usage Data\nYou can retain collected data for subsequent historical analysis by enabling one or more resource usage tables for logging. The table and type of PM/API request follow.\nPM/API Request Table\nMONITOR PHYSICAL RESOURCE\nMONITOR PHYSICAL SUMMARYResUsageSpma\nMONITOR PHYSICAL RESOURCE\nMONITOR VIRTUAL RESOURCEResUsageShst\nMONITOR VIRTUAL RESOURCE\nMONITOR VIRTUAL SUMMARYResUsageSldv (Storage Devices)\nEVENT STATUS\nMONITOR WDResUsageSps\nMONITOR VIRTUAL RESOURCE\nMONITOR VIRTUAL SUMMARYResUsageSvpr\nMONITOR VIRTUAL RESOURCE ResUsageSvdsk\nCollection and Logging Rates\nYou can control the rate at which resources are monitored (collected) and, if you enable resource logging, the interval at which a data row is to be inserted into the log table.\nSetting Collection Rates\nThe following collection rates can be set:\nGlobal session monitoring\nLocal session monitoring\nResource monitoring\nFor more information on these types of rates, see Data Collection.\nSetting Logging Rates\nYou can enable logging of collected data into the resource usage tables. You also set a logging rate that speciﬁes how often a data row is to be inserted.\nLogging is optional to collect and retrieve current data, but logging does prevent data from being lost at the next collection interval.\nIf you decide to enable logging, set the resource logging rate. The resource logging rate, also called the physical or virtual resource logging rate, sets the interval in seconds at which\nresource usage data is written to the resource usage tables (see Data Collection).\nThe resource logging rate:\nLake - Monitor Resources and Performance\nPage 110 of 420Can be set within the range of 0 and 3600 seconds.\nWith a value of zero indicates that logging is not being performed.\nReturns the value ResLogging in the MONITOR PHYSICAL SUMMARY and MONITOR VIRTUAL SUMMARY requests.\nIs saved to disk when altered (see SET RESOURCE RATE).\nA physical resource logging rate is the same as a virtual resource logging rate.\nWorkload Management API Features and Examples\nThe following describes the functionality and features of the workload management API, which consists of interfaces to System PMPC, Teradata Dynamic Workload Management,\nQuery Band, and embedded services system.\nSystem PMPC API Features\nTeradata Dynamic Workload Management API Features\nQuery Band API Features\nEmbedded Services System API Features\nSystem PMPC API Features\nTypes of T asks\nThe following types of tasks are tracked in Resource Usage tables:\nData Collection\nSystem-Level Monitoring\nSession-Level Monitoring\nMonitor Locks\nData Collection\nSystem PMPC requests, except MONITOR VERSION and MONITOR SQL, are based on periodic data collection. The Resource Sampling Subsystem (RSS) rates at which the resource\ndata is gathered (collection rate) and written to the resource usage tables (logging rate) are set separately.\nYou can control the session collection rate, the resource collection rate, and the resource logging rate. You can set the resource collection rate for any interval between 0 and 3600\nseconds. You can set the session collection rate for any interval between 1 and 3600 seconds.\nA master resource collection system within the database collects performance monitoring data, which can be accessed in multiple ways, such as using PM/API requests or SQL\ninterfaces.\nYou cannot set the session rate to zero in SET SESSION RATE PM/API or SetSessionRate Open API, but you can set the session rate to zero in the Supervisor Window.\nIntegrate performance monitoring tasks on your system to avoid potential conﬂicts.\nBecause resource usage data is collected in different memory repositories than session-level data, changes in the resource collection rate have no impact on session-level usage data,\nand the reverse.\nThe following table describes the types of monitoring rates that are set using the following APIs:\nThe SET RESOURCE RATE and SET SESSION RATE requests.\nThe SetResourceRate and SetSessionRate functions.\nRate Description\nGlobal session (SesMonitorSys) monitoring Sets the maximum acceptable age of collected session-level data in memory to the PM/API application or end user.\nThis rate is returned as SesMonitorSys value in a MONITOR VIRTUAL SUMMARY request.\nThe global session rate impacts all MONITOR SESSION requests unless local session rate is set.\nLocal session (SesMonitorLoc) monitoring Sets the maximum acceptable age of collected session-level data in memory for an individual Monitor partition session that submits a\nMONITOR SESSION request.\nThis rate is returned as SesMonitorLoc value in a MONITOR VIRTUAL SUMMARY request.\nBy default, the local session rate is the same as the global session rate.\nA change to the local collection rate may affect the cumulative data that other users see because all session usage data is stored in\nthe same memory repository.\nBecause changes to the global or local rate can reset the starting point at which data is collected and may alter cumulative session\nusage data, restrict the granting of session monitoring privilege to users trained in the use of system monitoring tools. For example,\nthe system or database administrator or certain application programmers.\nThis rate is not saved on disk and is lost during a system outage.\nResource monitoring (ResMonitor) Sets the interval in seconds at which all resource usage data is collected within memory for reporting using the PM/API.\nThe resource monitoring rate is returned as a ResMonitor data value in a MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL\nSUMMARY request.\nLake - Monitor Resources and Performance\nPage 111 of 420Rate Description\nYou can use the SampleSec ﬁeld of MONITOR PHYSICAL RESOURCE to view the current rate. This ﬁeld is equivalent to the\nResMonitor ﬁeld.\nResource logging (ResLogging) Sets the interval in seconds at which resource usage data is written to the resource usage tables.\nThe resource logging rate is returned as a ResLogging data value in a MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL\nSUMMARY request.\nData collection rates must be set to a nonzero value for all data ﬁelds called by a PM/API request or SQL interface or the ﬁelds contain no data.\nAll rates but the local session monitoring rate are saved on disk when altered, and are therefore \"remembered\" during restarts.\nRelated Information\nTopic Reference\nInformation on global and local rates\nSET SESSION RATE.\nMONITOR VIRTUAL SUMMARY.\nInformation on resource monitoring and logging rates\nSET RESOURCE RATE.\nMONITOR PHYSICAL SUMMARY.\nMONITOR VIRTUAL SUMMARY.\nSystem-Level Monitoring\nUse System PMPC to perform two types of system monitoring:\nPhysical resources\nNodes availability\nBYNET availability\nVirtual resources (vprocs)\nAccess Module Processor (AMP) status, performance, and usage\nParsing Engine (PE) status, performance, and usage\nResource usage data is collected and reported differently from session usage data. Whereas session usage data can be collected cumulatively, resource data is collected for a\ncollection period. The resource data reported is based on the activity that occurred during that collection period and does not include any cumulative data over collection periods. For\nexample, if you set the resource usage collection interval to 60 seconds and issue a MONITOR VIRTUAL RESOURCE request (or a MonitorVirtualResource function) or MONITOR\nPHYSICAL RESOURCE request (or MonitorPhysicalResource function), a report is issued for that speciﬁc 60-second interval.\nData you do not examine within the 60 seconds is lost when overwritten by data collected during the next 60-second collection interval.\nResource usage data and session-level usage data are deposited in separate global data collection areas. The data in the repository is updated once each collection period. All users\nshare the data, which is used to generate responses.\nSession-Level Monitoring\nSession-level monitoring tasks return the following information:\nIdentiﬁcation of blocking users, sessions and locked databases or tables\nSession-level usage data on:\nAMPs\nCPUs\nIdentiﬁcation of problem SQL requests, including:\nCurrent session\nCurrent step\nSQL text EXPLAIN data\nThere is session-level usage data that is collected cumulatively. The session rate is used to limit the frequency at which cumulative data is updated. For example, if you set the session\nrate to 60 seconds and issue a MONITOR SESSION request every 60 seconds, session-level usage data and request-level usage data is cumulatively totaled and updated every 60\nseconds. Cumulative type session-level or request-level data reported includes data from the beginning of the session or request.\nMonitor Locks\nLocks may occur when sessions, utilities, and applications being run by speciﬁc users block access to databases or tables typically available from the database. Interfaces to System\nPMPC can help you monitor locks.\nTo help determine the user causing a block and the locked database or table, you can use the MONITOR SESSION request or the MonitorSession function. Then, to get more speciﬁc\ninformation about the blocking session and the object being blocked, you can use the IDENTIFY request or IdentifySession, IdentifyUser or IdentifyTable functions.\nTo learn more about the interfaces used to perform these functions, see System PMPC APIs.\nLake - Monitor Resources and Performance\nPage 112 of 420Examples: Job Control Support Applications Using PM/APIs\nThis section explains two advanced examples of potential job control support applications that use PM/API requests:\nResource Supervisor\nIdle Session Logoff\nThe examples are explained at a high level so that, by understanding the concepts, you can develop similar applications at a customer site for monitoring and controlling the use of\ndatabase resources.\nResource Supervisor\nA Resource Supervisor prevents runaway queries. Runaway queries can be a problem at a site where end users can access the database to make ad hoc Teradata SQL requests. A\nbadly formulated query (for example, one missing constraint on a WHERE clause) may cause a product join, which consumes more resources than the user intended. Further, a user\nmaking an ill-formed SQL statement may request a join on two big tables, which unintentionally causes a Cartesian product join. The Resource Supervisor aborts transactions that\nexceed a certain resource usage threshold.\nYou can write a Resource Supervisor to use features available in the request, as shown in the following example.\n1. Program the SET SESSION RATE request to set a reasonable session-level collection rate, for example, 10 minutes.\n2. Based on the session-level rate, program the client application to issue a MONITOR SESSION request for all sessions or for a subset of sessions (for example, if users from a\nspeciﬁc client are the only ones to be governed).\n3. For each session returned to the client, program the client application to check site-speciﬁc criteria to see if the session is a candidate for the Resource Supervisor.\nFor example, interactive users are required to have INTERACTIVE as the ﬁrst word of their account string. If only interactive users are to be monitored by the Resource\nSupervisor, all sessions that do not include INTERACTIVE as the ﬁrst word of the UserAccount value returned by a MONITOR SESSION request are ignored.\n4. For sessions that are candidates for the Resource Supervisor, program the client application to look at the AMPCPUSec, PECPUSec, and AMPIO values to determine if a site-\nspeciﬁc maximum acceptable value has been exceeded.\nThese session values are cumulative and may not be appropriate for use as a Governor limit because you are limiting the total resource usage of a session and not of a request.\n5. Program the client application to keep a history of all previous cumulative values of AMPCPUSec, PECPUSec, and AMPIO, plus current XactCount (transaction count) and\nReqCount (request count) values for each session.\nThe difference between the historical value and the current value tells you the resources used. The request count and transaction count values tell you if the resources are\nconsumed as part of the current transaction or as part of the new request.\n6. If the Resource Supervisor determines that a session has exceeded site-speciﬁc limits, program the client application to issue an ABORT SESSION request for those session\nthat have exceeded the limits.\nThe client application can specify the logoff option for the ABORT SESSION request, depending on how severely the offending session is controlled.\nIdle Session Logoff\nAn Idle Session Logoff application automatically logs off users whose sessions have been idle for a certain length of time. This job control support feature prevents users from walking\naway from a terminal and allowing unauthorized users access to sensitive information.\nYou can write an Idle Session Logoff application program using the following requests.\n1. Program the SET SESSION RATE request to set a reasonable session-level collection rate, for example, 10 minutes.\n2. Based on the session-level rate, program the client application to issue a MONITOR SESSION request for all sessions or for a subset of sessions (for example, if users from a\nspeciﬁc client are the only ones to be monitored for idle sessions).\n3. For each session returned to the client, check site-speciﬁc criteria to see if the session is a candidate for Idle Session Logoff.\nFor example, interactive users are required to have INTERACTIVE as the ﬁrst word of their account string. If only interactive users are to be monitored by the Resource\nSupervisor, all sessions that did not have INTERACTIVE as the ﬁrst word of the UserAccount value returned by a MONITOR SESSION request are ignored. Those sessions with\nthe INTERACTIVE label proceed through the next step.\n4. For sessions that are candidates for Idle Session Logoff, program the client application to verify the following conditions to determine whether the session has been inactive for\nthe duration of the collection period:\nAMPState and PEState are idle.\nThe session was idle during the last MONITOR SESSION request.\nXactCount and ReqCount values did not change during the last MONITOR SESSION request.\nIf all these conditions are met, the session has been inactive for the duration of the collection interval and is a candidate for automatic logoff.\n5. Program the client application to issue an ABORT SESSION request with the logoff option for the sessions that are candidates for automatic logoff.\nExamples: Using Open APIs\nThe following table describes the different uses of the System PMPC open APIs.\nLake - Monitor Resources and Performance\nPage 113 of 420Functions Usage\nMonitorSession\nAbortSessionsCreate a query that aborts queries submitted by a set of users that have been running\nlonger than 10 minutes and have been skewed by more than 30% for 20 minutes.\nMonitorSession\nSetSessionAccountChange the account string.\nMonitorSession\nMonitorSQLTextDisplay the SQL of all active sessions that have run over 20 minutes.\nSelect the blocked ﬁelds of the MonitorSession function to display the block information of all blocked sessions.\nFunctionality\nThe following table describes the System PMPC interfaces used to show how efﬁciently the database uses its resources, to identify problem sessions and users, and to stop sessions\nand users having a negative impact on system performance.\nGoal SQL Interface to Use CLIv2 or T eradata JDBC Driver Request to Use\nAbort outstanding requests or transactions of one or\nmore sessionsAbortSessions\nor\nAbortListSessionsABORT SESSION\nReturn the name of a user, by session, who is\ncausing a blockIdentifySession IDENTIFY\nReturn the name of the speciﬁed table ID IdentifyTable IDENTIFY\nReturn the name of the speciﬁed user ID who is\ncausing a blockIdentifyUser IDENTIFY\nCollect statistics on AMPs based on the in-use AMP\nWorker Tasks (AWTs)MonitorAMPLoad or MonitorAWTResource MONITOR AWT RESOURCE\nCollect session information for the current user on\nthe current hostMonitorMySessions —\nCollect overall information on node availability MonitorPhysicalConﬁg MONITOR PHYSICAL CONFIG\nCollect RSS data and returns node-speciﬁc data MonitorPhysicalResource MONITOR PHYSICAL RESOURCE\nCollect global summary information MonitorPhysicalSummary MONITOR PHYSICAL SUMMARY\nReturn session or request resource usage statisticsMonitorSession MONITOR SESSION\nReturn session rate MonitorSessionRate MONITOR SESSION\nReturn data about the step being run of the running\nrequestMonitorSQLCurrentStep MONITOR SQL\nReturn the step information of the current or running\nrequestMonitorSQLSteps MONITOR SQL\nReturn the SQL text of the request being run for the\nspeciﬁed host, session, and vprocMonitorSQLText MONITOR SQL\nReturn BYNET status and system type values that\nare generated once for the entire system or collect\noverall information on node availabilityMonitorSystemPhysicalConﬁg MONITOR PHYSICAL CONFIG\nCollect information on virtual processor (vproc)\navailabilityMonitorVirtualConﬁg MONITOR VIRTUAL CONFIG\nCollect performance information for each AMP, PE,\nor TVS vprocMonitorVirtualResource MONITOR VIRTUAL RESOURCE\nCollect global summary information on system\nusageMonitorVirtualSummary MONITOR VIRTUAL SUMMARY\nReturn ResUsageSps data from the RSS SPS\nmemory bufferMonitorWD MONITOR WD\nReturn a subset of the RSS ResUsageSps data or\nreturn the collection rate, number of nodes with at\nleast one online AMP, and number of nodes with at\nleast one online PEMonitorWDRate MONITOR WD\nLake - Monitor Resources and Performance\nPage 114 of 420Goal SQL Interface to Use CLIv2 or T eradata JDBC Driver Request to Use\nSet ResMonitor or ResLogging rate SetResourceRate SET RESOURCE RATE\nChange the account string for the session or for the\nrequest.SetSessionAccount SET SESSION ACCOUNT\nSet the global and local rates for updating session-\nlevel statistics in memorySetSessionRate SET SESSION RATE\nTeradata Dynamic Workload Management API Features\nTeradata dynamic workload management software, a key component of Teradata Active System Management (TASM), is a rule-oriented management system capable of detecting and\nacting on events.\nTeradata ASM is not fully supported on Teradata appliances. For more information, see appropriate appliance documents for further details.\nTeradata Dynamic Workload Management APIs allow database administrators to:\nMonitor delayed requests\nRelease or stop requests from the delay queue\nDisplay the workload deﬁnition of a query\nDetermine the current status of TASM rules and rule sets\nReview statistics on how TASM rule categories are affecting request processing\nRetrieve information about the current status of all event-related constructs\nEnable or disable user-deﬁned events for event management\nFor examples on performing these Teradata Dynamic Workload Management functions, see the following examples.\nExamples Using Open APIs\nThe following table describes the different uses of the Teradata Dynamic Workload Management open APIs.\nFunctions Usage\nMonitorSession\nTDWMAssignWDChange the workload to WD-Report-High of all active requests with a workload of WD-\nReport-Low.\nTDWMEventControl Change the active health condition or planned environment on the system to adjust the\nthrottles.\nTDWMEventStatus Display all active events.\nTDWMGetDelayedQueries\nTDWMReleaseDelayedRequestRelease all delayed queries for a speciﬁed workload.\nTDWMRuleControl function Temporarily enable a rule to block an application for accessing a database while it is\nsynchronized between two active systems.\nTDWMSummary function Display the current workload summary statistics.\nTDWMThrottleStatistics function Display the current delay queue statistics.\nFunctionality\nThe following table describes the interfaces of the Teradata Dynamic Workload Management that are used to return WDs, delayed query lists, summary data, and statistics; and\nupdate the components stored in the Teradata Dynamic Workload Management database.\nThe updates in the TDWMRuleControl and TDWMSetLimits procedures must be committed before the TDWMApply procedure can be called. If the same transaction is used to call the\nexternal stored procedures that update the TDWM database and the TDWMApply external stored procedure, a self-deadlock occurs, as in the following example.\nBt;\nCall TDWMRuleControl() \nThe updates are not committed because the TDWMRuleControl procedure is in a transaction (that is, the rows are locked for write).\nCall TDWMApply(200, 'Y','N','N','N');\nThe TDWM database waits on the locked tables.\nGoal SQL Interface to Use CLIv2 or T eradata JDBC Driver Request to Use\nAbort a request or utility session on the Teradata\ndynamic workload management software delay queueTDWMAbortDelayedRequest TDWM DELAY REQUEST CHANGE\nApply changes to the rules in one or more the Teradata\ndynamic workload management software categoriesTDWMApply —\nLake - Monitor Resources and Performance\nPage 115 of 420Goal SQL Interface to Use CLIv2 or T eradata JDBC Driver Request to Use\nChange the workload a session or request is assigned toTDWMAssignWD TDWM WD ASSIGNMENT\nActivate or deactivate a user-deﬁned event TDWMEventControl USER EVENT CONTROL\nList all objects that make up the system state TDWMEventMapping EVENT STATUS\nReturn the deﬁned events TDWMEventStatus EVENT STATUS\nReturn the collection rate (that is, the ﬁrst record of the\nTeradata dynamic workload management software\nException PM/API request) or return Teradata dynamic\nworkload management software exception data from the\ndatabaseTDWMExceptionRate TDWM EXCEPTIONS\nCollect the Teradata dynamic workload management\nsoftware exception data from the databaseTDWMExceptions TDWM EXCEPTIONS\nReport if each category is active or not TDWMInquire —\nReturn the delayed query data ﬁelds and delay\ninformationTDWMGetDelayedQueries TDWM STATISTICS\nReturn the utility delay queue TDWMGetDelayedUtilities TDWM STATISTICS\nReturn a list of the WDs TDWMListWDs TDWM LIST WD\nReturn the statistics on the load utilities that are available\nin the systemTDWMLoadUtilStatistics TDWM STATISTICS\nRelease a request or utility session on the Teradata\ndynamic workload management software delay queueTDWMReleaseDelayedRequest TDWM DELAY REQUEST CHANGE\nReturn the Teradata dynamic workload management\nsoftware WD summary data ﬁeldsTDWMSummary TDWM SUMMARY\nReturn the collection rate TDWMSummaryRate TDWM SUMMARY\nReturn statistics for throttled database objects or\nthrottled workloadsTDWMThrottleStatistics TDWM STATISTICS\nQuery Band API Features\nQuery banding is a method for tracking system usage and managing task priorities. A query band is a list of name=value pairs in a string within apostrophes, deﬁned by the user or\nmiddle-tier application as follows.\n'org=Finance;report=EndOfYear;universe=west;'\nThe name-value pairs are separated by a semicolon.\nThere are three types of query bands:\nA session query band, which is stored in the session table and recovered after a system reset.\nA transaction query band, which is discarded when the transaction ends (for example, a commit, rollback, or abort).\nA proﬁle query band, which is set for the session at logon. The proﬁle query band is not saved in the session table, so after a restart, the session is initialized with the proﬁle\nquery band based on the current proﬁle setting.\nYou can set a query band for the transaction and session using the SQL statement, SET QUERY_BAND.\nYou can set a default query band in a proﬁle with the CREATE PROFILE statement and assign the proﬁle to a user with CREATE USER or MODIFY USER. See CREATE PROFILE.\nBy setting a query band, you can:\nIdentify the user, application, or report that originated the request from a middle-tiered application.\nIdentify what user, application, report, and even what part of an application issued a request (for example, a query band can be used for accounting, troubleshooting, and in\nother types of system management operations).\nGive requests a higher priority. For example, a query band can make a request issued for an interactive report a higher priority than one issued for a report that generates\noutput ﬁles.\nIncrease the priority of an urgent job. For example, if the CEO needs a report for a board review that starts in 20 minutes, a query band can be used to expedite the job.\nCreate requests that make up a “job” to be grouped for accounting and control purposes.\nA query band can be any of the following:\nLogged by Database Query Log (DBQL). DBQL reports are created using the query band name-values pairs to provide additional reﬁnement for accounting and resource\nallocation purposes and to assist in troubleshooting performance problems.\nUsed for rule checking and Workload Classiﬁcation. Query band name-value pairs can be associated with TASM Filter rules and deﬁned as workload attributes.\nUsed to determine the origin of a request that may be consuming system resources or blocking other requests.\nUsed as a system variable. A query band can be set for a session and retrieved using APIs.\nThrough these interfaces, the following information can be retrieved:\nThe concatenated transaction and session query band for the speciﬁed session.\nThe concatenated query band for the current transaction and session.\nThe name and value pairs in the query band.\nLake - Monitor Resources and Performance\nPage 116 of 420The value of the speciﬁed name in the current query band.\nFor examples on performing Query band requests and functions, see Examples Using PM/API and Open APIs.\nTo learn more about these interfaces and how to retrieve query bands, see Workload Management: Query Band APIs.\nExamples Using PM/API and Open APIs\nThe following table describes the different uses of the query band APIs.\nQuery Band API Description\nMONITOR QUERYBAND or MonitorQueryBand Returns the concatenated query band for session number 1102 on host ID 20 running\non vproc 16383.\nGetQueryBand or GetQueryBandSP Returns the concatenated query band string for the current transaction, session, and\nproﬁle.\nGetQueryBandValue Queries the DBQLogTbl based on names and values speciﬁed in the query band name\ninput argument.\nGetQueryBandValueSP Searches the session name-value pairs in the query band and return the value that\ncorresponds to the query band name “aa.”\nGetQueryBandPairs Returns the query band in name and value columns.\nFunctionality\nThe following table describes the query band interfaces that are used to track system usage and manage task priorities.\nGoal SQL Interface to Use CLIv2 or T eradata JDBC Driver Request to Use\nReturn the name and value pairs in the query band GetQueryBandPairs —\nReturn the concatenated query band for the current\ntransaction and sessionGetQueryBand\nor\nGetQueryBandSP—\nReturn the value of the speciﬁed name in the current\nquery band or NULLGetQueryBandValue\nor\nGetQueryBandValueSP—\nReturn the concatenated query band for the speciﬁed\nsessionMonitorQueryBand MONITOR QUERYBAND\nReturn all query band names and descriptions, including\nthose dropped from a releaseQueryBandReservedNames_TBF —\nEmbedded Services System API Features\nFunctionality\nEmbedded services system APIs follow the implicit data type conversion rules that apply to UDFs. See Implicit Data Type Conversion Rules.\nThe following table describes the different embedded services system interfaces.\nGoal SQL Interface to Use\nReturn the current type of Priority Scheduler being used (for example, workload\ndeﬁnitions)GetPSFVersion.\nRetrieve the maximum CPU and I/O capacity on demand (COD) values from the Priority\nSchedulerTD_get_COD_limits.\nReturn the value of the speciﬁed name in the current query band or NULL GetQueryBandValueSF.\nSystem PMPC APIs\nThe following discusses how to use the System Performance Monitor and Production Control (PMPC) APIs to monitor system and session-level performance and to identify and stop\nproblem sessions and users having a negative impact on system performance.\nPMPC data is available through two types of interfaces:\nSystem PMPC PM/APIs\nSystem PMPC Open APIs (SQL Interfaces)\nLake - Monitor Resources and Performance\nPage 117 of 420Before using the System PMPC APIs, you may want to familiarize yourself with Examples: Job Control Support Applications Using PM/APIs.\nSystem PMPC PM/APIs\nThis section describes the Teradata Dynamic Workload Management interfaces that use CLIv2 or the Teradata JDBC Driver. These interfaces are called PM/API requests.\nFor details on using the Teradata JDBC Driver requests, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nBefore using the System PMPC PM/APIs, read the following topic on the impact of object name length on PM/API requests.\nImpact of Object Name Length on PM/API Requests\nObject names contain 128 Unicode characters; however, to use object names of 128 characters, applications must use monitor software version 10 or later.\nMonitor Software V ersion Object Field in Input Area\n8 or earlier CHAR(30). A ﬁxed parcel ﬁeld size of 30 bytes. The names must be padded with spaces.\nSee previous releases of Workload Management API: PM/API and Open API.\n9 VARCHAR(120). A parcel ﬁeld size of up to 120 bytes in variable length.\nFor more information about monitor software version 9, see Application Programming\nReference: Workload Management.\n10 or later VARCHAR(512). A parcel ﬁeld size of up to 512 bytes in variable length in host character set\nformat.\nDepending on the version of your custom application, PM/API request output ﬁelds for object names may be truncated. For example, if the output ﬁeld is an object name of 100 bytes\nin length when converted to host character set format, and you are using a PM/API request with monitor software version 8 or earlier, the database name is truncated to ﬁt the ﬁxed\nparcel ﬁeld size of 30 bytes.\nCommon W arning and Error Messages\nMost of the monitor requests covered in this section depend on periodic collection of data. When this collection process is disturbed, the returned data can temporarily become\nconfusing or inaccurate.\nIf this happens, the user gets a warning message indicating that the data returned may not give a true picture of system or user activity.\nThe following are common situations in which a warning message is provided:\nThe data returned may have been affected by a system restart or a single processor recovery. Resource/session usage values may not be realistic until requests on the\ndatabase re-attain their normal level of activity.\nData may also be incomplete in cases where:\nA full data collection period has not transpired since the database has gone through a recovery.\nA full data collection period has not transpired since the related monitoring rate was changed.\nFor more detailed information on warning and error messages, see Database Messages.\nErrors Resulting from PMPC Subsystem Failures\nPMPC fault isolation provides automatic recovery from internal software errors or faults in System PMPC tasks. This signiﬁcantly reduces the cases in which the PMPC subsystem must\nbe shut down because of internal software errors or faults in PMPC modules. The PMPC subsystem continues to be available after clean up of local resources, in most cases.\nWhen an internal software error or a fault occurs in PMPC tasks, all current MONITOR partition sessions are forced off with an error and logons to the MONITOR partition are\ntemporarily disabled while the PMPC subsystem recovery is in progress. After the recovery is complete, the logons to the MONITOR partition are re-enabled. The PMPC subsystem\nrecovery is expected to take up to 3 minutes on a system with a normal workload.\nOnly the PMPC subsystem restarts on an internal software error or a fault in PMPC tasks. The requests in DBC/SQL sessions and all other type of non-PMPC requests are not impacted\nor interrupted while the PMPC subsystem recovery is in progress. Also a snapshot dump may have been taken during the recovery. The administrator must report the snapshot dump\nand any related errors in the event log to Teradata Support.\nABORT SESSION\nIDENTIFY\nMONITOR AWT RESOURCE\nMONITOR PHYSICAL CONFIG\nMONITOR PHYSICAL RESOURCE\nMONITOR PHYSICAL SUMMARY\nMONITOR SESSION\nMONITOR SQL\nMONITOR VERSION\nMONITOR VIRTUAL CONFIG\nMONITOR VIRTUAL RESOURCE\nMONITOR VIRTUAL SUMMARY\nMONITOR WD\nLake - Monitor Resources and Performance\nPage 118 of 420SET RESOURCE RATE\nSET SESSION ACCOUNT\nSET SESSION RATE\nABORT SESSION\nAborts any outstanding request or transaction of one or more sessions, and optionally logs those sessions off the database system.\nInput Data\nIf host_id, user_name, or session_no is omitted or set to NULL, ABORT SESSION tries to abort all hosts, all users, or all sessions. For example, if you specify 127 for host_id, FRR for\nuser_name, and NULL for session_no, ABORT SESSION attempts to abort every and all sessions logged on from host 127 as user FRR.\nElement Data T ype/ Range Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT Logical ID of a host (or client) with sessions logged on. For example, a hostid of zero identiﬁes internal\nsessions or system Console sessions.\nhost_id cannot exceed 1023.\nsession_no INTEGER Session number. session_no combined with the host_id represents a unique session ID.\nuser_name VARCHAR(128) Name of user who is running the sessions.\nlist VARCHAR(1) Indicator of whether to display a list of sessions.\nTo display a list of all session_no sessions, specify y or Y. If you do not want to display a list of sessions,\nspecify n, N, NULL, or blank.\nDo not use list when large numbers of sessions are being stopped. Otherwise, system degradation can\nresult, especially when the list contains more than 1500 sessions. The slowdown occurs because all\nimpacted sessions must be buffered and then sorted on a single processor. During the sort, the processor\nis unavailable for requests from any other MONITOR session logged on to that PE. The number of sessions\nto be sorted can exhaust scratch space on the processor and cause a system restart.\nIf your site is running Two-Phase Commit (2PC), the following information applies:\nDo not use ABORT SESSION to abort or log off Teradata Director Program internal sessions used for\n2PC processing. To log off the sessions, use the Teradata Director Program command DISABLE IRF\ninstead.\nBe sure to issue DISABLE IRF before running ABORT SESSION using the host_id.* or *.* parameters\nto avoid any possible problem with the Teradata Director Program.\nTo identify Teradata Director Program internal sessions, run the Teradata Director Program command\nDISPLAY SESSIONS. Teradata Director Program internal sessions have the job name *TDPINT*. (The\nMONITOR SESSION request cannot identify Teradata Director Program internal sessions.)\nlogoff VARCHAR(1) Indicator of whether to log session_no sessions off the database after aborting them.\nTo log session_no sessions off the database, specify y or Y. To end session_no sessions, specify n, N,\nNULL, or blank.\noverride VARCHAR(1) Possible values:\nY or y, if you do not want the ABORT SESSION request to fail in any of the following cases:\nAn identiﬁed session is being session-switched.\nAn identiﬁed session is running its own ABORT SESSION request.\nAn identiﬁed session has a PEState of IDLE: IN-DOUBT as a result of a 2PC.\nSessions are marked IN-DOUBT by the 2PC protocol, which governs how transactions are\ncommitted by multiple systems that do not share memory. The protocol guarantees that either\nall systems commit or all roll back.\nTherefore, when you specify y or Y, session_no sessions that ﬁt one of the preceding criteria are ignored,\nand all sessions that do not ﬁt any of the preceding criteria are aborted.\nLake - Monitor Resources and Performance\nPage 119 of 420Element Data T ype/ Range Description\nN, n, NULL, or blank\nIf at least one identiﬁed session ﬁts one of the preceding criteria, the ABORT SESSION request fails.\nIf you specify n or N, or do not specify this option, the entire ABORT SESSION operation fails if any\nnon-abortable session is encountered. If sessions are not aborted (including those in abortable\nstates), this ﬁeld returns an error message.\nPerformance and list Option\nThe ABORT SESSION request is different from other PM/API requests, because when processing begins, the ABORT SESSION operation cannot be stopped.\nThe ABORT SESSION cannot be stopped even if list displays sessions that were included by mistake.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nAborting a session is useful when a session causes a production job to block other sessions waiting for locks, or when a session uses resources that a critical application is running too\nslowly.\nBy default, the ABORT SESSION request aborts the current transaction for the speciﬁed sessions and logs those sessions off the database.\nThe ABORT SESSION request is logged to the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view). If you specify y or Y for logoff, records are added to\nDBC.SW_Event_Log table.\nABORT SESSION does not abort nor log off a session under any of the following conditions:\nThe session status is IN-DOUBT.\nThe session is being session-switched.\nThe session is a Database Query Log (DBQL) artiﬁcial internal session\nThe actual session is running an ABORT SESSION request.\nIf you try to abort a session that is running an ABORT SESSION request, either a diagnostic message displays, indicating that the ABORT SESSION request was not accepted, or, the\nABORT SESSION request aborts any identiﬁed sessions that do not meet the preceding conditions.\nThis request may end and log off other PM/API sessions, but ignores the session from which it was submitted.\nAt least one of the transactions you want to end either cannot be ended or already is being ended if:\nA session is in the ﬁnal stage of an ALTER TABLE operation and cannot be aborted.\nA user-initiated abort must complete before whatever caused the ABORT SESSION request to run can be done. Therefore, if you specify list, that list indicates sessions that are:\nIN-DOUBT\nBeing session-switched\nAlready aborting or committing their own transactions\nRunning an ABORT SESSION request\nThe ABORT SESSION request has the following impact as described in the following table.\nType of SessionImpact of ABORT\nSESSION Option Comments\nA session with a transaction that is\nbeing committed or rolled backNone with or without\nlogoffThe ABORT SESSION request does not fail. Instead, the stage 1 response from the database\nincludes a warning that identiﬁed sessions are in the process of committing or rolling back their\ntransactions.\nAn internal session None   The activity of such sessions is vital to the continued database execution and is considered to be\nmore important than any user-initiated work that may be blocked. The database system acts as if the\ninternal sessions do not appear in the optional list of sessions identiﬁed by this request.\nSpecify a host_id of zero to end Console Basic Teradata Query (BTEQ) sessions.\nA DBQL/Teradata dynamic workload\nmanagement software artiﬁcial\ninternal sessionDoes not work   This is not a real session and cannot be ended. If you try to end this session, an error message is\nreturned.\nA client utility user Little   Client utility locks are designed to survive system outages or interruptions in the archive process, and\nare not necessarily associated with an active session. Instead, these locks are associated with the\nLake - Monitor Resources and Performance\nPage 120 of 420Type of SessionImpact of ABORT\nSESSION Option Comments\nuser who originally submitted the archive or recovery operation. Therefore, an ABORT SESSION\nrequest does not necessarily remove locks placed by the client utility and does not necessarily\ncause whatever activity any such locks were blocking to become unblocked. However, such\nsessions still appear in the optional list of sessions identiﬁed by this request.\nMLOAD, FASTLOAD, or DBCUTIL\npartition sessionsDoes not work without logoff Sessions within these partitions are associated with transactions or locks. Also, these partitions may\nnot include the Teradata SQL or PM/API ability to recover from an interrupted request without\nterminating the application. That is, these partitions are designed to be restarted, but not rolled back.\nTherefore, when a FastLoad or MultiLoad operation must be terminated, the ABORT SESSION\nrequest typically speciﬁes that all sessions associated with the utility job be ended and logged off.\nThese utility-related sessions appear in the optional list of sessions identiﬁed by this request.\nEnding a FastLoad, MultiLoad, or FastExport job by user_name is easier than with session_no. These\nutilities have multiple sessions under one user_name and ending one utility session running under\nthat user_name but not another does not make sense. However, if the same user_name is running\nother sessions at the same time, those sessions are also ended and logged off.\nProcessing Messages\nUnlike other PM/API requests, ABORT SESSION has an unpredictable execution time and can take hours to roll back a transaction.\nTherefore, on receipt of an ABORT SESSION request, the database sends one or more of the following processing messages:\nIndicates that the ABORT SESSION request is received and is in one of the following states:\nIs accepted and is in execution.\nCannot be accepted because resources are exhausted, because of either a heavy workload or multiple ABORT SESSION requests are queued and waiting to ﬁnish\nprocessing. Information is recorded in the error log.\nThe database does not restart as a result of this error. Depending on the available resources, this request completes after the queued end requests have completed\nprocessing.\nLists the number of sessions affected by the running request (if Y was entered into the list ﬁeld).\nIndicates the request is complete when all identiﬁed sessions have been ended.\nIndicates that all session have been logged off (if Y was entered into the logoff ﬁeld).\nCLIv2 Response Parcels\nBecause of the unpredictable run time of ABORT SESSION, the database system handles ABORT SESSION as a two-statement request, with each statement generating a response.\nThe two-statement response contains the following sequence of parcel types.\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo =1\nActivityCount = Number of sessions identiﬁed by the ABORT SESSION request\nActivityType = 86 (PCLABTSESS)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Data or IndicData list of sessions. This parcel is present only if you speciﬁed list.\nEndStatement 11 6 StatementNo = 2-byte integer.\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = 0 (Number of sessions identiﬁed by the ABORT SESSION request)\nActivityType = 86 (PCLABTSESS)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nEndStatement 11 6 StatementNo = 2-byte integer.\nEndRequest 12 4 None.\nThe only difference between the parcels returned with the list option set to y or Y, and those returned with the list option set to n, N, blank, or NULL, is that one or more Record parcels\nare added when you specify the former.\nLake - Monitor Resources and Performance\nPage 121 of 420Response\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nIn the ﬁrst response, the database indicates that the request was accepted and is running, and lists the affected sessions and their status if you specify y or Y for list.\nStatement 1\nThe Record parcel in the ﬁrst statement of the response returns the list of sessions in increasing order of HostId. The following table shows the values returned from the ﬁrst statement.\nField/Column Name Data T ype Description\nHostId SMALLINT Logical host ID associated with a PE or session. For a PE, the Host ID identiﬁes one of the hosts or\nLANs associated with the described PE. For a session, the combination of a host ID and a session\nnumber uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nUserName VARCHAR(128)\nCHARACTER SET UNICODE\nNOT NULLUser name of the session.\nSessionNo INTEGER\nNOT NULLNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session\non the database system. This value is assigned by the host (or client) at logon time.\nAbortStatus VARCHAR(1) Information on the status of the associated session:\nI = In-Doubt\nA = Ending a transaction\nC = Committing a transaction\nE = Executing (running) an ABORT SESSION request\nS = Switching\nNULL = In a state other than the preceding\nFor an ABORT without LOGOFF, any status except NULL indicates the reason the request did not\nimpact the associated session.\nFor an ABORT with LOGOFF, an I, E, or S status value indicates that the associated session cannot\nbe ended or logged off.\nIf you do not specify logging off sessions, the Success parcel produced for the ﬁrst statement, when applicable, includes a warning that identiﬁed sessions are in the process of\ncommitting or rolling back their transactions. An ABORT with logoff completes and does not produce any warnings.\nStatement 2\nIn the second response, the database indicates that the request is complete. The completion response is sent only after all impacted sessions have been ended and, if requested,\nlogged off.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for an ABORT SESSION request, built by CLIv2, look when sent to the database server using a host_id of 52, session_no of 2521,\nuser_name of user_01, list of Y, logoff of Y, and override of N. In this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is\n32,000 bytes.\nNumber Length Body\nNum Name BytesField Value\n0001 Req 17 Request ABORT SESSION\n0003 Data 47 MonVerID 2\nHostId 348\nSessionNo 1000\nUserName user_01\nListOption Y\nLogoff Y\nOverride N\n0004 Resp 6 BufferSize 64000\nLake - Monitor Resources and Performance\nPage 122 of 420Sample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nWith a host_id of 52, session_no of 2521, user_name of DBC, list of Y, and logoff of Y, this request may return the following values in character text format. Your application program\nmay return the values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 86    FieldCount: 4\nDataInfo iparcel:\n FieldCount: 4\nRecord parcel.\n Parcel flavor:        10    Parcel body length:   38\n HostId = 52,  UserName = \"DBC\",  SessionNo = 2521,\n AbortStatus = ' '.\nEndStatement.\nSuccess parcel:\n StatementNo: 2    ActivityCount: 0\n ActivityType: 86    FieldCount: 0\nDataInfo parcel:\n FieldCount: 0\nEndStatement.\nEndRequest.\nRelationship between ABORT SESSION and MONIT OR SESSION\nWhen sessions are being ended or sessions are being blocked by the sessions being ended, data returned from subsequent MONITOR SESSION queries may be affected. After the\nend operation starts, you can immediately notice the changes from ending sessions. However, you do not notice the changes resulting from sessions that were blocked by ending\nsessions in MONITOR SESSION responses until the end operation is complete.\nEnded Sessions\nFor ended sessions, expect the following types of changes in the response returned from a subsequent MONITOR SESSION query:\nPEState changes to PARSING. AMPState changes to ABORTING.\nAMPCPUSec is updated due to its continued tracking of the CPU time used during the transaction rollback process. Resources consumed during a transaction rollback are\ncharged to the user the same way as any other form of resource usage.\nAMPIO is updated due to its tracking of logical I/O necessary during the transaction rollback process.\nRequest_AMPSpool decreases if there are spool ﬁles in use by the ended request, because those spool ﬁles are discarded.\nAfter the end operation has completed and if the ended sessions are not logged off, the sessions become IDLE (PEState) while waiting for subsequent requests.\nEnded sessions that are logged off are no longer tracked by subsequent MONITOR SESSION requests.\nBlocked Sessions\nFor sessions blocked or slowed down by ended sessions, expect the following types of changes in the response returned from a subsequent MONITOR SESSION query:\nThe following response ﬁelds related to the ended sessions are removed (that is, reported as NULLS because the blocking session is gone):\nBlk_x_H ostId\nBlk_x_S essNo\nBlk_x_U serID\nBlk_x_L Mode\nBlk_x_OT ype\nBlk_x_Ob jDBId\nBlk_x_Ob jTId\nBlk_x_S tatus\nFor example, the following describes the information that can be inferred from the returned data:\nWithin a MONITOR SESSION, response ﬁelds show Session 1 blocked by Sessions 2 and 3.\nAfter an ABORT SESSION, Session 2 is removed.\nWithin a subsequent MONITOR SESSION, response ﬁelds show Session 1 blocked by Session 3.\nThe MoreBlockers ﬁeld may return data indicating there are no additional lock conﬂicts.\nBecause removing an ended session allows another blocking session to be reported, there may be no remaining locks to report.\nIf the ended sessions are no longer blocking other sessions, the AMPState of those other sessions changes from BLOCKED to ACTIVE.\nFor sessions that have changed to ACTIVE, or that are only slowed down by the ended sessions, all resource usage ﬁelds may show a more rapid increase in resource usage.\nFor example, the AMPCPUSec, AMPIO, and Request_AMPSpool ﬁelds may change more rapidly due to reduction in competition for those resources.\nLake - Monitor Resources and Performance\nPage 123 of 420Before You Run ABORT SESSION Request\nRun the MONITOR SESSION before you run the ABORT SESSION request to get a list of current sessions. Therefore, you can evaluate which sessions to end. You can use the host ID,\nsession number, and user name returned by the MONITOR SESSION request as input data to an ABORT SESSION request.\nMONITOR SESSION returns values that can help you determine which session is not actively processing or has a long-running transaction. For example, look at PEState for the session\nin question. If PEState is not PARSING-WAIT, PARSING, DISPATCHING, BLOCKED, or ACTIVE, that session may be a good candidate for an end. As another example, look at the ratio\nof AMPCPUSec to XactCount to determine which transaction is running for a long time. If this ratio is high, this session has a long-running transaction.\nRelationship between ABORT SESSION and MONIT OR PHYSICAL  RESOURCE or MONIT OR VIRTUAL  RESOURCE\nIf you ran an ABORT SESSION request, data returned in a MONITOR PHYSICAL RESOURCE or MONITOR VIRTUAL RESOURCE request may be altered. Whether you notice the\nchange in data depends on the scope of the ABORT SESSION request. For example, if you run an ABORT SESSION and log off the sessions associated with a speciﬁc host (or client),\nthe PEs associated with that client report a large decrease in resource consumption. However, if the ABORT SESSION request only ends one transaction from one session, you may not\nnotice a change in AMP or PE resource use.\nIDENTIFY\nReturns information on the locks blocking a session:\nName of the user associated with a session\nUser name of an object\nDatabase name of an object\nName of a table\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT Logical ID of a host (or client). host_id cannot exceed 1023. A host_id of zero identiﬁes the system Console ID of\nthe host. A combination of host_id and session_no identiﬁes a user causing a block.\nsession_no INTEGER Session number. A combination of host_id and session_no identiﬁes a user causing a block.\nTo identify the user involved in a lock conﬂict, include the Blk_x_H ostId and Blk_x_S essNo  returned in a MONITOR\nSESSION response as input in the USING Data String for the IDENTIFY SESSION request.\ndatabase_id INTEGER ID of the database for this session.\nTo identify the database name of the object involved in a block, include the Blk_x_Obj DBId returned in a MONITOR\nSESSION response as input in the USING Data String for the IDENTIFY DATABASE request.\nuser_id INTEGER ID of the user for this session.\nTo identify the user involved in a lock conﬂict, include the Blk_x_U serID ﬁeld returned in a MONITOR SESSION\nresponse as input in the USING Data String for the IDENTIFY USER request.\ntable_id INTEGER Unique ID of a table.\nTo identify the table name of the object involved in a block, include the Blk_x_Ob jTId returned in a MONITOR\nSESSION response as input in the USING Data String for the IDENTIFY TABLE request.\nThe database name and user name are assigned an associated identiﬁer when created. The IDENTIFY DATABASE\nor IDENTIFY USER request processes database and user names in the same manner.\nBecause the Blk_x_H ostId, Blk_x_S essNo, and Blk_x_U serID ﬁelds returned by a MONITOR SESSION request may either be NULL or identify an internal session, the data returned by\na MONITOR SESSION request that you use as input for the IDENTIFY request can cause error responses from IDENTIFY. If you use an internal session identiﬁer as input to the\nIDENTIFY SESSION request, the request returns an error message. The same error message is returned if you submit the IDENTIFY SESSION request for the DBQL/Teradata dynamic\nworkload management software artiﬁcial internal session.\nIf you use an NULL UserID as input to the IDENTIFY DATABASE or IDENTIFY USER request, the system returns an error message.\nMonitor Privileges\nLake - Monitor Resources and Performance\nPage 124 of 420To use this request, you must have the MONSESSION privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - IDENTIFY\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nThe following table describes the different IDENTIFY options.\nOption Description\nIDENTIFY DATABASE Identify a locked database.\nIDENTIFY SESSION Identify a user (by session) who is causing a block. You can use IDENTIFY SESSION with a combination of host_id and\nsession_no, or you can use IDENTIFY USER.\nIDENTIFY TABLE Identify a locked table.\nIDENTIFY USER Identify a user who is causing a block. You can use IDENTIFY SESSION, or you can use IDENTIFY USER user_id.\nThe following table lists the system table for each option. You can use Data Dictionary views to examine the information in each system table (see Data Dictionary Views).\nSystem T able Name IDENTIFY  Option\nDBC.SessionTbl IDENTIFY SESSION\nDBC.DBase IDENTIFY DATABASE\nIDENTIFY USER\nDBC.TVM IDENTIFY TABLE\nCLIv2 Response Parcels\nRegardless of the form of the IDENTIFY request you run, the response contains the following sequence of parcel types.\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = 1\nActivityType = 85 (PCLIDENTIFY)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. This record\ncontains the user name with the speciﬁed user ID or database ID, user name logged on as\nthe speciﬁed session, or table name with the speciﬁed table ID.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nThe following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each of the ﬁelds correspond to a ResultSet column returned by the Teradata JDBC\nDriver. See Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe Record returns the following ﬁeld/column:\nField/Column Name Data T ype Description\nName VARCHAR(128)\nCHARACTER SET UNICODE\nNOT NULLName of the object (for example, database, user, or table) whose identiﬁer was supplied by the\nIDENTIFY request.\nSample Input - CLIv2 Request\nThe following example shows how the Request parcels for an IDENTIFY SESSION request, built by CLIv2, appear when sent to the database server using a host_id of 348 and a\nsession_no of 1000.\nLake - Monitor Resources and Performance\nPage 125 of 420In this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 20 Request IDENTIFY SESSION\n0003 Data 12 MonVerID 2\nHostId 348\nSessionNo 1000\n0004 Resp 6 BufferSize 64000\nThe following example shows how the Request parcels for an IDENTIFY USER request, built by CLIv2, look when sent to the database server using a user_id of 725.\nIn this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 21 Request IDENTIFY DATABASE or IDENTIFY USER\n0003 Data 10 MonVerID 2\nUserID 725\n0004 Resp 6 BufferSize 64000\nThe next example shows how the Request parcels for an IDENTIFY TABLE request, built by CLIv2, look when sent to the database server using a table_id of 183351.\nIn this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name BytesField Value\n0001 Req 18 Request IDENTIFY TABLE\n0003 Data 10 MonVerID 2\nTableId 183351\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nWith a host_id of 52 and a session_no of 31467, the IDENTIFY SESSION request may return the following values. These example values are returned in text character format. Your\napplication program may return the values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 85    FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nRecord parcel.\n Parcel flavor:        10    Parcel body length:   31\n Name = \"DBC                           \".\nEndStatement.\nEndRequest.\nWith a database_id of 1012, the IDENTIFY DATABASE request may return the following values. These example values are returned in text character format. Your application program\nmay return the values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 85    FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nRecord parcel.\n Parcel flavor:        10    Parcel body length:   31\n Name = \"weekly                        \".\nEndStatement.\nEndRequest.\nLake - Monitor Resources and Performance\nPage 126 of 420With a user_id of 1012, the IDENTIFY USER request may return the following values. These example values are returned in text character format. Your application program may return\nthe values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 85    FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nRecord parcel.\n Parcel flavor:        10    Parcel body length:   31\n Name = \"weekly                        \".\nEndStatement.\nEndRequest.\nWith a table_id of 63, the IDENTIFY TABLE request may return the following values. These example values are returned in text character format. Your application program may return\nthe values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 85    FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nRecord parcel.\n Parcel flavor:        10    Parcel body length:   31\n Name = \"EventLog                      \".\nEndStatement.\nEndRequest.\nRelationship between IDENTIFY  and MONIT OR SESSION\nPM/API can report on locks placed by any user or object with the MONITOR SESSION and IDENTIFY requests. The MONITOR SESSION request helps you identify the types of locks\nblocking a session.\nThe MONITOR SESSION request:\nMonitors the executing processes and reports blocks preventing sessions from doing useful work, for both application or utility locks causing the block.\nTells you not only which session is blocked and on what type of object but also who is holding the lock. You can trace a blocked session back to the object locked and display\nthe owner of the lock, if your job has stopped responding or is running slowly and you suspect a lock conﬂict.\nOn a query, reports the lock conﬂicts per session with the MoreBlocks ﬁeld to indicate if there are more lock conﬂicts involved but not reported. The types of lock information\nreturned for each session include:\nUser ID or user of host utility job causing a block\nType of object (for example, database, table, or row hash) causing a lock\nMode or severity of lock\nDatabase identiﬁer of object being locked\nTable identiﬁer of object being locked\nBy looking at the logical host ID of a session causing the block in combination with the session number of the session causing a block, you can uniquely identify the session that is\ncausing a block.\nAlthough you have the preceding lock information, you must use the IDENTIFY request to further identify the locks as either a user name, database name, or table name. Use the\nBlk_ data values (or ﬁelds) returned in the MONITOR SESSION operation as input for an IDENTIFY request.\nTeradata recommends using MONITOR SESSION, with IDENTIFY as a diagnostic tool.\nExample: W rite Lock Blocking Session\nThe following example output shows that SessionNo 1001 is blocked by SessionNo 1000 by a WRITE lock that is granted on a table object type. Records are sorted in HostId and then\nSessionNo order.\nFirst Record:\nHostId = 719\n     .\n     .\nSessionNo = 1000\n     .\n     .\n     .\nSecond Record:\nHostId = 719\n     .\n     .\nSessionNo = 1001\nLake - Monitor Resources and Performance\nPage 127 of 420     .\n     .\nBlk-1-HostId = 719\nBlk-1-SessNo = 1000\nBlk-1-UserID = 10\nBlk-1-LMode = 'W'\nBlk-1-OType = 'T'\nBlk-1-ObjDBId = 12\nBlk-1-ObjTId = 1097\nBlk-1-Status = 'G'\nBlk-2-HostId = NULL\n     .\n     .\n     .\nWhen the Blk_2_ HostId, Blk_2_SessNo, and Blk_2_UserID values are returned as NULLs, this typically means that the blocking job is a HUT job that has logged off without releasing\nits lock.\nBecause the data returned here does not tell you which user is causing the block or which table is locked, you must next use the IDENTIFY request with the output from your MONITOR\nSESSION to return that information.\nTo identify the user causing the lock, run the IDENTIFY request with:\nHostId = 719\nSessionNo = 1000\nOr:\nUserID = 10\nTo identify a locked database, run the IDENTIFY request with:\nObjDBId = 12\nTo identify a locked table, run the IDENTIFY request with:\nObjTId = 1097\nMONIT OR AWT RESOURCE\nCollects statistics on AMPs based on the in-use AMP Worker Tasks (AWTs).\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nThreshold 1 SMALLINT\nNOT NULLMinimum value for in-use AWTs to qualify an AMP for inclusion into this interval.\nThreshold 2 SMALLINT Start value for in-use AWTs to qualify an AMP for inclusion into this interval.\nThreshold 3 SMALLINT Start value for in-use AWTs to qualify an AMP for inclusion into this interval.\nThreshold 4 SMALLINT Start value for in-use AWTs to qualify an AMP for inclusion into this interval.\nSummary SMALLINT\nNOT NULL0 = Return no record parcels in statement 2.\n1 = Return the record parcels in statement 2, which are the data ﬁelds returned in Groups I through V only.\nDetail SMALLINT\nNOT NULL0 = Return no detail information.\n1 = Return AMP worker task usage information by each AMP.\nIf Detail is enabled, a third statement is returned containing AMP worker task usage information by each AMP.\nIf Detail is not enabled, a statement is returned with no record parcels. For information on the record parcels\nLake - Monitor Resources and Performance\nPage 128 of 420Element Data T ype Description\nreturned, see Statement 3 - MONITOR AWT RESOURCE.\nYou can deﬁne up to four thresholds for categorizing AMPs.\nMonitor Privileges\nTo use this request, you must have the MONRESOURCE privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR AWT RESOURCE\nThis interface provides a snapshot of AMP usage based on the number of AWTs in use within the MSGWORKNEW and MSGWORKONE message work types. These two message work\ntypes are a barometer for AMP activity/health. The MONITOR AWT RESOURCE request allows the speciﬁcation of four thresholds which are used to categorize AMPs. AMPs are\ncounted into categories deﬁned by these thresholds and based on the AWT usage of the AMP.\nThis request also indicates the number of AMPs in a form of Flow Control. Flow Control can be deﬁned at a node level and, therefore, may not have a system-wide consistent deﬁnition.\nThis indication is applicable only to those messages to which Flow Control is applicable.\nMONITOR AWT RESOURCE provides information on the AMPs having the highest and lowest in-use counts within the system. When duplicate in-use counts exist, the AMP information\nreturned is for the AMPs with the largest VProc ID.\nThresholds must be deﬁned in ascending order and cannot contain gaps. If a gap is detected, an error message is returned.\nThresholds that are not used must be set to -1 (or NOT NULL). The minimum valid threshold value is zero.\nCLIv2 Response Parcels\nThe MONITOR AWT RESOURCE request is treated internally as a one statement request that generates two responses. The statement response returned from the database contains\nthe following sequence of parcel types.\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments and Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 175 (PCLMONAWTRESSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100\n(indicator mode)Depending on the request (Data or IndicData) data is returned in record or indicator mode. This\nrecord contains information in StatementNo-1. For an example of this record, see Statement 1.\nEndStatement 11 6 StatementNo = 2-byte integer=1\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = 1\nActivityType = 175 (PCLMONAWTRESSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record\nmode)\n6 to 64100\n(indicator mode)Depending on the request (Data or IndicData) data is returned in record or indicator mode. This\nrecord contains information in StatementNo-2. For an example of this record, see Statement 2.\nEndStatement 11 6 StatementNo = 2-byte integer=1\nEndRequest 12 4 None\nLake - Monitor Resources and Performance\nPage 129 of 420Parcel Sequence Parcel NumberLength\n(Bytes)\nComments and Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 3\nActivityCount = 1\nActivityType = 175 (PCLMONAWTRESSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100\n(indicator mode)Depending on the request (Data or IndicData) data is returned in record or indicator mode. This\nrecord contains information in StatementNo-3. For an example of this record, see Statement 3 -\nMONITOR AWT RESOURCE.\nEndStatement 11 6 StatementNo = 3-byte integer=1\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe MONITOR AWT RESOURCE request returns the following information:\nNumber of AWTs in use within the MSGWORKNEW and MSGWORKONE message work types\nNumber of AMPs in a form of Flow Control\nNumber of AMPs with the highest and lowest in-use counts within the system\nThe output returns three statements:\nThe ﬁrst statement provides information about the collection rate.\nThe second statement provides information about AMPs and the AMPs AWT distribution across the deﬁned thresholds.\nThe third statement provides AMP worker task usage information by each AMP.\nStatement 1\nThe ﬁrst statement is a Record parcel format containing:\nField/Column Name Data T ype Description\nSampleSec INTEGER\nNOT NULLDuration of the collection period, in seconds. This ﬁeld contains the Monitor resource collection rate\n(ResMonitor).\nCollectionDate DATE\nNOT NULLDate the Monitor AWT cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLTime the Monitor AWT cache was last refreshed.\nTo avoid excessive AWT data collection, Monitor AWT Resource checks if the data in the buffer is still valid in relation to the value set for SampleSec (ResMonitor rate) and collects new\ndata only if the data in the buffer has expired.\nStatement 2\nThe second statement is a Record parcel format containing information about AMPs and the AMPs AWT distribution across the deﬁned thresholds.\nField/Column Name Data T ype Description\nInterval 1 Count INTEGER Number of AMPs in the system whose in-use AWT counts fall at, or above, the Threshold 1 value and do\nnot qualify for the higher thresholds.\nInterval 2 Count INTEGER Number of AMPs in the system whose in-use AWT counts fall at, or above, the Threshold 2 value and do\nnot qualify for the higher thresholds.\nInterval 3 Count INTEGER Number of AMPs in the system whose in-use AWT counts fall at, or above, the Threshold 3 value and do\nnot qualify for the higher thresholds.\nInterval 4 Count INTEGER Number of AMPs in the system whose in-use AWT counts fall at, or above, the Threshold 4 value and do\nnot qualify for the higher thresholds.\nLake - Monitor Resources and Performance\nPage 130 of 420Field/Column Name Data T ype Description\nFlow Control INTEGER Number of AMPs in a form of Flow Control.\nHigh AMP 1 VprocId INTEGER Vproc ID of the AMP with the highest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nHigh AMP 1 In-Use Count INTEGER In-use count associated with the AMP 1 Vproc ID. This is only applicable if AMP 1 is deﬁned.\nHigh AMP 2 VprocId INTEGER Vproc ID of the AMP with the next highest in-use count in the system. A value of -1 (or NULL) indicates this\nﬁeld is not deﬁned.\nHigh AMP 2 In-Use Count INTEGER In-use count associated with the AMP 2 Vproc ID. This is only applicable if AMP 2 is deﬁned.\nHigh AMP 3 VprocId INTEGER Vproc ID of the AMP with the next highest in-use count in the system. A value of -1 (or NULL) indicates this\nﬁeld is not deﬁned.\nHigh AMP 3 In-Use Count INTEGER In-use count associated with the AMP 3 Vproc ID. This is only applicable if AMP 3 is deﬁned.\nHigh AMP 4 VprocId INTEGER Vproc ID of the AMP with the next highest in-use count in the system. A value of -1 (or NULL) indicates this\nﬁeld is not deﬁned.\nHigh AMP 4 In-Use Count INTEGER In-use count associated with the AMP 4 Vproc ID. This is only applicable if AMP 4 is deﬁned.\nHigh AMP 5 VprocId INTEGER Vproc ID of the AMP with the next highest in-use count in the system. A value of -1 (or NULL) indicates this\nﬁeld is not deﬁned.\nHigh AMP 5 In-Use Count INTEGER In-use count associated with the AMP 5 Vproc ID. This is only applicable if AMP 5 is deﬁned.\nLow AMP 1 VprocId INTEGER Vproc ID of the AMP with the lowest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nLow AMP 1 In-Use Count INTEGER In-use count associated with the AMP 1 Vproc ID. This is only applicable if AMP 1 is deﬁned.\nLow AMP 2 VprocId INTEGER Vproc ID of the AMP with the lowest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nLow AMP 2 In-Use Count INTEGER In-use count associated with the AMP 2 Vproc ID. This is only applicable if AMP 2 is deﬁned.\nLow AMP 3 VprocId INTEGER Vproc ID of the AMP with the lowest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nLow AMP 3 In-Use Count INTEGER In-use count associated with the AMP 3 Vproc ID. This is only applicable if AMP 3 is deﬁned.\nLow AMP 4 VprocId INTEGER Vproc ID of the AMP with the lowest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nLow AMP 4 In-Use Count INTEGER In-use count associated with the AMP 4 Vproc ID. This is only applicable if AMP 4 is deﬁned.\nLow AMP 5 VprocId INTEGER Vproc ID of the AMP with the lowest in-use count in the system. A value of -1 (or NULL) indicates this ﬁeld\nis not deﬁned.\nLow AMP 5 In-Use Count INTEGER In-use count associated with the AMP 5 Vproc ID. This is only applicable if AMP 5 is deﬁned.\nFlow Control 1 VprocId,\nFlow Control 2 VprocId,\nFlow Control 3 VprocId,\nFlow Control 4 VprocId,\nFlow Control 5 VprocIdINTEGER Vproc ID of the AMP in ﬂow control. A value of -1 (or NULL) indicates this ﬁeld is not deﬁned.\nStatement 3 - MONIT OR AWT RESOURCE\nThe third statement is a Record parcel format containing AMP worker task usage information by each AMP.\nField/Column Name Data T ype Description\nVprocNo SMALLINT\nNOT NULLAMP vproc number.\nAvailableAWTs SMALLINT\nNOT NULLNumber of available AMP worker tasks in each AMP.\nInUseAWTs SMALLINT\nNOT NULLNumber of active AMP worker tasks in each AMP.\nMsgCount INTEGER\nNOT NULLNumber of messages queued for delivery to each AMP.\nLake - Monitor Resources and Performance\nPage 131 of 420Field/Column Name Data T ype Description\nDQMsgCount INTEGER\nNOT NULLNumber of messages processed by each AMP.\nAvailableAWTsForAll SMALLINT The number of available AMP worker tasks in the unreserved pool in each AMP.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a MONITOR AWT RESOURCE request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes). The minimum size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 16 Request MONITOR AWT RESOURCE\n0003 Data 57\nMonVerId\nThreshold 1\nThreshold 2\nThreshold 3\nThreshold 4\nSummary\nDetail6\n10\n12\n14\n15\n1\n0\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe MONITOR AWT RESOURCE request returns values approximately, as follows, when TASM Workloads are enabled and the following input data is speciﬁed:\nThreshold 1 = 10\nThreshold 2 = 12\nThreshold 3 = 14\nThreshold 4 = 15\n    Summary = 1\n     Detail = 1\nThe MONITOR AWT RESOURCE request commonly returns values in text character format. Your application program may return the values in a different format or display.\nYou can rename the SampleSec ﬁeld in your application. In the following output, the SampleRate value is the SampleSec value.\nPay attention to SampleRate when interpreting the results of this request.\nSampleRate: 30\nCollection Date/Time:  06/15/2011 18:32:44.00\nSUCCESS parcel: \nStatementNo=2,    ActivityCount=1,\nActivityType=175, FieldCount=30\nIntervals:\n             1       2       3       4\n             4       0       0       0\nFlow Control = 0\n*** HIGH AMP ***\n                    1       2       3       4       5\nVprocId:            3       2       1       0      -1\nInUseCount:         1       1       1       1       0\n*** LOW AMP ***\n                    1       2       3       4       5\nVprocId:            3       2       1       0      -1\nInUseCount:         1       1       1       1       0\n*** FLOW CONTROL INFO ***\n                    1       2       3       4       5\nVprocId            -1      -1      -1      -1      -1\nSUCCESS parcel: \nStatementNo=3,    ActivityCount=4,\nActivityType=175, FieldCount=5\nLake - Monitor Resources and Performance\nPage 132 of 420VProcNo   AvailableAWTs   InUseAWTs   MsgCount   DQMsgCount\n-------   -------------   ---------   --------   ----------\n      0              49           2          0       111135\n      1              49           1          0       124561\n      2              49           1          0       156017\n      3              49           1          0       122913\nMONIT OR PHYSICAL  CONFIG\nCollects overall information on node availability. Node status information is returned for all nodes in the system.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have any of the following monitor privileges as part of your default role or any of these privileges must be granted directly to you:\nABORTSESSION\nMONRESOURCE\nMONSESSION\nSETRESRATE\nSETSESSRATE\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR PHYSICAL  CONFIG\nMONITOR PHYSICAL CONFIG is most useful when used with the MONITOR PHYSICAL SUMMARY request for doing a quick overall system health check. For more information, see\nRelationship between MONITOR PHYSICAL CONFIG and MONITOR PHYSICAL SUMMARY.\nYou can use the MONITOR PHYSICAL CONFIG request instead of dumping the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view) to check for a\nphysical problem with the system.\nCLIv2 Response Parcels\nThe MONITOR PHYSICAL CONFIG request is treated internally as a two statement request, with each statement generating a response. The database returns the two statement\nresponse containing the following sequence of parcels.\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 92 (PCLMONPCONFIG)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. This record\ncontains the BYNET status data and the type of system running the Vantage software.\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nLake - Monitor Resources and Performance\nPage 133 of 420Parcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nActivityCount = Number of nodes\nActivityType = 92 (PCLMONPCONFIG)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. Multiple record\nparcels are returned that consist of a record for each node in the system. This record contains\nnode-speciﬁc information; one record per node.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nFor descriptions of the number ﬁeld and length ﬁeld, see Teradata® Call-Level Interface Version 2 Reference for Mainframe-Attached Systems, B035-2417 or Teradata® Call-Level\nInterface Version 2 Reference for Workstation-Attached Systems, B035-2418. Within the parcel body ﬁelds, the order of items and their data types and lengths are determined by the\nUSING Phrase.\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe Record parcel in the ﬁrst statement of the MONITOR PHYSICAL CONFIG response returns the following values:\nColumn Field/Column Name Data T ype Description\n1 NetAUp VARCHAR(1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-\nwide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\n2 NetBUp VARCHAR(1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-\nwide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\n3 SystemType VARCHAR(7)\nNOT NULLType of system running the Vantage software, such as 5650, 6700, or ‘Other’.\nIf all the nodes in the system are the same type, this ﬁeld returns the type of\nthe system.\nIf any of the nodes are of a different type, this ﬁeld returns ‘Mixed’.\nThis output parameter is available on monitor software version 9 or later only.\n4 SystemName VARCHAR(15) Name of the system running Teradata.\nIf you are using MONITOR software version ID (mon_ver_id) 10 or earlier, this\noutput parameter is not available.\nStatement 2\nThe response to the second statement returns multiple Record parcels that consist of a record for each node in the system. For example, if you have two nodes, two records are\nreturned with speciﬁc information for each processor.\nRecords are sorted based on NodeID. The following table shows the order in which the Record parcel returns the data.\nField/Column Name Data T ype Description\nProcId INTEGER\nNOT NULLID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nLake - Monitor Resources and Performance\nPage 134 of 420Field/Column Name Data T ype Description\nStatus VARCHAR(1) NOT NULL Status of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nS = Standby\nA node is up (U) when all of the following are true:\nThe node is conﬁgured into the system\nThe node is online\nThe node can perform tasks associated with normal database activity\nDown (D) represents all other potential states.\nStandby (S) indicates the node is ready to join the conﬁguration in place if another node goes down.\nWhen the node status is Standby, the SystemType, NetAUp, and NetBUp ﬁelds are not available and\nNULL or spaces are returned.\nCPUType VARCHAR (7)\nNOT NULLType of central processing unit (CPU) installed in this node , for example, ‘Pentium’, ‘PentPro’, or\n‘Unknown’.\nCPUCount INTEGER\nNOT NULLNumber of CPUs in this node.\nSystemType VARCHAR (7) Type of system running the Vantage software, such as 5650, 6700, or ‘Other’.\nThis output parameter is available on monitor software version 9 or later only.\nCliqueNo SMALLINT\nNOT NULLClique number of the node.\nThis output parameter is available on monitor software version 9 or later only.\nNetAUp VARCHAR(1) Status of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = Node BYNET is up/online.\nD = Node BYNET is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\nNetBUp VARCHAR(1) Status of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = Node BYNET is up/online.\nD = Node BYNET is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\nPhyMemory INTEGER Size of the physical memory of the node in MBs.\nIf you are using MONITOR software version ID (mon_ver_id) 10 or earlier, this output parameter is not\navailable.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a MONITOR PHYSICAL CONFIG request, built by CLIv2, look when sent to the database server.\nIn the following example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 27 Request MONITOR PHYSICAL CONFIG\n0003 Data 6 MonVerID 9\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nUsing monitor software version ID 11, this request may return the following values in character text format.\nLake - Monitor Resources and Performance\nPage 135 of 420Your application program may display returned values in a different format.\nSubmitting request MONITOR PHYSICAL CONFIG; ...\nNetAUp:  U NetBUp:  U\nSystemType: 5500C\nSystemName: localhost\n1 node(s) found\nProcId:    10001 (1-1) Status: [ U]   CPUType: [Xeon   ]  CPUCount: 1\nSystemType: [5500C  ]\nCliqueNo: 0\nNetAUp: [  ] NetBUp: [  ]\nPhyMemory: 5720\nRelationship between MONIT OR PHYSICAL  CONFIG and MONIT OR PHYSICAL  SUMMAR Y\nUse the MONITOR PHYSICAL SUMMARY request with the MONITOR PHYSICAL CONFIG request for an overall system status. These are low overhead requests.\nRun the MONITOR PHYSICAL SUMMARY request every 5 or 10 minutes for a low-cost, continuous monitoring of your system.\nRun the MONITOR PHYSICAL CONFIG request to get a picture of your system conﬁguration at deﬁned times, such as at the beginning of a day, different times during the day,\nor when the system is down.\nUse these requests to spot problems, such as abnormal Central Processing Unit (CPU) load balancing, and possible sources of system performance bottlenecks. For example, if the\nHigh/LowCPUUse ﬁgures are consistently widely separated and do not approximate the AvgCPU ﬁgure, you may need to evaluate whether the system is using available resources\nefﬁciently. How often you check your system depends on the size of your system and the type of applications your system runs.\nKnowledge of the overall system status can help you to determine these three concerns.\nConcern Comments\nWhen to run production applications, especially large ones For example, if you have a down node, Access Module Processors (AMPs) and Parsing Engines (PEs) may\nmigrate to other nodes. Recovering the node ﬁrst and running the job may be less costly than running the job\nwithout full system availability.\nWhy an application runs more slowly than usual This situation may be caused by a down node, which causes the online nodes to run more than the optimal\nnumber of AMPs and PEs. This, in turn, can cause your application to run more slowly.\nWhether all nodes have come back up after a system restart Examine the Status value returned in a MONITOR PHYSICAL CONFIG request to determine whether each\nnode is up or down.\nIf the data returned from a MONITOR PHYSICAL SUMMARY query does not give you enough information (for example, you need BYNET or CPU% busy information), use the\nMONITOR PHYSICAL RESOURCE request to get more detailed resource usage data.\nThe data returned by the MONITOR PHYSICAL CONFIG request is an abbreviated form of the data returned by the MONITOR PHYSICAL RESOURCE request.\nThe MONITOR PHYSICAL CONFIG and MONITOR PHYSICAL SUMMARY requests do not return the status of non-database nodes. However, these requests may accumulate and\nreturn data on resources consumed by non-Teradata applications running on database nodes. To determine the resources consumed by non-Teradata applications, compare the\nfollowing:\nData returned by the MONITOR PHYSICAL RESOURCE request with that of the MONITOR VIRTUAL RESOURCE request (that is, the subtotal of the resource statistics by node).\nData returned by the MONITOR PHYSICAL SUMMARY request with that of the MONITOR VIRTUAL SUMMARY request (that is, the subtotal/average by node of the resource\nstatistics in the MONITOR VIRTUAL SUMMARY).\nMONIT OR PHYSICAL  RESOURCE\nCollects RSS data and returns node-speciﬁc data.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later only.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nLake - Monitor Resources and Performance\nPage 136 of 420Monitor Privileges\nTo use this request, you must have the MONRESOURCE privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR PHYSICAL  RESOURCE\nBecause information is given on the detailed resource usage of each node, performance concerns can be isolated by node.\nUse the MONITOR PHYSICAL RESOURCE request to:\nExpand on the data reported by the MONITOR PHYSICAL SUMMARY request.\nIn your initial problem analysis, a MONITOR PHYSICAL SUMMARY request may indicate a performance or system problem. MONITOR PHYSICAL RESOURCE allows you to\ncollect RSS data on a node by node basis.\nContinually monitor your system.\nMonitor your system on a periodic basis, for example, every 10 minutes. Use this request to build a normal baseline proﬁle for your system. When you notice something\nabnormal or a user complains that a job is slow (such as the last reading is signiﬁcantly different from the normal baseline reading), this request can tell you:\nIf there is a parallel efﬁciency problem\nA constraint to throughput\nAnd which node is causing it.\nDetermine whether a new application can be added to the current system load without disruption.\nThe node usage information collected by this request can help you evaluate the impact of adding new applications to an already heavily used system and help you plan\npotential system upgrades.\nHelp resolve problems that session-level usage information cannot resolve.\nWhen the MONITOR SESSION request does not show any cause for the problem, the MONITOR PHYSICAL RESOURCE request provides information on congestion, memory\nallocations, BYNET outages, and system status.\nThe MONITOR PHYSICAL RESOURCE request provides the following information:\nHow the system is being used (for example, the percentage of CPU usage by node)\nHow system resource usage is spread across the nodes\nHow much physical disk Input/Output (I/O), BYNET trafﬁc, or host reads and writes are occurring\nWhether congestion or excessive swapping is a problem on any node or group of nodes\nThe ﬁelds the MONITOR PHYSICAL RESOURCE request returns and the ﬁelds found in the resource usage tables overlap. You can use both MONITOR PHYSICAL RESOURCE and\nresource usage data for problem detection. Unlike resource usage data, MONITOR PHYSICAL RESOURCE data is near real time, requires less overhead to produce, but is less\ncomprehensive. MONITOR PHYSICAL RESOURCE data helps detect:\nPoor Node CPU parallel efﬁciency\nPoor disk parallel efﬁciency\nA higher than expected disk read/write ratio\nA high swap I/O rate\nIf the MONITOR PHYSICAL RESOURCE request does not provide enough detailed data for problem detection, run one or more of the resource usage macros. See Monitoring\nPerformance and Resource Usage.\nThere are MONITOR PHYSICAL RESOURCE and MonitorPhysicalResource ﬁelds that return NULL if any of the following are true:\nA node is down or ofﬂine.\nThe ResMonitor is set to zero.\nYou must set the ResMonitor rate to a nonzero value to allow the MONITOR PHYSICAL RESOURCE request or MonitorPhysicalResource function to return meaningful data.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate\nAfter a system outage or a change in the ResMonitor rate, do not request data again until after completion of the ﬁrst collection period requested after the crash or change in\nrate. Otherwise, the data returned contains NULL except NetAUp, NetBUp, SampleSec, ProcId, AMPCount, PECount, and Status, and may not be fully representative. The in-\nmemory counters reset after a crash. Typically, the contents of the counters are not well deﬁned until a full collection period has elapsed. If you were logged on before the\nsystem outage, and you issue the ﬁrst MONITOR PHYSICAL RESOURCE request or MonitorPhysicalResource function after the outage, you get a warning that the database\nsystem has been restarted.\nAll values retured by MONITOR PHYSICAL RESOURCE are those that were collected asynchronously at the end of the previous resource collection period.\nResource collection period can be changed using SET RESOURCE RATE.\nCLIv2 Response Parcels\nThe MONITOR PHYSICAL RESOURCE request is treated internally as a two statement request with each statement generating a response. The database returns a two statement\nresponse containing the following sequence of parcel types.\nLake - Monitor Resources and Performance\nPage 137 of 420Parcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 96 (PCLMONPRES)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. One\nrecord is returned. That record contains the duration of the collection period (in\nseconds), BYNET status, and the data and time of when the Physical Resource cache\nwas last refreshed.\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = Number of nodes\nActivityType = 96 (PCLMONITOPRES)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicReq parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. One\nrecord per node is returned. Each record contains a description for each node,\nincluding BYNET status.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe response to the ﬁrst statement results in a Record parcel containing global data about the collection duration and BYNET status that is generated once for the whole system. The\nfollowing table shows the order in which the data is returned.\nField/Column Name Data T ype Description\nNetAUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nNetBUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nSampleSec SMALLINT\nNOT NULLDuration of the collection period in seconds. This ﬁeld is equivalent to the ResMonitor rate. See Data\nCollection and SET RESOURCE RATE for more information on ResMonitor.\nCollectionDate DATE\nNOT NULLDate the Physical Resource cache was last refreshed.\nCollectionTime FLOAT,\nNOT NULLTime the Physical Resource cache was last refreshed.\nStatement 2\nLake - Monitor Resources and Performance\nPage 138 of 420The response to the second statement returns multiple Record parcels that consist of a one record of 32 ﬁelds for each node in the system. For example, if you have 50 nodes, 50\nrecords are returned with speciﬁc information for each node. One record describes the collection period and BYNET status for the entire system.\nThe following table shows the order in which the Record parcel returns the data.\nField/Column Name Data T ype Description\nProcId INTEGER\nNOT NULLID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nAmpCount SMALLINT\nNOT NULLCurrent number of AMPs executing on the associated node.\nPECount SMALLINT\nNOT NULLCurrent number of active PEs on the associated node.\nCPUUse FLOAT\nrange 0 - 100%% of CPU usage not spent being idle. This value is computed from ResUsageSpma table data as:\nPercntUser + PercntService\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nPercntIOWait FLOAT % of CPU resources in idle and waiting for I/O completion. This value is computed from\nResUsageSpma data as follows, where x is the number of CPUs:\nCPUIOWAIT / (x * SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nPercntService FLOAT % of CPU resources spent in PDE user service processing. The value is computed from the\nResUsageSpma table data, where x represents the number of CPUs:\nCPUUServ / (x * SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nPercntUser FLOAT % of CPU resources spent in non-service user code processing. This value is computed from the\nResUsageSpma table data, where x represents the number of CPUs:\nCPUUExec / (x * SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nStatus VARCHAR (1)\nNOT NULLStatus of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nS = Standby\nA node is up (U) when all of the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nStandby (S) indicates the node is ready to join the conﬁguration in place if another node goes down.\nWhen the node status is Standby, the SystemType, NetAUp, and NetBUp ﬁelds are not available and\nNULL or spaces are returned.\nNetAUse FLOAT % of BYNET A usage. This is the actual BYNET receiver usage. (The BYNET transmitter usage is\nmaintained in resource usage separately and is typically lower than the receiver usage. This is\ncaused by multicasts, where one transmitter sends a message to multiple receivers.) This value is\ncomputed from the ResUsageSpma table data as follows:\n((NetSamples - NetTxIdle) / NetSamples)* 100.0\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nDiskUse FLOAT % of disk usage per node.\nThis value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv\ndevices used by this node:\nLake - Monitor Resources and Performance\nPage 139 of 420Field/Column Name Data T ype Description\n(LdvOutReqTime 1 + ... + LdvOutReqTime n) / (n*SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nThe DiskUse ﬁeld does not take into account overlapping of operations among multiple storage\ndevices, but does allow for the possibility of multiple requests for the same device.\nDiskReads FLOAT Total number of physical disk reads per node during the collection period. This value is computed\nfrom ResUsageSldv table data as follows, assuming n is the number of ldv devices used by this\nnode:\nLdvReads 1 + ... + LdvReads n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nDiskWrites FLOAT Total number of physical disk writes per node during the collection period. This value is computed\nfrom ResUsageSldv table data as follows, assuming n is the number of ldv devices used by this\nnode:\nLdvWrites 1 + ... + LdvWrites n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nDiskOutReqAvg FLOAT Average number of outstanding disk requests per disks (averaged over all the disks on a node). This\nvalue can be used to monitor the load on the disks and indicate problems with the throughput if the\nlevel becomes too high.\nThis value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv\ndevices used by this node:\n((LdvOutReqSum 1 / NULLIFZERO(LdvOutReqDiv 1)) + … + (LdvOutReqSum n /\nNULLIFZERO(LdvOutReqDiv n))) / n\nThe range of the value is typically 0 to 25.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nHostBlockReads FLOAT Number of message blocks (one or more messages sent in one physical group) received from all\nclients. This value is computed from ResUsageShst data, assuming n is the number of host channel\nand network connections on this node:\nHostBlockReads 1 + ... + HostBlockReads n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nHostBlockWrites FLOAT Number of message blocks (that is, one or more messages sent in one physical group) sent to all\nhosts. For node displays, this value is computed from ResUsageShst data, assuming n is the number\nof host channel and network connections on this node:\nHostBlockWrites 1 + ... + HostBlockWrites n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nSwapReads FLOAT Number of pages/segments read into node memory from the disk during the collection period after a\nprior write/drop. This value is computed from the ResUsageSpma table data as MemCtxtPageReads.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nSwapWrites FLOAT Number of pages/segments written to swap area from node memory during the collection period.\nThis value is computed from the ResUsageSpma table data as MemCtxtPageWrites.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nSwapDrops FLOAT Number of pages/segments dropped from node memory during the collection period due to\nswapping.\nThis ﬁeld returns zero.\nMemAllocates FLOAT This ﬁeld is deprecated and returns zero or NULL.\nMemAllocateKB FLOAT Value represents the change in the node-level memory. MemAllocateKB represents a delta from the\nprevious reporting period. Negative values indicate that less memory is used.\nThis value is calculated from the ResUsageSpma column:\nMemVprAllocKB\nLake - Monitor Resources and Performance\nPage 140 of 420Field/Column Name Data T ype Description\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nMemFailures FLOAT This ﬁeld is deprecated and returns zero or NULL.\nMemAgings FLOAT This ﬁeld is deprecated and returns zero or NULL.\nNetReads FLOAT Number of Reads from the BYNET to the node. This value is computed from the ResUsageSpma\ntable data as:\nNetRxCircBrd + NetRxCircPtP\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nNetWrites FLOAT Number of messages written from the node to the BYNET during the collection period. For node-level\ndisplays, the value is computed from the ResUsageSpma table data as:\nNetTxCircBrd + NetTxCircPtP\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL RESOURCE.\nNetAUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = Node BYNET is up/online.\nD = Node BYNET is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\nNetBUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = Node BYNET is up/online.\nD = Node BYNET is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\nVprocCount SMALLINT Available segment space for each Vproc in MB.\nThis output parameter is available on monitor software version 16 or later only.\nSegSizeMBperVproc INTEGER Size of the segment space for each Vproc in MB.\nThis output parameter is available on monitor software version 16 or later only.\nSegCurrAvailMBperVProc INTEGER Available segment space for each Vproc in MB.\nThis output parameter is available on monitor software version 16 or later only.\nSample Input - CLIv2 Request\nThe following example shows how the parcels, built by CLIv2, for a MONITOR PHYSICAL RESOURCE request look when sent to the database.\nIn this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 20 Request MONITOR PHYSICAL RESOURCE\n0003 Data 6 MonVerID 9\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis request may return the following values in character text format (a record for each node). Your application program may display returned values in a different format.\nYou can rename the SampleSec ﬁeld in your application. In the following output, the SampleRate value is the SampleSec value.\nPay attention to SampleRate when interpreting the results of this request. Use monitor version 13 when running the following example:\nSubmitting request MONITOR PHYSICAL RESOURCE; ... \nNetAUp:  U NetBUp: U\nSampleRate: 60\nLake - Monitor Resources and Performance\nPage 141 of 420Collection Date/Time:   07/06/2016 13:48:00.00  \nProcId:    10001 (1-1) AmpCount: 4   PECount: 2 \nCPUUse:  100.0   PrcntKernel:   0.0   PrcntService:   2.2   PrcntUser: 97.8 \nStatus: U\nNetAUse:      0.0   DiskUse:     10.7\nDiskReads:   36.00   DiskWrites: 6500.00   DiskOutReqAvg:   0.19\nHstBlkRds:   8.00   HstBlkWrts:    8.00\nSwapReads:   0.00   SwapWrites:    0.00  SwapDrops:    0.00 \nMemAllocates:        0.00  MemAllocateKB:   16.00 MemFailures:         0.00   \nMemAgings:    0.00 \nNetReads:     0.00   NetWrites:    0.00 \nNetAUp:  U NetBUp:  U \nRelationship between MONIT OR PHYSICAL  RESOURCE and ABORT SESSION\nIf you ran an ABORT SESSION request, data returned in a MONITOR PHYSICAL RESOURCE or MONITOR VIRTUAL RESOURCE request may be altered. Whether you notice the\nchange in data depends on the scope of the ABORT SESSION request. For example, if you run an ABORT SESSION and log off all of the sessions associated with a speciﬁc host (or\nclient), the PEs associated with that client reports a large decrease in resource consumption. However, if the ABORT SESSION request only aborts one transaction from one session,\nyou may not notice a change in AMP or PE resource use.\nRelationship between MONIT OR PHYSICAL  RESOURCE and SET RESOURCE RA TE\nYou must run the SET RESOURCE RATE request to activate resource data collection before you run a MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request.\nTherefore, you must set the resource monitoring rate (ResMonitor) to nonzero. If the ResMonitor rate is set to zero, you get an error message.\nA change in the resource collection rate by User A, for example, may affect the data reported by MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request made\nby User B. If the ResMonitor rate is altered, User B gets a warning message when executing a subsequent MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE\nrequest.\nMONIT OR PHYSICAL  SUMMAR Y\nCollects global summary information that includes the following types of information:\nCPU usage (average, high, and low)\nDisk usage (average, high, and low)\nBYNET usage (total, up/down)\nRate information (resource logging rate and resource monitoring rate)\nCurrent software release and version numbers\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT, NOT NULL MONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have any one of the following monitor privileges as part of your default role or any of these privileges must be granted directly to you:\nABORTSESSION\nMONRESOURCE\nMONSESSION\nSETRESRATE\nLake - Monitor Resources and Performance\nPage 142 of 420SETSESSRATE\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR PHYSICAL  SUMMAR Y\nThere are MONITOR PHYSICAL SUMMARY and MonitorPhysicalSummary ﬁelds that return NULL if any of the following are true:\nA node is down or ofﬂine.\nThe ResMonitor is set to zero.\nYou must set the ResMonitor rate to a nonzero value to allow the MONITOR PHYSICAL SUMMARY request or MonitorPhysicalSummary function to return meaningful data.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAfter a system outage or a change in the ResMonitor rate, do not request data again until after completion of the ﬁrst collection period requested after the outage or change in\nrate. Otherwise, the data returned contains NULL except NetAUp, NetBUp, SampleSec, ProcId, AMPCount, PECount, and Status, and may not be fully representative.\nThe in-memory counters reset after a system outage. Typically the contents of the counters are not well-deﬁned until a full collection period has elapsed. If you were logged on\nbefore the outage, and you issue the ﬁrst MONITOR PHYSICAL SUMMARY request or MonitorPhysicalSummary function after the outage, you get a warning that the database\nsystem has been restarted.\nBy default, the statistics for PE only nodes are excluded in the calculation of MONITOR PHYSICAL SUMMARY statistics.\nCLIv2 Response Parcels\nThe response returned from the database resembles a summary of the type of response returned by a MONITOR PHYSICAL SUMMARY request. The response is one row of 22 ﬁelds.\nThe response returned from the database contains the following sequence of parcel types.\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 94 (PCLMONPSUMMARY)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on request (Data or IndicData), data is in record or indicator mode. This\nrecord contains the Data or IndicData physical summary information and the date and\ntime the Physical Resource cache was last refreshed.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nSee the appropriate section in Teradata® Call-Level Interface Version 2 Reference for Mainframe-Attached Systems, B035-2417 or Teradata® Call-Level Interface Version 2 Reference\nfor Workstation-Attached Systems, B035-2418.\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe following table describes the resource usage information returned from the Record parcel for the MONITOR PHYSICAL SUMMARY response.\nField/Column Name Data T ype Description\nAvgCPU FLOAT Average % CPU usage (CPUUse) time of all online nodes in the Vantage conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nAvgDisk FLOAT Average % disk usage (from DiskUse) of all online nodes in the Vantage conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nAvgDiskIO FLOAT Average number DiskReads and DiskWrites for all online nodes in the Vantage conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nHighCPUUse FLOAT Highest CPUUse number associated with any online node that is part of the Vantage conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLake - Monitor Resources and Performance\nPage 143 of 420Field/Column Name Data T ype Description\nHighCPUProcId INTEGER ID of a node with CPPUse equal to the value reported as HighCPUUse.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowCPUUse FLOAT Lowest CPUUse number associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowCPUProcId INTEGER ID of a node with CPPUse equal to the value reported as LowCPUUse.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nHighDisk FLOAT Highest % disk usage (from DiskUse) associated with any online node that is part of the database\nconﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nHighDiskProcId INTEGER ID of a node with DiskUse equal to the value reported as HighDisk.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowDisk FLOAT Lowest % disk usage (from DiskUse) associated with any online node that is part of the database\nconﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowDiskProcId INTEGER ID of a node with DiskUse equal to the value reported as LowDisk.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when LowDisk is NULL.\nHighDiskIO FLOAT Highest DiskReads and DiskWrites number associated with any online node that is active in the\ndatabase conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nHighDiskIOProcId INTEGER ID of a node with DiskReads and DiskWrites equal to the value reported as HighDiskIO.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowDiskIO FLOAT Lowest DiskReads and DiskWrites number associated with any online node that is part of the database\nconﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nLowDiskIOProcId INTEGER ID of a node with DiskReads and DiskWrites equal to the value reported as LowDiskIO.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when LowDiskIO is NULL.\nNetUse FLOAT % of total BYNET use (that is, average of the online BYNETs).\nIf both BYNETs are up, the value is computed from ResUsageSpma table data as:\nNetUse = Average NetAUse per node / NetCount\nwhere:\nNetCount is 2 if both NetA and NetB are up or 1 if only one of the BYNET is up.\nLake - Monitor Resources and Performance\nPage 144 of 420Field/Column Name Data T ype Description\nAverage NetAUse is the sum of all NetAUse of each node divided by the number of online\nnodes.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR PHYSICAL SUMMARY.\nNetUse returns a value of zero because resource usage data is not available.\nNetAUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nNetBUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nResLogging SMALLINT\nNOT NULL\nrange 0-3600 seconds,Interval in seconds at which resource usage data is written to one or more active resource usage\ndatabase tables.\nResMonitor SMALLINT\nNOT NULL\nrange 0-3600 secondsInterval in seconds at which all resource usage data is collected in memory for reporting using the\nPM/API.\nRelease VARCHAR (29)\nNOT NULLRelease number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nVersion VARCHAR (32)\nNOT NULLVersion number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nCollectionDate DATE\nNOT NULLDate the Physical Resource cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLTime the Physical Resource cache was last refreshed.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a MONITOR PHYSICAL SUMMARY request, built by CLIv2, look when sent to the database.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 28 Request MONITOR PHYSICAL SUMMARY\n0003 Data 6 MonVerID 9\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe following example shows the values returned in character text format for the MONITOR PHYSICAL SUMMARY request. Your application program may display returned values in a\ndifferent format.\nSubmitting request MONITOR PHYSICAL SUMMARY; ...\nLake - Monitor Resources and Performance\nPage 145 of 420AvgCPU:       100.00   AvgDisk:        10.75   AvgDiskIO:      6536.00\nHighCPUUse:   100.00   HighDisk:      100.00   HighDiskIO:       10.75\nHighCPUProcId: 10001   HighDiskProcId: 10001   HighDiskIOProcId: 10001\nLowCPUUse:     10.75   LowDisk:      6536.00   LowDiskIO:      6536.00\nLowCPUProcId:  10001   LowDiskProcId:  10001   LowDiskIOProcId: 10001\nNetUse:         0.00   NetAUp:  U   NetBUp:  U\nResLogging:       60   ResMonitor:        60\nRelease: 16t.00.00.97                    Version: 16t.00.00.97_dr182707j\nCollection Date/Time:   88/64/110954 00:00:00.00\nWarning and Error Messages\nAll users who are logged on and issue a MONITOR PHYSICAL SUMMARY request after a system restart or after the last rate change can expect a warning. Users also get a warning if\nthe resource monitoring rate (ResMonitor) is set to zero.\nEither MONITOR PHYSICAL SUMMARY or MONITOR PHYSICAL RESOURCE requests issues a warning for any sessions logged on before the database recovery, or before the\nchange in the ResMonitor collection rate.\nFor more detailed information on warning and error messages, see Database Messages.\nRelationship between MONIT OR PHYSICAL  SUMMAR Y and MONIT OR PHYSICAL  CONFIG\nUse the MONITOR PHYSICAL SUMMARY request with the MONITOR PHYSICAL CONFIG request for an overall system status. These are low overhead requests.\nRun the MONITOR PHYSICAL SUMMARY request every 5 or 10 minutes for a low-cost, continuous monitoring of your system.\nRun the MONITOR PHYSICAL CONFIG request to get a picture of your system conﬁguration at deﬁned times, such as at the beginning of a day, different times during the day,\nor when the system is down.\nFor information on this PMPC CLIv2 or the Teradata JDBC Driver request relationship, see Relationship between MONITOR PHYSICAL CONFIG and MONITOR PHYSICAL SUMMARY.\nRelationship between MONIT OR PHYSICAL  SUMMAR Y and SET RESOURCE RA TE\nThe SET RESOURCE RATE request sets the ResMonitor and ResLogging rates, which are among the responses returned by the MONITOR PHYSICAL SUMMARY or MONITOR\nVIRTUAL SUMMARY request. Any change to either the ResMonitor or ResLogging rate causes changes in the corresponding response returned by the MONITOR VIRTUAL SUMMARY\nor MONITOR PHYSICAL SUMMARY request.\nYou must set ResMonitor to a nonzero rate for MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL SUMMARY to return meaningful resource usage data. A zero ResMonitor rate\nreturns NULL for resource usage information.\nRelationship between MONIT OR PHYSICAL  SUMMAR Y and SET SESSION RA TE\nChanges to the session-level rates (global and local) speciﬁed by SET SESSION RATE are reported in the data returned by MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL\nSUMMARY.\nThe local rate reported is your own local rate. If the local rate is not set, the local rate is reported as zero.\nAs more session-level monitoring is done (by setting a faster SET SESSION RATE), the resulting overhead may increase the level of CPU usage (reported in MONITOR PHYSICAL\nSUMMARY or MONITOR VIRTUAL SUMMARY data) by your system. However, this may depend on the size of the rate change and the type of work done by other sessions.\nMONIT OR SESSION\nReturns session or request resource usage statistics.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nVersion 6 or later can be used to determine if a utility session is on the Teradata dynamic workload\nmanagement software delay queue. For information on returning the utility delay queue, see\nTDWMGetDelayedUtilities.\nLake - Monitor Resources and Performance\nPage 146 of 420Element Data T ype Description\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT Logical ID of a host (or client) with sessions logged on. host_id cannot exceed 1023. A host_id of zero\nidentiﬁes the system Console ID of the host on which sessions are running.\nsession_no INTEGER Session number. The session number combined with the host_id represents a unique session ID.\nuser_name VARCHAR (512) Name of user who is running the sessions.\nIf you do not specify host_id, user_name, or session_no, or group_id, all hosts, all users, or all sessions, or all groups are monitored. For example, if you specify 127 for host_id,\nPEDERSON for user_name, and do not specify session_no or group_id, the MONITOR SESSION request reports on all sessions logged on from host 127 as user PEDERSON.\nNULL in any ﬁeld, with the exception of mon_ver_id, indicates a match for all potential values of that ﬁeld. A NULL for mon_ver_id isssues an error. IndicData parcels are used to\nspecify the output ﬁelds that are null. For additional information on IndicData, see Creating a Request with CLIv2.\nFor information on the data returned for each monitor version, see Response Groups.\nMonitor Privileges\nTo use this request, you must have MONSESSION privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR SESSION\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nUse this information, when a job stops responding because of unavailable resources, to ﬁnd the following:\nThe user causing a block\nThe locked database or table\nSystem usage data on a session-by-session basis\nIn the MONITOR partition, each job is a session. You can run the MONITOR SESSION request to query:\nAll hosts (or clients) with all sessions\nSingle host (or client) with all sessions\nSingle host (or client) with all sessions for a given user name\nSingle host (or client) with a single session and a given user name\nMONITOR SESSION requests return data:\nIdentical for all sessions\nSpeciﬁc to a session\nMONITOR SESSION requests return accumulated session statistics commencing with the last time that one of the following events impacted a session:\nThe time that a session logged on.\nThe time that a session-switch changed the vproc with Session Control responsibility for a session.\nThe time that a system outage or TPA restart occurred.\nThe time that system or local rate was set to a nonzero value.\nA MONITOR SESSION request can also be used to track session-level AMP usage and provide data on the three highest and lowest CPU/IO used AMPs. This can help identify:\nSkewed data\nPossible hardware problems\nPossible database bugs\nYou can use the data returned by the MONITOR SESSION request as input for the IDENTIFY request to determine lock activity. For more information, see IDENTIFY.\nBe aware of the following rules:\nTo collect statistics, set the system or local rate to a nonzero value.\nData on a session is reported only for the last complete collection period. For example, assume the collection rate is 600 seconds (or 10 minutes) and that you issue a\nMONITOR SESSION request at 9:00 a.m. If the user for whom you are seeking data logged onto the system at 9:01 a.m., no session data is available until the next MONITOR\nSESSION request is issued at 9:10 a.m. (on completion of the current collection period). A MONITOR SESSION request made at 9:05 a.m. (after the user logged on at 9:01\na.m.) reports only on sessions that stayed logged on at 9:00 a.m.\nWhen a session-switch changes the processor with session control responsibility for a session, previous data in memory is lost and the data collection for the affected session\nstarts over again.\nA system outage occurs clears out the previous data and data collection starts again.\nThe RSS data loss affects only speciﬁc sessions when a session logs off or a PE goes down, forcing all sessions on that PE to switch to another PE. In other cases, such as a system\noutage, the data loss affects all sessions.\nLake - Monitor Resources and Performance\nPage 147 of 420If a system failure occurs, the response to subsequent MONITOR SESSION requests contains a warning message. For more information, see Database Messages.\nThe MONITOR SESSION request returns an ActivityCount (one of the ﬁelds in the Success parcel indicating total number of records selected, updated, and so forth) equal to 0 or -1.\nActivityCount Meaning\n0 Requested combination of logical HostId, UserName, and SessionNo does not match a session.\n-1 Request generates an unknown number of Response Rows. The application must continue to gather data until encountering the\nEndStatement parcel.\nA value of -1 is used because ActivityCount cannot be determined when the request is run. Because the response is collected from data\nshared by all running Monitor sessions, that data can be updated while a request is in progress. If that update adds or removes\ninformation on sessions, the activity count calculated at the beginning of a session query response generation does not become valid by\nthe end of the response processing for that session. Rather than return possibly incorrect data, the ActivityCount is set to indicate that\nthe count is unknown.\nA Trusted Session enables a middle-tier application to switch the user on an already active database session to another user (proxy user). When the user is switched, all subsequent\nrequests uses the privileges and session attributes of the proxy user. Monitor Session returns the logon user name and ID in the UserName and UserId ﬁelds and the proxy user name\nand ID in the ProxyUserName and ProxyUserId ﬁelds.\nThe following CPU ﬁelds in the MONITOR SESSION response are affected by the MonSesCPUNormalization ﬁeld:\nAMPCPUSec\nAvgAmpCPUSec\nHotAmp1CPU\nHotAmp2CPU\nHotAmp3CPU\nLowAmp1CPU\nLowAmp2CPU\nLowAmp3CPU\nPECPUSec\nRequestAmpCPU\nThe MonSesCPUNormalization ﬁeld controls whether normalized or non-normalized statistical CPU data is reported by the MONITOR SESSION request, and by the functions\nMonitorMySessions and MonitorSession.\nFor a complete description of these ﬁelds, see the \"Response Groups\" table in this topic..\nYou can also see MonitorMySessions or MonitorSession for a list of these CPU ﬁelds.\nCollecting Session Data\nAfter a collection interval is set to a nonzero rate, session usage data is accumulated in AMP and PE storage areas (regardless of the rate set). When a user makes a MONITOR\nrequest, the central coordinator task determines if current data is necessary. If current data is required, the central coordinator task directs the processors to transmit data from\nprocessor storage areas on the AMPs to the main memory repository on each PE where each PE is simultaneously collecting its own session data. Otherwise, data in the main PE\nrepositories is considered current and is sent to the user.\nCurrent data is associated with an internal timestamp not visible to the user. Every MONITOR SESSION request issued by a user is associated with a session-level data collection rate.\nThis rate is the local rate if a local rate has been set. Otherwise, this rate is the global rate.\nWhen a user runs a MONITOR SESSION request, the central coordinator task checks the age of the current session-level data (current time minus the data timestamp). Depending on\nthe age determination, action is then taken on the data as shown in the following table.\nData in PE Memory Repository Result\nConsidered current (the age of the data is less than or equal to the session collection\nrate)Data is returned to the user.\nNot considered current (the age of the data is greater than the session collection rate) Coordinator task forces a data update (causing its internal timestamp to be reset to the\ncurrent time) and returns the updated data to the user.\nUnreported Session Partitions\nResource usage in session partitions may not be reported or fully reported. MONITOR SESSION requests do not report statistics on session resources used by the DBCUTIL utility.\nAlthough resource usage is reported, not all resource usage data is accounted for. These restrictions may affect the following data returned from a MONITOR SESSION request:\nAMPCPUSec\nAMPIO\nRequest_AMPSpool\nAMPState\nPECPUSec\nPEState\nReqCount\nLake - Monitor Resources and Performance\nPage 148 of 420As an example of how the returned data is affected, both AMPState and PEState data values may be UNKNOWN if I/O is done on behalf of the unreported partitions. As another\nexample, in a Teradata SQL session, PECPUSec spent in a PE do not include time spent in Gateway communications processing.\nDown Processor\nWhen a previously active PE is down because of a system outage, the data returned for those sessions logged on to the down processor may not be meaningful. If you encounter a\nsystem outage, pay attention to the following information, because the PE data does not change:\nHostId\nLogonPENo\nSessionNo\nUserName\nUserAccount\nUserID\nLSN\nLogonTime\nLogonDate\nPartName\nPEState\nLogonSource\nInternal Sessions\nInternal sessions are a part of the database software and cannot be started or aborted from the client. For example, the operation sending a message from a parser to an AMP is an\ninternal session.\nInternal sessions can cause problems for these reasons:\nInternal sessions may be blocking an important session.\nInternal sessions are hard to recognize.\nInternal sessions may be blocked by other requests.\nInternal sessions that are blocked are reported by MONITOR SESSION. These include:\nInternal sessions associated with the user that show the blocking activity on the user session itself.\nDBQL/Teradata dynamic workload management software artiﬁcial internal sessions that appear in the Monitor Session output and exist only to show blocked DBQL/Teradata\ndynamic workload management software internal express requests.\nFor information on handling blocked DBQL/Teradata dynamic workload management software internal express requests, see DBQL Tables.\nYou must determine what to do about a session that is blocking an important activity.\nThe following ﬁelds (returned by a MONITOR SESSION request) may provide information about internal sessions blocking other sessions:\nBlk_x_H ostId\nBlk_x_S essNo\nBlk_x_U serID\nInternal sessions may not be easily recognized from data returned in Blk_x ﬁelds, any or all of which may be NULL. You may mistake an internal session with a NULL Blk_x_S essNo for\na client utility session. All three ﬁelds can have legitimate-looking values. You can frequently recognize an internal session by a value of zero in the Blk_x_Ho stId ﬁeld, but this is not\nguaranteed, because a Teradata SQL session started from the system Console running DBW has a value of zero in the Blk_x_H ostId ﬁeld.\nThe following matrix provides guidelines for recognizing internal sessions the HostId, SessNo , and UserID Blk_x ﬁelds internal sessions.\nFields and V alues Session T ype\nHostId = NULL\nSessNo = NULL\nUserID = NULLInternal\nHostId = NULL\nSessNo = NULL\nUserID ≠ NULLIdle Client utility\nHostId ≠ NULL\nSessNo ≠ NULL\nUserID ≠ NULLA MONITOR SESSION request does not return a record for an internal session. If you specify internal session in\nan IDENTIFY request to specify the name of the session causing the lock, the session returns an error\nmessage.\nSituation Result\nInternal session is blocking an important session. You cannot stop the internal session.\nInternal session lock request is waiting. You can stop the work of the sessions that are blocking the internal sessions.\nInternal session lock request is granted. You must wait for request to complete.\nLake - Monitor Resources and Performance\nPage 149 of 420CLIv2 Response Parcels\nThe MONITOR SESSION request is treated internally as a multiple statement request with each statement generating a response. The multiple statement response returned from the\ndatabase contains the following sequence of parcel types:\nParcel Sequence Parcel Number Length (Bytes) Comments and Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 84 (PCLMONSESS)\nDataInfo 71 6 to 64100 (Optional). This parcel is present if request was IndicData parcel.\nRecord 10 5 to 64100 (record mode)\n6 to 64100 (indicator mode)Returns data in Record or Indicator mode depending on the request (for example, Data or\nIndicData).\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = -1 or 0\nActivityType = 84 (PCLMONSESS)\nDataInfo 71 6 to 64100 (Optional) This parcel is present if request was IndicData parcel.\nRecord 10 5 to 64100 (record mode)\n6 to 64100 (indicator mode)Returns data in Record or Indicator mode depending on the request (for example, Data or\nIndicData). Contains data describing the session.\nEndStatement 11 6 StatementNo = 2-byte integer, value = 2\nSuccess 8 18 to 273 StatementNo = 3\nActivityType = 84 (PCLMONSESS)\nDataInfo 71 6 to 64100 (Optional) This parcel is present if request was IndicData parcel.\nRecord 10 5 to 64100 (record mode)\n6 to 64100 (indicator mode)Returns data in Record or Indicator mode depending on the request (for example, Data or\nIndicData). Contains blocker data describing the session.\nEndStatement 11 6 StatementNo = 2-byte integer, value = 3\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe response to the ﬁrst statement returns a Record parcel containing the following ﬁelds:\nField/Column Name Data T ype Description\nCollectionInterval SMALLINT\nNOT NULLActual interval in seconds between current and last cache refresh.\nCollectionSeqNum INTEGER\nNOT NULLMonitor session cache refresh sequence number.\nCollectionDate DATE\nNOT NULLDatabase date of when the session cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLDatabase time of when the session cache was last refreshed.\nSessionRate SMALLINT Session rate.\nLake - Monitor Resources and Performance\nPage 150 of 420Field/Column Name Data T ype Description\nNOT NULL\nExceptionInterval SMALLINT\nNOT NULLException interval. If TASM Workloads are disabled, this ﬁeld returns a zero.\nSessionRateThreshold SMALLINT\nNOT NULLThe PMPC_SessionRateThreshold value.\nDBQLFlushRate SMALLINT\nNOT NULLThe DBQLFlushRate value.\nRedriveProtection VARCHAR (2)\nNOT NULLRedrive protection type:\n' ' = No Redrive protection. The session does not participate in Redrive and database\nrestarts are not transparent to applications and users.\nMN = Memory-based Redrive protection, no fallback spools\nStatement 2\nThe response to the second statement returns multiple Record parcels that consist of a record for each session in the system. Records are sorted in order of LogonPENo, HostId, and\nSessionNo.\nResponse Groups\nThe MONITOR SESSION request returns groups of response data ﬁelds or JDBC ResultSet columns. The following table shows the different values returned from mon_ver_id.\nmon_ver_ID Response Group Returned Description\n2 Group I Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned primarily with session-level user status.\n3 Groups I Data Fields and II and JDBC ResultSet Columns In addition, returns data ﬁelds on session-speciﬁc AMP resource usage.\n4 Groups I-III Data Fields and JDBC ResultSet Columns In addition, returns request level usage information.\n5 Groups I-IV Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using IV\n6 Groups I-IV Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using IV.\nThis value is required for Teradata Dynamic Workload Management PM/APIs.\n7 and 8 Groups I-V Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using Group V.\n9 - 11 Groups I - VI Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using VI.\n12 Groups I - VII Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using VII.\n13-14 Groups I - VIII Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using VIII.\n15-16 Groups I - IX Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using IX.\n17 Groups I - X Data Fields and JDBC ResultSet Columns Returns data ﬁelds concerned with Group I using X.\nIf monitor version software ID 10 or later is speciﬁed, object ﬁelds in the input area can be up to 512 bytes in variable length in host character set format. For more information, see\n\"Impact of Object Name Length on PM/API Requests\" in System PMPC PM/APIs.\nGroup I Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group I values.\nField/Column Name Data T ype Description\nHostId SMALLINT Logical host ID associated with a PE or session. For a PE, the Host ID identiﬁes one of the hosts or\nLANs associated with the described PE. For a session, the combination of a Host ID and a session\nnumber uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nLogonPENo SMALLINT\nNOT NULLVproc number of the PE the session is logged on to, which identiﬁes the PE that has control\nresponsibility for the session. Typically, this is the PE that processed the logon request, but if that\nPE goes ofﬂine, this is the PE to which the session was switched.\nRunVprocNo SMALLINT Vproc number of the AMP or PE assigned to process the session requests.\nFor sessions in Teradata SQL partitions, this value is identical to the LogonPENo. For sessions in\nFastLoad or MultiLoad partitions, this is the AMP that initially processes the data being loaded.\nLake - Monitor Resources and Performance\nPage 151 of 420Field/Column Name Data T ype Description\nIf a RunVprocNo value of -1 in record mode or NULL in indicator mode is returned by MONITOR\nSESSION for FastLoad, MultiLoad or FastExport sessions, this indicates that the session is in the\nprocess of starting up.\nSessionNo INTEGER\nNOT NULLNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session\non the database system. This value is assigned by the host (or client) at logon time.\nUserName VARCHAR (128)\nCHARACTER SET UNICODE\nNOT NULLUser name of the session.\nUserAccount VARCHAR (128)\nCHARACTER SET UNICODE\nNOT NULLCurrent account for the session.\nUserID INTEGER\nNOT NULLUser or internal ID of a user for this session. Within the database, UserID is equivalent to Database\nID. Typically, UserID is used when the associated record is known to be a user name, and\nDatabase ID is used when the associated record is known to be a database. However, UserID can\nidentify either a given user or database name.\nLSN INTEGER\nNOT NULLLogon Sequence Number (LSN) associated with session when session logs on. Identiﬁes collection\nof sessions performing related activity. For example, in a FastLoad job, a user is logged on as a\nTeradata SQL session and n FastLoad sessions with the same user name. Therefore, n+1 sessions\n(1 Teradata SQL and n FastLoad) with the same LSN are all associated with the given FastLoad\njob. To see how the FastLoad job is doing, the user can pick out all sessions reported with the\nsame LSN number.\nThis information supplies the parent-child relationship for sessions involved with FastLoad and\nMultiLoad jobs.\nLogonTime FLOAT\nNOT NULLTime portion of the information recorded by Session Control when a session logs on. With\nLogonDate, indicates when the session logged on to the system. T formatted for display as\n99:99:99, which represents hours: minutes: seconds.\nLogonDate DATE\nNOT NULLDate portion of the information recorded by Session Control when a session logs on. With\nLogonTime, indicates when the session logged on to the system.\nPartName VARCHAR (16)\nNOT NULLName of the session partition associated with this session. Following a successful logon request by\na session or as part of a connect request, the session identiﬁes the partition with which the user\nwants the session to be associated. FASTLOAD, Teradata SQL, MONITOR, INTERNAL are\nexamples of valid partition names.\nReserved2 VARCHAR (2) This ﬁeld is not used.\nPEState VARCHAR (18) Current state of the session within the PE. This session describes PARSING, DISPATCHING, and\nMonitor activity. The session states are reported in decreasing priority:\nSession State Meaning\nDELAYED The request is either waiting on a queue table\nfor rows to be inserted in to that table or,\nbecause of a TASM System Throttle and\nSession Control rule, the request is on the\nTeradata dynamic workload management\nsoftware delay queue.\nDEFERRED A request is being deferred by an arrival rate\nmeter rule.\nHOST-RESTART A restart is in progress for the associated host\n(or client).\nABORTING The transaction is being rolled back; the\nsession is ending.\nPARSING-WAIT Waiting for information from the Data Dictionary.\nPARSING The Parser portion of the PE is processing a\nrequest.\nELICIT CLIENT DATA The Dispatcher is eliciting data from the client\nand sending the data to the AMP.\nLake - Monitor Resources and Performance\nPage 152 of 420Field/Column Name Data T ype Description\nSession State Meaning\nDISPATCHING The Dispatcher or Monitor is having a request\nrun.\nBLOCKED Background activity is in progress and the last\nrequest is on hold until this background activity\nis completed.\nACTIVE Normal, on-going activity is being done by this\nsession.\nRESPONSE The Dispatcher is returning query responses to\nthe session.\nIDLE: IN-DOUBT A session using Two-Phase Commit (2PC) is IN-\nDOUBT.\nIDLE No work in progress for this session.\nQTDELAYED A session is delayed due to a Queue Table\nrestriction.\nSESDELAYED A utility session is on the Teradata dynamic\nworkload management software delay queue.\nUNKNOWN The Parser, Dispatcher, and Monitor on the PE\nare unaware of this session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nthat follows either a system outage or a change in the ResMonitor rate.\nPECPUsec FLOAT CPU time, in seconds, used in a PE by the associated session for parsing and dispatching\nrequests. Accurate to the second.\nThis value is valid only when associated with Teradata SQL and MONITOR partition sessions.\nThis value is NULL when returned for all other sessions.\nXActCount FLOAT Number of explicit and implicit transactions run by the session.\nThis value is valid only when returned for Teradata SQL sessions, and is NULL for all other partition\nsessions. For this value, you must make a request for data before completion of the ﬁrst collection\nperiod that follows either a system outage or a change in the ResMonitor rate.\nReqCount FLOAT Number of requests (Tequel Start Request [TSR] messages) initiated by the session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing either a system outage or change in the ResMonitor rate.\nReqCacheHits FLOAT Number of times this session processed a request using information from the Teradata SQL Parser\nrequest cache, speciﬁcally, number of times there was a request cache hit.\nThis value is valid only for Teradata SQL sessions, and is NULL for all other partition sessions. This\nvalue is also NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing either a system outage or a change in the ResMonitor rate.\nLake - Monitor Resources and Performance\nPage 153 of 420Field/Column Name Data T ype Description\nAMPState VARCHAR (18) Current state of the associated session in AMP vprocs in decreasing priority:\nSession State Meaning\nABORTING The transaction is being rolled back; session is\nending.\nBLOCKED Background activity is in progress and the last\nrequest is on hold until this background activity\nis completed.\nACTIVE Normal, on-going activity is being done by this\nsession.\nIDLE No work in progress for this session on any\nAMP.\nUNKNOWN No recorded activity by this session since\nmonitoring began.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nAMPCPUSec FLOAT Current elapsed CPU time, in seconds, used on all AMPs by the associated session for executing\nrequests. For example, for Teradata SQL requests, this is the time spent by the database actively\nworking or rolling back an aborted transaction. This does not include any PDE CPU time spent\nhandling database requests.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing either a system outage or a change in the ResMonitor rate.\nAMPIO FLOAT Current number of logical Reads and Writes issued across all AMPs by the associated session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing either a system outage or a change in the ResMonitor rate.\nRequest_AmpSpool FLOAT Current spool used by current request across all AMPs, expressed in bytes.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period\nfollowing a system outage or a change in the ResMonitor rate.\nBlk_1_HostId,\nBlk_2_HostId,\nBlk_3_HostIdSMALLINT Logical host ID of a session causing a block. This value is derived from equating the transactions\ncausing a database lock conﬂict to the sessions that issued those transactions. The Blk_x_Ho stId,\nin combination with Blk_x_S essNo, uniquely identiﬁes the session that is causing a block.\nThis value is NULL if:\nThe host ID is not available.\nThe session does not have an AMPState of BLOCKED.\nBlk_1_SessNo,\nBlk_2_SessNo,\nBlk_3_SessNoINTEGER Number of the session causing a block. This value is derived from associating the transactions\ncausing a lock conﬂict to the sessions that issued those transactions. The Blk_x_Se ssNo, in\ncombination with Blk_x_H ostId, uniquely identiﬁes the session causing a block.\nThis value is NULL if:\nThe SessNo is not available.\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_1_UserID,\nBlk_2_UserID,\nBlk_3_UserIDINTEGER ID of the user or host utility job preventing the session from being granted a lock. The user ID is the\nonly information available about who placed the lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_1_LMode,\nBlk_2_LMode,\nBlk_3_LModeVARCHAR (1) Mode (severity) of the lock involved in causing a block:\nE = Exclusive\nW = Write\nR = Read\nA = Access\nLake - Monitor Resources and Performance\nPage 154 of 420Field/Column Name Data T ype Description\nLocks are reported in decreasing order of severity because removing the most severe lock conﬂict\nmay eliminate the source of the lock conﬂict.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA session may be blocked by either a granted lock or an ungranted lock that precedes the blocked\nlock in the queue and is in conﬂict with the lock requested by this blocked session. For information\non whether the lock is granted, see the block status MONITOR SESSION ﬁelds (Blk_1_Status,\nBlk_2_Status, and Blk_3_Status) later in this table.\nBlk_1_OType,\nBlk_2_OType,\nBlk_3_OTypeVARCHAR(2) Type of object whose lock is causing the session described by the associated row to be blocked:\nD = Database\nT= Table\nR = Row hash\nTP = Table Partition range\nRP = RowHash in Partition range\nRK = RowHash in one partition\nRN = RowKey range\nHowever, this object is not necessarily the type of object the blocked session is trying to access.\nFor example, if the session is requesting a row hash lock, the blocking object can be a database,\ntable, or row hash.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nFor a Table T, User A can block User B with a table-level lock on Table T on AMP_1 and with a Row\nHash Level lock on that same Table T on AMP_2. When that occurs, the only lock conﬂict reported\nis that User B is blocked by User A on a table.\nBlk_1_ObjDBId,\nBlk_2_ObjDBId,\nBlk_3_ObjDBIdINTEGER Unique ID of the database object over which a lock conﬂict is preventing the session from being\ngranted a lock.\nWithin the database system, Database ID is equivalent to User ID. Typically, User ID is used when\nthe associated record is known to be a user name, and Database ID is used when the associated\nrecord is known to be a database. However, Database ID can identify either a user or database\nname.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_1_ObjTId,\nBlk_2_ObjTId,\nBlk_3_ObjTIdINTEGER Unique ID of the table object over which a lock conﬂict is preventing the session from being\ngranted a lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nThe Blk_x_OT ype is D.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_1_Status,\nBlk_2_Status,\nBlk_3_StatusVARCHAR (1) Status of lock causing a block:\nW= Waiting\nG = Granted\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA lock request may be blocked by either a granted lock or an ungranted lock that precedes the\nblocked lock request in the queue and is in conﬂict with it.\nLake - Monitor Resources and Performance\nPage 155 of 420Field/Column Name Data T ype Description\nA status of Waiting has a higher priority than that of Granted when there is more than one lock\ninvolved. For example, for a given object and a given session, a session that is blocked by a\nWaiting lock on one AMP and a Granted lock on another AMP has Waiting reported as its status.\nMoreBlockers VARCHAR (1) Indicator of more lock conﬂicts:\nBlank = Blk_x information is a complete list of sessions blocking the session described.\nAsterisk (*) = Additional sessions are blocking the session described. In rare cases, the\nblocker information in statement 2 and 3 do not represent a complete list of sessions\nblocking the session described.\nThis value is NULL if:\nThe state of the session is not BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLogonSource VARCHAR (128) Logon source information. At logon time, this information is optionally supplied by the Teradata\nDirector Program or the Gateway to further identify the physical or logical location of the session,\nthe logon user name, and the interface under which the session was initiated. (For example, the\ndata string may include DBC as the user ID and BTEQ as the interface.)\nData strings for TCP/IP sessions are inserted by CLIv2 or the Teradata JDBC Driver, which\ntruncates strings that exceed 128 bytes.\nA two-byte value precedes the LogonSource data to indicate the length of the string. The length\nvalue is zero if LogonSource is NULL.\nTempSpace FLOAT Total amount, in bytes, of temporary space used by the session.\nThis value is NULL if the session did not materialize any temporary tables.\nGroup II Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group II values.\nThe values are NULL if the request is made before the collection period expires.\nField/Column Name Data T ype Description\nHotAmp1CPU FLOAT CPU time of the highest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp2CPU FLOAT CPU time of the second highest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp3CPU FLOAT CPU time of the third highest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs on the system.\nHotAmp1IO FLOAT I/O count of the highest I/O used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp2IO FLOAT I/O count of the second highest I/O used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp3IO FLOAT I/O count of the third highest I/O used AMP for the last collection interval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs in the system.\nHotAmp1CPUId SMALLINT Vproc ID of the highest CPU used AMP for the last session collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp2CPUId SMALLINT Vproc ID of the second highest CPU used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires.\nLake - Monitor Resources and Performance\nPage 156 of 420Field/Column Name Data T ype Description\nHotAmp3CPUId SMALLINT Vproc ID of the third highest CPU used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs in the system.\nHotAmp1IOId SMALLINT Vproc ID of the highest I/O used AMP for the last session collection interval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp2IOId SMALLINT Vproc ID of the second highest I/O used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires.\nHotAmp3IOId SMALLINT Vproc ID of the third highest I/O used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs in the system.\nLowAmp1CPU FLOAT CPU time of the lowest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp2CPU FLOAT CPU time of the second lowest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp3CPU FLOAT CPU time of the third lowest CPU used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs on the system.\nLowAmp1IO FLOAT I/O count of the lowest I/O used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp2IO FLOAT I/O count of the second lowest I/O used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp3IO FLOAT I/O count of the third lowest I/O used AMP during the collection interval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs on the system.\nLowAmp1CPUId SMALLINT Vproc ID of the lowest CPU used AMP for the last session collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp2CPUId SMALLINT Vproc ID of the second lowest CPU used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp3CPUId SMALLINT Vproc ID of the third lowest CPU used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs on the system.\nLowAmp1IOId SMALLINT Vproc ID of the lowest I/O used AMP for the last session collection interval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp2IOId SMALLINT Vproc ID of the second lowest I/O used AMP for the last session collection\ninterval.\nThis value is NULL if the request is made before the collection period expires.\nLowAmp3IOId SMALLINT Vproc ID of the third lowest I/O used AMP for the last session collection\ninterval.\nLake - Monitor Resources and Performance\nPage 157 of 420Field/Column Name Data T ype Description\nThis value is NULL if the request is made before the collection period expires,\nand if there are only two AMPs on the system.\nUpAMPCount SMALLINT Total number of AMPs participating for this session during the last session\ncollection interval.\nThis value is NULL if the request is made before the collection period expires.\nAvgAmpCPUSec FLOAT Average AMP CPU usage for the last session collection interval. The average\nis calculated as the sum of CPU usage for all AMPs participating divided by\nthe number of online AMPs.\nThis value is NULL if the request is made before the collection period expires.\nAvgAmpIOCnt FLOAT Average AMP I/O usage for the last session collection interval. The average is\ncalculated as the sum of I/O usage for all AMPs participating divided by the\nnumber of online AMPs.\nThis value is NULL if the request is made before the collection period expires.\nGroup III Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group III values.\nField/Column Name Data T ype Description\nRequestStartTime FLOAT Time of the current request on the session started.\nRequestStartDate DATE Date of the current request on the session started.\nRequestAmpCPU FLOAT Total CPU usage by the current SQL request on the session on all AMPs. This value contains proper\nrequest-level statistics for DBC/SQL sessions running SQL requests only. Ignore the value returned in\nthis ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nThis ﬁeld is equivalent to the MonitorSession ReqCPU ﬁeld.\nRequestAmpI/O FLOAT Total number of accesses by the current SQL request on the session on all AMPs.\nThis value contains proper request-level statistics for DBC/SQL sessions running SQL requests only.\nIgnore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to\na utility job.\nThis ﬁeld is equivalent to the MonitorSession ReqIO ﬁeld.\nGroup IV Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group IV values.\nField/Column Name Data T ype Description\nRequest Number INTEGER Active request number.\nIf no request is running, this ﬁeld displays a value of zero or NULL in indicator mode.\nIn the early phase of a request in parsing state, when PEState = PARSING, the request number\nmay not be available and may be returned as zero or NULL. The active request number is\navailable on the next collection.\nWDId INTEGER Workload ID associated with the speciﬁed request.\nClassiﬁcation Mode SMALLINT Indicator if a running query or session or future queries are forced into a WD.\nThe classiﬁcation mode is valid only for DBC/SQL sessions and if the Teradata dynamic\nworkload management software is enabled. If enabled, the Teradata dynamic workload\nmanagement software classiﬁes all incoming queries into a WD.\nIf the Teradata dynamic workload management software is enabled, the value is one of the\nfollowing:\n0 = Automatic\n1 = Manual at Request Level\n2 = Manual at Session Level\nLake - Monitor Resources and Performance\nPage 158 of 420Field/Column Name Data T ype Description\nIf the Teradata dynamic workload management software is disabled and the DBC/SQL session\nis not a valid session, the value is 255 or NULL.\nGroup V Data Field and JDBC ResultSet Columns\nThe Record returns the following Group V value.\nField/Column Name Data T ype Description\nProxyUser VARCHAR (128)\nCHARACTER SET UNICODEName of a proxy user in a trusted session.\nGroup VI Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group VI values.\nField/Column Name Data T ype Description\nCPUDecayLevel SMALLINT Current most severe decay level as reached due to CPU usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nIODecayLevel SMALLINT Current most severe decay level as reached due to I/O usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nTacticalCPUException INTEGER Number of nodes that encountered a CPU exception.\nTacticalIOException INTEGER Number of nodes that encountered an I/O exception.\nReqIOKB FLOAT Total logical I/O usage in KB.\nReqPhysIO FLOAT Number of physical I/Os.\nReqPhysIOKB FLOAT Physical I/O usage in KB.\nReqStepsCompletedCnt INTEGER Count of completed steps for the current request. If there is no change in the\nReqStepsCompletedCnt ﬁeld from the previous Monitor Session collection, this indicates\nthat there are no new steps completed.\nCurrentRedriveParticipation VARCHAR (1) Indicates if the session is participating in Redrive. Sessions that use Redrive can enable\nor disable the functionality using the REDRIVE reserved query band. Possible values:\nT = Redrive functionality is enabled (database restarts are transparent to\napplications and users)\nF = Redrive functionality is disabled (database restarts are not transparent to\napplications and users)\nReqRedriveSpoolSpace FLOAT Persistent spool space for the current request.\nBlockerSessionCnt SMALLINT Total number of blocker sessions. If there are more than three blocker sessions, this ﬁeld\nreturns the blocking sessions in one or more record parcels in statement 3.\nThis ﬁeld returns only the ﬁrst three blocking sessions in statement 2.\nThis output parameter is available on monitor software version ID 11 or later.\nReqTblOpBytesIn FLOAT The total number of bytes transferred into the database from a foreign server for the\ncurrent request using one or more table operators.\nThe request may involve one or multiple table operator executions. The\nReqTblOpBytesIn output parameter shows bytes transferred across all invocations\nwithin the request.\nThis output parameter is available on monitor software version ID 11 or later.\nReqTblOpBytesOut FLOAT The total number of bytes transferred out of the database and into a foreign server for the\ncurrent request using one or more table operators.\nThe request may involve one or multiple table operator executions. The\nReqTblOpBytesOut output parameter shows bytes transferred across all\ninvocations within the request.\nThis output parameter is available on monitor software version ID 11 or later.\nGroup VII Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group VII values.\nLake - Monitor Resources and Performance\nPage 159 of 420Field/Column Name Data T ype Description\nProxyUserId INTEGER\nNULLABLEThe user ID charged for SPOOL and TEMP space if being charged to the proxy user.\nZoneId INTEGER\nNULLABLEThe unique identiﬁer of the zone.\nReqHotAmpCPU FLOAT The CPU time of the highest CPU used AMP during the life of the current request on the\nsession.\nThis value is NULL if there is no request running on the session.\nReqHotAmpCPUId SMALLINT Vproc ID of the highest CPU used AMP for the current request.\nThis value is NULL if no request is running on the session.\nReqHotAmpIO FLOAT I/O count of the highest I/O used AMP during the life of the current request on the\nsession.\nThis value is NULL if there is no request running on the session.\nReqHotAmpIOId SMALLINT Vproc ID of the highest I/O used AMP for the current request.\nThis value is NULL if there is no request running on the session.\nReqInvolvedAMPCnt SMALLINT The number of AMPs involved in processing the current request.\nThis value is NULL if there is no request running on the session.\nReqFirstRespTime FLOAT Time that the ﬁrst response of the current request on the session is ready. The response\nmay be held to meet the TASM Minimum Response Time.\nThis value is NULL if there is no request running on the session or the PE state is not\nRESPONSE.\nReqFirstRespDate DATE Date that the ﬁrst response of the current request on the session is ready. The response\nmay be held to meet the TASM Minimum Response Time.\nThis value is NULL if there is no request running on the session or the PE state is not\nRESPONSE.\nReqLocalQueryStatus SMALLINT The current state of the Uniﬁed Data Architecture (UDA) query.\nThis value is NULL when no UDA query is running.\nReqRemoteHostId SMALLINT Host ID of the remote system.\nThis value is NULL when there is no UDA query running.\nReqRemoteSessionId INTEGER Session ID of the executing remote query.\nThis value is NULL when there is no UDA query running.\nReqRemoteRequestId INTEGER Request ID of the executing remote query.\nThis value is NULL when there is no UDA query running.\nReqRemoteQueryId FLOAT Query ID of the executing remote query.\nThis value is NULL when there is no UDA query running.\nGroup VIII Data Fields and JDBC ResultSet Columns\nThe Record returns the following Group VIII values.\nLake - Monitor Resources and Performance\nPage 160 of 420Field/Column Name Data T ype Description\nReqHotAmpSpool FLOAT Spool value of the highest spool used AMP during the life of the current request on the\nsession.\nThis value is NULL if no request is running on the session.\nReqHotAmpSpoolId SMALLINT Vproc ID of the highest spool used AMP for the current request.\nThis value is NULL if no request is running on the session.\nReqMapNo SMALLINT Map number for the largest map the request is using.\nReqMaxNumMapAMPs INTEGER Number of AMPs in the largest contiguous map used by the request.\nReqMinNumMapAMPs INTEGER Number of AMPs in the smallest contiguous map used by the request.\nReqSysDefNumMapAMPs INTEGER Number of AMPs in the system-default map used by the request.\nReqRemoteHostIp VARCHAR(128) Host IP address of the remote system.\nReqServerName VARCHAR(128) Name of the foreign server.\nReqFlexReleased SMALLINT The TDWM Flex Throttle feature detects available system resources, overrides existing\nworkload throttle limits, and automatically releases queries from the delay queue. This\nminimizes the DBA manually managing the TASM delay queue. Only Workload throttles are\noverridden; all System level throttles are still honored.\nReturn values:\n0: Indicates that the request was not released by TDWM Flex Throttles.\n1: Indicates that the request was released by TDWM Flex Throttles.\nReqAdmissionTime FLOAT Time that the current request was admitted into the system by workload management (after\nbeing checked for applicable arrival rate meters).\nReqAdmissionDate DATE Date that the current request was admitted into the system by workload management (after\nbeing checked for applicable arrival rate meters).\nReqQueryIDHigh INTEGER High 32 bits of the Query ID.\nQueryID can be constructed as:\n((unsigned long) ReqQueryIDHigh << 32 | (unsigned int) ReqQueryIDLow)\nReqQueryIDLow INTEGER Lower 32 bits of the Query ID.\nQueryID can be constructed as:\n((unsigned long) ReqQueryIDHigh << 32 | (unsigned int) ReqQueryIDLow)\nGroup IX Data Fields and JDBC ResultSetColumns\nField/Column Name Data T ype Description\nComputeWorkerInUse VARCHAR(1) Returns 'T' if the current request is using the Compute\nWorker AMPs. Returned only when the monitor version is\n15 and above. Older applications with previous monitor\nversion numbers do not see this ﬁeld.\nGroup X Data Fields and JDBC ResultSetColumns\nField/Column Name Data T ype Description\nReqQueryIDHigh INTEGER High 32 bits of the Query ID.\nQueryID can be constructed as:\n((unsigned long) ReqQueryIDHigh << 32 | (unsigned int) ReqQueryIDLow)\nReqQueryIDLow INTEGER Lower 32 bits of the Query ID.\nQueryID can be constructed as:\n((unsigned long) ReqQueryIDHigh << 32 | (unsigned int) ReqQueryIDLow)\nStatement 3\nThis statement returns additional blocker sessions. If more than three sessions are blocking the session, the ﬁrst three blocker sessions are listed in statement 2 and the remaining\nblocker sessions are listed in statement 3. Each record parcel holds one blocker information set. Record parcels are returned in statement 3 for a speciﬁed session that has more than\nLake - Monitor Resources and Performance\nPage 161 of 420three blocking sessions.\nFor more information about the ﬁrst three blocker sessions, see the \"Statement 2\" section in this topic.\nField/Column Name Data T ype Description\nHostId SMALLINT Logical host ID of the blocked session.\nSessionNo INTEGER,\nNOT NULLSession number of the blocked session that has more than three blocker sessions. The ﬁrst three\nblocker sessions are listed in statement 2 and the remaining blocker sessions are listed in\nstatement 3.\nBlk_HostId SMALLINT Logical host ID of a session causing a block. This value is derived from equating the transactions\ncausing a database lock conﬂict to the sessions that issued those transactions. The Blk_Ho stId, in\ncombination with Blk_SessNo, uniquely identiﬁes the session that is causing a block.\nThis value is NULL if:\nThe host ID is not available.\nThe session does not have an AMPState of BLOCKED.\nBlk_SessNo INTEGER Number of the session causing a block. This value is derived from associating the transactions\ncausing a lock conﬂict to the sessions that issued those transactions. The Blk_Se ssNo, in\ncombination with Blk_HostId, uniquely identiﬁes the session causing a block.\nThis value is NULL if:\nThe SessNo is not available.\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_UserID INTEGER ID of the user or host utility job preventing the session from being granted a lock. The user ID is the\nonly information available about who placed the lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_LMode VARCHAR (1) Mode (severity) of the lock involved in causing a block:\nE = Exclusive\nW = Write\nR = Read\nA = Access\nLocks are reported in decreasing order of severity because removing the most severe lock conﬂict\nmay eliminate the source of the lock conﬂict.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA session may be blocked by either a granted lock or an ungranted lock that precedes the blocked\nlock in the queue and is in conﬂict with the lock requested by this blocked session. For information\non whether the lock is granted, see the Blk_Status ﬁeld.\nBlk_OType VARCHAR(2) Type of object whose lock is causing the session described by the associated row to be blocked:\nD = Database\nT= Table\nR = Row hash\nTP = Table Partition range\nRP = RowHash in Partition range\nRK = RowHash in one partition\nRN = RowKey range\nHowever, this object is not necessarily the type of object the blocked session is trying to access.\nFor example, if the session is requesting a row hash lock, the blocking object can be a database,\ntable, or row hash.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLake - Monitor Resources and Performance\nPage 162 of 420Field/Column Name Data T ype Description\nFor a Table T, User A can block User B with a table-level lock on Table T on AMP_1 and with a Row\nHash Level lock on that same Table T on Blk_LMode. When that occurs, the only lock conﬂict\nreported is that User B is blocked by User A on a table.\nBlk_ObjDBId INTEGER Unique ID of the database object over which a lock conﬂict is preventing the session from being\ngranted a lock.\nWithin the database system, Database ID is equivalent to User ID. Typically, User ID is used when\nthe associated record is known to be a user name, and Database ID is used when the associated\nrecord is known to be a database. However, Database ID can identify either a user or database\nname.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_ObjTId INTEGER Unique ID of the table object over which a lock conﬂict is preventing the session from being\ngranted a lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nThe Blk_OType is D.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk_Status VARCHAR (1) Status of lock causing a block:\nW= Waiting\nG = Granted\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a\nsystem outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA lock request may be blocked by either a granted lock or an ungranted lock that precedes the\nblocked lock request in the queue and is in conﬂict with it.\nA status of Waiting has a higher priority than that of Granted when there is more than one lock\ninvolved. For example, for a given object and a given session, a session that is blocked by a\nWaiting lock on one AMP and a Granted lock on another AMP has Waiting reported as its status.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR SESSION request, built by CLIv2, appear when sent to the database server using a host_id of 387, a session_no of 1098, and a\nuser_name of WEEKLY. In this example, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum NameBytesField Value\n0001 Req 19 Request MONITOR SESSION\n0003 Data 42 MonVerID 10\nHostId 387\nSessionNo 1098\nUserName WEEKLY\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output - MONIT OR SESSION Statements 1 through 3\nUsing monitor software version ID 13, this request returns the following values for statements 1 through 3.\nLake - Monitor Resources and Performance\nPage 163 of 420HostId:        1   SessionNo: 1006\nLogonPENo: 30718   RunVprocNo: 30718\nPartName: DBC/SQL                         PEState:  DISPATCHING\nLogonDate/Time:  04/29/2016 11:26:46.00\nUserID: 1028 LSN: 0\nUserName: [JCK]\nUserAccount: [DBC]\nPECPUSec:       0.02   XactCount:          1.00\nReqCount:        2.0   ReqCacheHits:        0.0\nAMPState: ACTIVE\nAMPCPUSec:     13.60   AMPIO: 4606.00\nRequest_AMPSpool: 491517952.0\nBlk_1_HostId:      0   Blk_2_HostId:      0   Blk_3_HostId:      0\nBlk_1_SessNo:      0   Blk_2_SessNo:      0   Blk_3_SessNo:      0\nBlk_1_UserID:      0   Blk_2_UserID:      0   Blk_3_UserID:      0\nBlk_1_LMode:        Blk_2_LMode:        Blk_3_LMode:\nBlk_1_OType:        Blk_2_OType:        Blk_3_OType:\nBlk_1_ObjDBId:     0   Blk_2_ObjDBId:     0   Blk_3_ObjDBId:     0\nBlk_1_ObjTId:      0   Blk_2_ObjTId:      0   Blk_3_ObjTId:      0\nBlk_1_Status:       Blk_2_Status:       Blk_3_Status:\nMoreBlockers:\nLogonSource: (TCP/IP) f1a3 153.64.183.39 MYSYSTEM      9964  JK121219  BTEQ  01 LSS\nHotAmp1CPU:      3.43   HotAmp2CPU:      3.40   HotAmp3CPU:      3.40\nHotAmp1CPUId:       3   HotAmp2CPUId:       2   HotAmp3CPUId:       0\nHotAmp1IO:    1158.00   HotAmp2IO:    1152.00   HotAmp3IO:    1152.00\nHotAmp1IOId:        3   HotAmp2IOId:        2   HotAmp3IOId:        1\nLowAmp1CPU:      3.38   LowAmp2CPU:      3.40   LowAmp3CPU:      3.40\nLowAmp1CPUId:       1   LowAmp2CPUId:       2   LowAmp3CPUId:       0\nLowAmp1IO:    1144.00   LowAmp2IO:    1152.00   LowAmp3IO:    1152.00\nLowAmp1IOId:        0   LowAmp2IOId:        1   LowAmp3IOId:        2\nAvgAmpCPUSec:    3.40   AvgAmpIOCnt:  1151.50\nAmpCount:           4\nTempSpaceUsg:    0.00\nReqStartTime:  04/29/2016 11:26:46.00\nReqCPU:      13.60  ReqIO:    4606.00\nReqNo:3   WlcId: 13     DontReclassifyFlag: 0\nProxyUser: []\nProxyUserID: 0\nCPUDecayLevel=0,  IODecayLevel=0,  TacticalCPUException=0, TacticalIOException=0\nReqIOKB=541295      , ReqPhysIO=661         , ReqPhysIOKB=268502\nReqStepsCompletedCnt=9\nCurrentRedriveParticipation=[F]\nReqRedriveSpoolSpace=0.00\nBlockerSessionCnt = 0\nReqTblOpBytesIn = 0           , ReqTblOpBytesOut = 0\nZoneId = 0\nReqHotAmpCPU =       3.43 ReqHotAmpCPUId = 3\nReqHotAmpIO =    1158.00 ReqHotAmpIOId = 3\nReqInvolvedAMPCnt = 4\nReqFirstResp Date/Time= 00/00/0000 00:00:00.00\nReqLocalQueryStatus = 0\nReqRemoteHostId = 0, ReqRemoteSessionId = 0\nReqRemoteRequestId = 0, ReqRemoteQueryId = 0\nReqRemoteHostIp:\nLake - Monitor Resources and Performance\nPage 164 of 420ReqServerName:\nReqHotAmpSpool = 123837952.00 ReqHotAmpSpoolId = 3\nReqMapNo = 0,   ReqMaxNumMapAMPs = 0\nReqMinNumMapAMPs = 0,   ReqSysDefNumMapAMPs = 0\nReqFlexReleased = N (0)\nSample Output: MONIT OR SESSION Statements 1 and 2: Indicator Mode\nStmt #1 ** Data Info ** Field Count: 9 \nField 1) [CollectionInterval]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 2) [CollectionSeqNum]:  INTEGER NOT NULL         Type = 496 (496) Size = 4 (4) \nField 3) [Collectiondate]:  DATE NOT NULL            Type = 752 (752) Size = 4 (4) \nField 4) [CollectionTime]:  FLOAT NOT NULL           Type = 480 (480) Size = 8 (8) \nField 5) [SessionRate]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 6) [ExceptionInterval]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 7) [SessionRateThreshold]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 8) [DBQLFlushRate]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 9) [RedriveProtection]:  VARCHAR NOT NULL         Type = 448 (448) Size = 10 (10) \n***** Stmt #1    Record Count: 1 *****\nRECORD #1:\nField 1) [CollectionInterval] = 125\nField 2) [CollectionSeqNum] = 5965\nField 3) [Collectiondate] = 1240207\nField 4) [CollectionTime] =   82907.00\nField 5) [SessionRate] = 60\nField 6) [ExceptionInterval] = 0\nField 7) [SessionRateThreshold] = 60\nField 8) [DBQLFlushRate] = 600\nField 9) [RedriveProtection] = [MN]\nStmt #2 ** Data Info ** Field Count: 122 \nField 1) [HostId]: SMALLINT NULLABLE        Type = 501 (501) Size = 2 (2) \nField 2) [LogonProcId]:  SMALLINT NOT NULL        Type = 500 (500) Size = 2 (2) \nField 3) [RunProcId]: SMALLINT NULLABLE        Type = 501 (501) Size = 2 (2) \nField 4) [SessionNo]: INTEGER NOT NULL         Type = 496 (496) Size = 4 (4) \nField 5) [UserName]: VARCHAR NOT NULL         Type = 448 (448) Size = 514 (514) \nField 6) [UserAccount]:  VARCHAR NOT NULL         Type = 448 (448) Size = 514 (514) \nField 7) [UserId]: INTEGER NOT NULL         Type = 496 (496) Size = 4 (4) \nField 8) [LSN]: INTEGER NOT NULL         Type = 496 (496) Size = 4 (4) \nField 9) [LogonTime]: FLOAT NOT NULL           Type = 480 (480) Size = 8 (8) \nField 10) [LogonDate]: DATE NOT NULL            Type = 752 (752) Size = 4 (4) \nField 11) [PartName]: VARCHAR NOT NULL         Type = 448 (448) Size = 66 (66) \nField 12) [Priority]: VARCHAR NOT NULL         Type = 448 (448) Size = 10 (10) \n.\n.\n.\nField 114) [ReqMaxNumMapAMPs]:  INTEGER NULLABLE         Type = 497 (497) Size = 4 (4) \nField 115) [ReqMinNumMapAMPs]:  INTEGER NULLABLE         Type = 497 (497) Size = 4 (4) \nField 116) [ReqSysDefNumMapAMPs]:  INTEGER NULLABLE         Type = 497 (497) Size = 4 (4) \nField 117) [ReqRemoteHostIp]:  VARCHAR NULLABLE         Type = 449 (449) Size = 514 (514) \nField 118) [ReqServerName]:  VARCHAR NULLABLE         Type = 449 (449) Size = 514 (514) \nField 119) [ReqFlexReleased]:  SMALLINT NULLABLE        Type = 501 (501) Size = 2 (2) \nField 120) [ReqAdmissionTime]:  FLOAT NULLABLE           Type = 481 (481) Size = 8 (8) \nField 121) [ReqAdmissionDate]:  DATE NULLABLE            Type = 753 (753) Size = 4 (4) \nField 122) [ComputeWorkerInUse]:  VARCHAR NULLABLE         Type = 449 (449) Size = 6 (6) \nField 123) [ReqQueryIDHigh]:  INTEGER NULLABLE         Type = 497 (497) Size = 4 (4) \nField 124) [ReqQueryIDLow]:  INTEGER NULLABLE         Type = 497 (497) Size = 4 (4) \n***** Stmt #2    Record Count: -1 *****\nRECORD #1:\nField 1) [HostId] = 1\nField 2) [LogonProcId] = 30719\nField 3) [RunProcId] = 30719\nField 4) [SessionNo] = 1021\nLake - Monitor Resources and Performance\nPage 165 of 420Field 5) [UserName] = [DBC]\nField 6) [UserAccount] = [DBC]\nField 7) [UserId] = 1\nField 8) [LSN] = 0\nField 9) [LogonTime] =   84738.00\nField 10) [LogonDate] = 1240207\nField 11) [PartName] = [MONITOR]\nField 12) [Priority] = [(null)]\n.\n.\n.\nField 114) [ReqMaxNumMapAMPs] = (null)\nField 115) [ReqMinNumMapAMPs] = (null)\nField 116) [ReqSysDefNumMapAMPs] = (null)\nField 117) [ReqRemoteHostIp] = [(null)]\nField 118) [ReqServerName] = [(null)]\nField 119) [ReqFlexReleased] = (null)\nField 120) [ReqAdmissionTime] = (null)\nField 121) [ReqAdmissionDate] = (null)\nField 122) [ComputeWorkerInUse] = [F]\nField 123) [ReqQueryIDHigh] = (null)\nField 124) [ReqQueryIDLow] = (null)\nRelationship between MONIT OR SESSION and ABORT SESSION\nWhen sessions are being ended or sessions are being blocked by the sessions being ended, data returned from subsequent MONITOR SESSION queries may be affected. After the\nending operation starts, you can immediately notice the changes from ending sessions. However, you do not notice the changes resulting from sessions that were blocked by ending\nsessions in MONITOR SESSION responses until the ending operation is complete.\nFor information on this PMPC PM/API request relationship, see \"Relationship between ABORT SESSION and MONITOR SESSION\" in ABORT SESSION.\nRelationship between MONIT OR SESSION and IDENTIFY\nPM/API can report on locks placed by any user or object with the MONITOR SESSION and IDENTIFY requests. The MONITOR SESSION request helps you identify the types of locks\nblocking a session.\nFor information on this PMPC PM/API request relationship, see \"Relationship Between IDENTIFY and MONITOR SESSION\" in IDENTIFY.\nRelationship between MONIT OR SESSION and SET SESSION RA TE\nYou must run the SET SESSION RATE request to activate session-level data collection before you run a MONITOR SESSION request. Therefore, either the global rate or local rate must\nbe set to nonzero. If both rates are set to zero, an error message is returned.\nA change in the global session rate may affect the data reported by a MONITOR SESSION request. Speciﬁcally, if User A makes a change in the global rate, this change can affect the\nviewing for User B of displayed data from a MONITOR SESSION request. Unless User B is aware of the rate change, User B may draw incorrect conclusions from the observed data.\nUser B gets a warning message when executing a MONITOR SESSION request.\nExample: Using SET SESSION RA TE and MONIT OR SESSION\nThe following example is a single user on a system that uses the SET SESSION RATE and MONITOR SESSION requests.\n1. User Morris uses the SET SESSION RATE request to set a session-level global rate of 600 seconds (or 10 minutes) at 9:00 a.m. The data time-stamp was set at 9:00 a.m.\nbecause that was the last time data was requested.\n2. Morris then uses the SET SESSION RATE request to set a session-level local rate of 300 seconds (5 minutes) at 9:05 a.m. Morris does not make a request for data at this time.\nTherefore, the time-stamp is still set at 9:00 a.m.\n3. Morris runs a MONITOR SESSION request at 9:08 a.m. for host_id of 510 and a session_no of 1000:\nMONITOR SESSION 2 510 1000\n4. A collection occurs because the “current” data was not considered current (that is, the age of the data is greater than the session collection rate). The system calculates that\n9:08 a.m. (current time) - 9:00 a.m. (time-stamp) = 8 minutes, which is the age of the data. The 8 minutes is greater than 5 minutes, which is the local collection rate. Because of\nthe forced update, Morris gets 8 minutes of data (from 9:00 a.m. to 9:08 a.m.), and the time-stamp is reset to 9:08 a.m.\n5. At 9:10 a.m., Morris decides to make another MONITOR SESSION request. This time, no collection occurs, because the “current” available data was considered current. The\nsystem calculates that 9:10 a.m. (current time) - 9:08 a.m. (time-stamp) = 2 minutes (age of the data), which is less than 5 minutes (local collection rate). Therefore, the current\ndata available is considered current, because no data update to the session-level memory repository occurs. Morris gets the same data that was returned at 9:08 a.m.\nTwo other events can cause data to be collected:\nEvent Comments\nA default system timer of 10 minutes has elapsed without a request from a\nuser.Whenever 10 minutes has expired without a collection, the system timer causes a default collection to\noccur. This causes data in the main memory repository to be updated, even if no request is made.\nLake - Monitor Resources and Performance\nPage 166 of 420Event Comments\nWhen the AMP Session Cache is full A full AMP Session Cache forces an update of data in the main memory repository. This is a rare\noccurrence.\nMONIT OR SQL\nReturns the step information (that is, a scaled-down version of the output of the EXPLAIN request modiﬁer) of the current or running request for the speciﬁed host, session, and vproc.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 3 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT\nNOT NULLLogical ID of a host (or client) with sessions logged on. host_id cannot exceed 1023 bytes. A host _id of\nzero identiﬁes the system Console ID of the host on which the sessions are running.\nsession_no INTEGER\nNOT NULLSession number. The session number combined with the host_id represents a unique session ID.\nRunPEVprocNo SMALLINT\nNOT NULLPE vproc number where the session runs. This is typically from the MONITOR SESSION response of the\nRunVprocNo ﬁeld. See the MONITOR SESSION RunVprocNo ﬁeld for more information.\nMonitor Privileges\nTo use this request, you must have the MONSESSION privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR SQL\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nWhen issuing a MONITOR SQL request, you must specify a minimum buffer size of 32,007 bytes or more. For custom applications, an error message may appear.\nThe MONITOR SQL request can be used in the following ways:\nA problematic query is using a large amount of system resources. Use of this feature provides the associated SQL text to the system administrator to help identify possible\nbottlenecks, hardware problems and bugs. The query text and DDL statements can also be forwarded to Teradata Support for help in diagnosing the problem.\nThe information provided by this request can help to identify speciﬁc SQL problems, such as poorly structured tables and indexes.\nProblems can even be traced down to the individual step within a query.\nThe MONITOR SQL request may not be used on internal sessions or sessions that are logged onto the monitor. Request text and steps text are not stored for these types of sessions,\nand if an attempt is made to query one, an error is returned, indicating that the session is not an SQL session.\nEnding processing is handled in the same way as when using the MONITOR SESSION request. See MONITOR SESSION.\nIf MONITOR SQL processing is not completed within the timeout interval, an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, an error is returned.\nThe default timeout interval is 60 seconds.\nMONITOR SQL is most useful when used with the MONITOR VIRTUAL SUMMARY request for doing a quick overall system health check. For more information, see Relationship\nBetween MONITOR VIRTUAL CONFIG and MONITOR VIRTUAL SUMMARY.\nCLIv2 Response Parcels\nLake - Monitor Resources and Performance\nPage 167 of 420The MONITOR SQL request is treated internally as a three statement request, with each statement generating a response. The three-statement response returned from the database\ncontains the following sequence of parcel types:\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = -1\nActivityType = 110 (PCLMONSQL)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. This\nrecord contains the text of the SQL request (see Statement 1).\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = 1\nActivityType = 110 (PCLMONSQL)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. This\nrecord contains step count information (see Statement 2).\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 3\nActivityCount = Number of EXPLAIN steps\nActivityType = 110 (PCLMONSQL)\nDatainfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. Each\nrecord contains step resource information (see Statement 3).\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe response to the ﬁrst statement returns a Record parcel that contains the SQL request text.\nField/Column Name Data T ype Description\nRequestText VARCHAR (64000) Actual SQL request for a speciﬁed session.\nA RequestText of 64001 bytes or more splits into multiple records. A variable number of characters\nup to 64000 is returned depending on the character set of the session. If needed, the request\ncontext is split into multiple rows such that each row does not exceed 64000 bytes.\nStatement 2\nThe response to the second statement returns information regarding the total number of steps and which steps are executing.\nLake - Monitor Resources and Performance\nPage 168 of 420Field/Column Name Data T ype Description\nNumOfSteps SMALLINT\nNOT NULLNumber of steps contained in the description text in the third statement of the response.\nIf this is a static plan (that is, when the DynamicPlan ﬁeld value is zero), NumOfSteps is the total\nnumber of steps for the static plan.\nIf this is a complete dynamic plan (that is, when the DynamicPlan ﬁeld value is 1 and the\nPartialSteps ﬁeld value is zero), NumOfSteps is the total number of steps for the dynamic plan.\nIf this is a partial dynamic plan (that is, when both of the DynamicPlan and PartialSteps ﬁeld values\nare 1), NumOfSteps is the total number of steps generated. This value is less than the total number\nof steps generated for the entire dynamic plan.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (that is,\nwhen the DynamicPlan and PartialSteps ﬁeld values are 1 and no rows are returned in response to\nthe third statement), NumOfSteps is zero.\nFor more information, see the MONITOR SQL DynamicPlan and PartialSteps ﬁelds.\nCurLev1StepNum SMALLINT\nNOT NULLNumber of the running level 1 step. If parallel steps are running, this value is the number of the\nlowest executing step.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for\nexample, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are PartialSteps ﬁeld\nvalues are 1), the CurLev1StepNum ﬁeld value is zero.\nCurLev2StepNum SMALLINT\nNOT NULLNumber of the running step. If parallel steps are running, this value is the number of the highest\nexecuting step.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for\nexample, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are PartialSteps ﬁeld\nvalues are 1), the CurLev2StepNum ﬁeld value is 1.\nDynamicPlan SMALLINT Plan type:\n0 = Static plan\n1 = Dynamic plan\nFor more information on static and dynamic explanations of a request, see EXPLAIN Request\nModiﬁer or EXPLAIN Request Modiﬁer.\nPartialSteps SMALLINT Possible values:\n0 = All steps are returned\n1 = Partial plan or no plan is returned\nIf a partial plan is returned, this indicates the steps for the ﬁnal plan fragment of the\ndynamic explanation of the request has not yet been generated.\nIf no plan is returned, this indicates the request has been throttled and is in the delay\nqueue.\nA value 1 cannot occur for a static plan.\nSee STATIC EXPLAIN and DYNAMIC EXPLAIN.\nZoneId INTEGER\nNULLLABLEThe unique identiﬁer of the zone.\nSPName VARCHAR(128)\nCHARACTER SET UNICODEThis is the outer stored procedure name, if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nSPDBName VARCHAR(128)\nCHARACTER SET UNICODEThis is the owner database name of the outer stored procedure, if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nDefaultDBName VARCHAR(128)\nCHARACTER SET UNICODE\nNOT NULLThis ﬁeld returns the default database name of the session at the start of a non-stored procedure\nrequest. For stored procedures, this ﬁeld returns the default database name of the session when\nthe stored procedure was compiled.\nIf only one step is executing, CurLevlStepNum and CurLEv2StepNum are identical.\nLake - Monitor Resources and Performance\nPage 169 of 420Statement 3\nThe response to the third statement returns a Record parcel that contains the step text for a given request. Each step returns a separate row. This parcel description has changed from\nthe version 3 parcel. The response parcel received is contingent on whether you set mon_ver_id 3 or mon_ver_id 4. The values returned vary in format and content depending on the\nvalue of mon_ver_id used.\nIf mon_ver_id 3 is set, the response to the third statement returns a Record parcel that contains the following steps text for a given request.\nField/Column Name Data T ype Description\nStepNum SMALLINT\nNOT NULLUnique number identifying the EXPLAIN step.\nStepText VARCHAR (2048) CHARACTER SET\nUNICODE\nNOT NULLGenerated text of the step.\nIf mon_ver_id 4 is set, the response to the third statement returns a Record parcel that contains the following steps text for a given request.\nField/Column Name Data T ype Description\nStepNum SMALLINT\nNOT NULLUnique number identifying the EXPLAIN step.\nConﬁdence SMALLINT\nNOT NULLConﬁdence level as determined by the optimizer:\n0 = None\n1= Foreign Key\n2 = Low\n3 = High\nEstRowCount FLOAT\nNOT NULLEstimated row count generated from the Optimizer plan for this step.\nFor a hybrid join method, also called a partial redistribution and partial duplication (PRPD) plan, the\nEstRowCount ﬁeld for the split step (that is, a RETRIEVE or JOIN step with “split into” appearing in the\nEXPLAIN when target spools are generated) is the estimated row counts for all split spools.\nSee Join Strategies and Methods.\nActRowCount FLOAT\nNOT NULLActual row count returned from the AMP for this step. For a PRPD plan, this value includes rows from all\nsplit spools for a split step.\nSee Join Strategies and Methods.\nEstElapTime FLOAT\nNOT NULLEstimated time for the query as generated from the Optimizer plan.\nActElapTime FLOAT\nNOT NULLActual elapsed time calculated by the dispatcher.\nStepText VARCHAR (2048)\nCHARACTER SET UNICODE\nNOT NULLGenerated text of the step.\nThe estimated ﬁelds populate immediately. The low value supplied by the optimizer is used. The actual ﬁelds are populated at the same time with \"-1\". After the step runs, the actual\nvalues (or a zero for those kinds of steps with no row count) are placed in the actual ﬁelds to identify those steps that are run at the time of the API information capture.\nIf the request has been throttled and is in the delay queue (that is, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are PartialSteps ﬁeld values are 1), the response\nto this statement returns no rows. See Statement 2.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR SQL request, built by CLIv2, appear when sent to the database server. In this example, the size of the response buffer is set at the\nmaximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\nLake - Monitor Resources and Performance\nPage 170 of 420Number Length Body\n0001 Req 16 Request MONITOR SQL\n0003 Data 12 MonVerID\nHostId\nSessionNo\nRunPEVprocNo3\n1\n1002\n16383\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis example shows the values returned in character text format for the MONITOR SQL request. Your application program may display returned values in a different format.\nThe EXPLAIN steps shown are not as inclusive as those provided by the EXPLAIN request modiﬁer.\nThe following is an Explain of a CREATE DATABASE SQL statement.\nEXPLAIN CREATE DATABASE testdb AS PERM=1E6; \nExplanation\n----------------------------------------------------------------------\n  1) First, we lock data base testdb for exclusive use.\n  2) Next, we lock DBC.UIFDEPENDENCY for write on a reserved RowHash to\n     prevent global deadlock.\n  3) We lock DBC.DataBaseSpace for write on a reserved RowHash to\n     prevent global deadlock.\n  4) We lock DBC.Parents for write on a reserved RowHash to prevent\n     global deadlock.\n  5) We lock DBC.Owners for write on a reserved RowHash to prevent\n     global deadlock.\n  6) We lock DBC.AccessRights for write on a reserved RowHash in all\n     partitions to prevent global deadlock.\n  7) We lock DBC.UIFDEPENDENCY for write, we lock DBC.DataBaseSpace for\n     write, we lock DBC.Parents for write, we lock DBC.Owners for write,\n     we lock DBC.DBase for write on a RowHash, we lock DBC.DBase for\n     write on a RowHash, we lock DBC.Accounts for write on a RowHash,\n     and we lock DBC.AccessRights for write.\n  8) We execute the following steps in parallel.\n       1) We do a single-AMP ABORT test from DBC.DBase by way of the\n          unique primary index \"Field_1 = 'TESTDB'\" with no residual\n          conditions.\n       2) We do a single-AMP ABORT test from DBC.Roles by way of the\n          unique primary index \"Field_1 = 'TESTDB'\" with no residual\n          conditions.\n       3) We do a single-AMP ABORT test from DBC.DBase by way of the\n          unique primary index \"Field_1 = 'DBC'\" with a residual\n          condition of (\"DBC.DBase.Field_18 = 47\").\n       4) We do a single-AMP ABORT test from DBC.DBase by way of the\n          unique primary index \"Field_1 = 'DBC'\" with a residual\n          condition of (\"1.00000000000000E 006 <= DBC.DBase.Field_10\").\n       5) We do an INSERT into DBC.DBase.\n       6) We do a single-AMP UPDATE from DBC.DBase by way of the unique\n          primary index \"Field_1 = 'DBC'\" with no residual conditions.\n       7) We do a single-AMP RETRIEVE step from DBC.Parents by way of\n          the primary index \"Field_1 = '00000100'XB\" with no residual\n          conditions into Spool 1 (all_amps), which is redistributed by\n          the hash code of (DBC.Parents.Field_2) to few AMPs. Then we\n          do a SORT to order Spool 1 by row hash.\n  9) We do an all-AMPs MERGE into DBC.Owners from Spool 1 (Last Use).\n 10) We execute the following steps in parallel.\n      1) We do an INSERT into DBC.Owners.\n      2) We do a single-AMP RETRIEVE step from DBC.Parents by way of\n         the primary index \"Field_1 = '00000100'XB\" with no residual\n         conditions into Spool 2 (all_amps), which is redistributed by\n         the hash code of ('00000404'XB) to few AMPs. Then we do a\nLake - Monitor Resources and Performance\nPage 171 of 420         SORT to order Spool 2 by row hash.\n 11) We do an all-AMPs MERGE into DBC.Parents from Spool 2 (Last Use).\n 12) We execute the following steps in parallel.\n      1) We do an INSERT into DBC.Parents.\n      2) We do an INSERT into DBC.Accounts.\n      3) We do a single-AMP RETRIEVE step from a single partition of\n         DBC.AccessRights by way of the primary index \"Field_1 =\n         '00000000'XB, Field_2 = '00000000'XB, Field_3 =\n         '000000000000'XB\" with a residual condition of (\n         \"(DBC.AccessRights.Field_5 <> 'ZO') AND\n         ((DBC.AccessRights.Field_5 <> 'DZ') AND\n         ((DBC.AccessRights.Field_5 <> 'CZ') AND\n         ((DBC.AccessRights.Field_5 <> 'OR') AND\n         ((DBC.AccessRights.Field_5 <> 'OA') AND\n         ((DBC.AccessRights.Field_5 <> 'DS') AND\n         ((DBC.AccessRights.Field_5 <> 'CS') AND\n         ((DBC.AccessRights.Field_5 <> 'OD') AND\n         ((DBC.AccessRights.Field_5 <> 'OU') AND\n         ((DBC.AccessRights.Field_5 <> 'OS') AND\n         ((DBC.AccessRights.Field_5 <> 'OI') AND\n         ((DBC.AccessRights.Field_5 <> 'SA') AND\n         ((DBC.AccessRights.Field_5 <> 'SD') AND\n         ((DBC.AccessRights.Field_5 <> 'GM') AND\n         ((DBC.AccessRights.Field_5 <> 'GD') AND\n         ((DBC.AccessRights.Field_5 <> 'GC') AND\n         ((DBC.AccessRights.Field_5 <> 'OP') AND\n         ((DBC.AccessRights.Field_5 <> 'AE') AND\n         ((DBC.AccessRights.Field_5 <> 'CE') AND\n         ((DBC.AccessRights.Field_5 <> 'DO') AND\n         ((DBC.AccessRights.Field_5 <> 'CO') AND\n         ((DBC.AccessRights.Field_5 <> 'DR') AND\n         ((DBC.AccessRights.Field_5 <> 'CR') AND\n         ((DBC.AccessRights.Field_5 <> 'AP') AND\n         ((DBC.AccessRights.Field_5 <> 'UM') AND\n         ((DBC.AccessRights.Field_5 <> 'UT') AND\n         ((DBC.AccessRights.Field_5 <> 'UU') AND\n         ((DBC.AccessRights.Field_5 <> 'SH') AND\n         ((DBC.AccessRights.Field_5 <> 'EF') AND\n         ((DBC.AccessRights.Field_5 <> 'AF') AND\n         ((DBC.AccessRights.Field_5 <> 'CF') AND\n         ((DBC.AccessRights.Field_5 <> 'PE') AND\n         ((DBC.AccessRights.Field_5 <> 'NT') AND\n         ((DBC.AccessRights.Field_5 <> 'PC') AND\n         ((DBC.AccessRights.Field_5 <> 'TH') AND\n         ((DBC.AccessRights.Field_5 <> 'RO') AND\n         ((DBC.AccessRights.Field_5 <> 'IX') AND\n         ((DBC.AccessRights.Field_5 <> 'RF') AND\n         ((DBC.AccessRights.Field_5 <> 'AS') AND\n         ((DBC.AccessRights.Field_5 <> 'SR') AND\n         ((DBC.AccessRights.Field_5 <> 'SS') AND\n         ((DBC.AccessRights.Field_5 <> 'MR') AND\n         ((DBC.AccessRights.Field_5 <> 'MS') AND\n         (DBC.AccessRights.Field_3 =\n         '000000000000'XB)))))))))))))))))))))))))))))))))))))))))))\")\n         into Spool 3 (all_amps), which is redistributed by the rowkey\n         of ('00000100'XB, '00000404'XB, '000000000000'XB) to few AMPs.\n 13) We execute the following steps in parallel.\n      1) We do a single-AMP RETRIEVE step from a single partition of\n         DBC.AccessRights by way of the primary index \"Field_1 =\n         '00000000'XB, Field_2 = '00000000'XB, Field_3 =\n         '000001000000'XB\" with a residual condition of (\n         \"DBC.AccessRights.Field_3 = '000001000000'XB\") into Spool 3\n         (all_amps), which is redistributed by the rowkey of (\n         '00000404'XB, '00000404'XB, '000000000000'XB) to few AMPs.\n      2) We do an all-AMPs RETRIEVE step from DBC.AccessRights by way\n         of an all-rows scan with a condition of (\n         \"DBC.AccessRights.Field_8 = 'Y'\") into Spool 4 (all_amps),\n         which is redistributed by the hash code of (\n         DBC.AccessRights.Field_1) to all AMPs. Then we do a SORT to\n         order Spool 4 by row hash.\n 14) We do an all-AMPs JOIN step from DBC.Owners by way of a RowHash\n     match scan with a condition of (\"DBC.Owners.Field_2 = '00000404'XB\"),\nLake - Monitor Resources and Performance\nPage 172 of 420     which is joined to Spool 4 (Last Use) by way of a RowHash match\n     scan. DBC.Owners and Spool 4 are joined using a merge join, with\n     a join condition of (\"DBC.Owners.Field_1 = Field_1\"). The result\n     goes into Spool 3 (all_amps), which is redistributed by the rowkey\n     of ('00000404'XB, DBC.AccessRights.Field_2,\n     DBC.AccessRights.Field_3) to all AMPs. Then we do a SORT to\n     partition Spool 3 by rowkey.\n 15) We execute the following steps in parallel.\n      1) We do an all-AMPs MERGE into DBC.AccessRights from Spool 3\n         (Last Use).\n      2) We do an INSERT into DBC.UIFDEPENDENCY.\n 16) We flush the DISKSPACE and AMPUSAGE caches.\n 17) We do an all-AMPs ABORT test from DBC.DataBaseSpace by way of the\n     unique primary index \"Field_1 = '00000100'XB, Field_2 =\n     '000000000000'XB\" with a residual condition of (\n     \"2.50000000000000E 005 <= (DBC.DataBaseSpace.Field_4 -\n     DBC.DataBaseSpace.Field_8)\").\n 18) We do an INSERT into DBC.DataBaseSpace.\n 19) We do an all-AMPs UPDATE from DBC.DataBaseSpace by way of the\n     unique primary index \"Field_1 = '00000100'XB, Field_2 =\n     '000000000000'XB\" with no residual conditions.\n 20) We flush the DISKSPACE and AMPUSAGE caches.\n 21) We spoil the parser's dictionary cache for the database.\n 22) Finally, we send out an END TRANSACTION step to all AMPs involved\n     in processing the request.\n  -> No rows are returned to the user as the result of statement 1.\nThe following is the output from a PM/API application capturing the step data of the preceding SQL statement.\nThe number is a sequential count of the rows returned from the DBS.\nA repeated step number indicates that a parallel step. For example, in the following example, the step number 8 is repeated multiple times. This coincides with the parallel steps found\nfor step 8 in the preceding Explain.\nStep text is derived information and not the true EXPLAIN text.\nA sample of a PM/API application output appears as follows:\nSubmitting request MONITOR SQL; ...\nTotal SQL records = 1\ncreate database testdb as perm=1e6;\n============================\nNumOfSteps: 33   CurStepBegNum: 33   CurStepEndNum: 33\nDynamicPlan: 0   PartialSteps: 0\nZoneId: 0\nSPName/SPDBName: SP NOT executing.\nDefault Database Name: [DBC]\n33 explain steps found\nConfidence= 0, RowCount        0/       4, ET     0.00/    0.00\n 1) First, lock [DBId=0x0406]. for exclusive.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 2) Next, we lock DBC.[TBId=0x0130] for write on a row hash.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 3) We lock DBC.DBSpace for write on a row hash.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 4) We lock DBC.Parents for write on a row hash.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 5) We lock DBC.Owners for write on a row hash.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 6) We lock DBC.AccessRights for write on a row hash.\nConfidence= 0, RowCount        0/       4, ET     0.00/    0.00\n 7) We lock DBC.[TBId=0x0130] for write, we lock DBC.DBSpace for write, we lock DBC.Parents for write, we lock DBC.Owne.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 8) We do a Single-AMP ABORT test from DBC.DBase by way of the unique primary index. This step begins a parallel block .\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 8) We do a Single-AMP ABORT test from DBC.[TBId=0x0138] by way of the unique primary index. This step is performed in .\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 8) We do a Single-AMP ABORT test from DBC.DBase by way of the unique primary index. This step is performed in parallel.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 8) We do a Single-AMP ABORT test from DBC.DBase by way of the unique primary index. This step is performed in parallel.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.01\n 8) We do an INSERT step into table DBC.DBase. This step is performed in parallel.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 8) We do a Single-AMP UPDATE from DBC.DBase by way of the unique primary index. This step is performed in parallel.\nLake - Monitor Resources and Performance\nPage 173 of 420Confidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 8) We do a Single-AMP RETRIEVE step from DBC.Parents by way of the primary index into Spool 50, which is redistributed.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 9) We do a MERGE into table DBC.Owners from Spool 50.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 10) We do an INSERT step into table DBC.Owners. This step begins a parallel block of steps.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 10) We do a Single-AMP RETRIEVE step from DBC.Parents by way of the primary index into Spool 51, which is redistribute.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 11) We do a MERGE into table DBC.Parents from Spool 51.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.00\n 12) We do an INSERT step into table DBC.Parents. This step begins a parallel block of steps.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.02\n 12) We do an INSERT step into table DBC.Accounts. This step is performed in parallel.\nConfidence= 0, RowCount        0/      25, ET     0.00/    0.00\n 12) We do a Single-AMP RETRIEVE step from DBC.AccessRights accessing a single partition by way of the primary index in.\nConfidence= 0, RowCount        0/      21, ET     0.00/    0.00\n 13) We do a Single-AMP RETRIEVE step from DBC.AccessRights accessing a single partition by way of the primary index in.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 13) We do an All-AMPs RETRIEVE step from DBC.AccessRights by way of an all-rows scan into Spool 53, which is redistrib.\nConfidence= 0, RowCount        0/      46, ET     0.00/    0.01\n 14) We do an All-AMPs JOIN step from DBC.Owners by way of an all-rows scan, which is joined to Spool 53. table Owners .\nConfidence= 0, RowCount        0/      46, ET     0.00/    0.01\n 15) We do a MERGE into table DBC.AccessRights from Spool 52. This step begins a parallel block of steps.\nConfidence= 0, RowCount        0/       1, ET     0.00/    0.02\n 15) We do an INSERT step into table [TBId=0x0130]. This step ends a parallel block of steps.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 16) We flush the DISKSPACE and AMPUSAGE caches.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.00\n 17) We do an All-AMPs ABORT test from DBC.DBSpace by way of the unique primary index.\nConfidence= 0, RowCount        0/       4, ET     0.00/    0.00\n 18) We do an INSERT step into table DBC.DBSpace.\nConfidence= 0, RowCount        0/       4, ET     0.00/    0.00\n 19) We do an All-AMPs UPDATE from DBC.DBSpace by way of the unique primary index.\nConfidence= 0, RowCount        0/       0, ET     0.00/    0.01\n 20) We flush the DISKSPACE and AMPUSAGE caches.\nConfidence= 0, RowCount        0/      -1, ET     0.00/   -1.00\n 21) We Spoil the parser's dictionary cache for the database.\nConfidence= 0, RowCount        0/      -1, ET     0.00/    0.00\n 22) We send out an END TRANSACTION step to all AMPs involved in processing the request.\nMONIT OR VERSION\nIdentiﬁes the highest version number (MonVerId) the database monitor function supports, which determines the requests and data ﬁelds available for use.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 3 or later.\nUsage Notes - MONIT OR VERSION\nThe MONITOR VERSION request does not check for access privileges.\nCLIv2 Response Parcels\nThe MONITOR VERSION request is treated internally as a one-statement request that generates one response. The statement response returned from the database contains the\nfollowing sequence of parcel types:\nLake - Monitor Resources and Performance\nPage 174 of 420Parcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = Highest supported version\nActivityType = 108 (PCLMONVER)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record mode)\n6 to 64100(indicator mode)Depending on request (Data or IndicData), data is in record or indicator mode. This\nrecord contains a 2-byte bitmap ﬁeld indicating the supported functions and the\ncurrent version number.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nSee Teradata® Call-Level Interface Version 2 Reference for Mainframe-Attached Systems, B035-2417 or Teradata® Call-Level Interface Version 2 Reference for Workstation-Attached\nSystems, B035-2418.\nResponse\nThe following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each of the ﬁelds correspond to a ResultSet column returned by the Teradata JDBC\nDriver. See Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe statement returns a Record parcel containing:\nField/Column Name Data T ype Description\nFunctionBitmap SMALLINT\nNOT NULLFunctions are:\nBit0 = ModifyAccount\nBit1 = Monitor SQL\nBit2 = 15 - Set to zero (This bit is not used.)\nThe bits are 1 if supported and 0 if not.\nCurrentVersion SMALLINT\nNOT NULLCurrent monitor version number.\nIf you are using MONITOR software version ID (mon_ver_id) 8 or earlier, this output parameter is not\navailable. For more information, see Impact of Object Name Length on PM/API Requests.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR VERSION request, built by CLIv2, appear when sent to the database server. In this example, the size of the response buffer is set\nat the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name BytesField Value\n0001 Req 19 Request MONITOR VERSION\n0003 Data 8 MonVerID 12\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis example shows the values returned in character text format for the MONITOR VERSION request. Your application program may display returned values in a different format.\nSUCCESS parcel:\nStatementNo=1,    ActivityCount=1,\nActivityType=111, FieldCount=2\nMONITOR VERSION:\nFunction bitmap: 3, Current monitor version=12\nMONIT OR VIRTUAL  CONFIG\nCollects information on virtual processor (vproc) availability.\nLake - Monitor Resources and Performance\nPage 175 of 420Input Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using the indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have any one of the following monitor privileges as part of your default role or any of these privileges must be granted directly to you:\nABORTSESSION\nMONRESOURCE\nMONSESSION\nSETRESRATE\nSETSESSRATE\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR VIRTUAL  CONFIG\nInformation regarding vproc status is returned for all AMP, PE, and TVS vprocs in the system.\nMONITOR VIRTUAL CONFIG is most useful when used with the MONITOR VIRTUAL SUMMARY request for doing a quick overall system health check. For more information, see\nRelationship Between MONITOR VIRTUAL CONFIG and MONITOR VIRTUAL SUMMARY.\nIf you use MONITOR VIRTUAL CONFIG, you need not dump out the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view) to see if there is a physical\nproblem with the system.\nCLIv2 Response Parcels\nThe MONITOR VIRTUAL CONFIG request is treated internally as a two statement request, with each statement generating a response. The two statement response returned from the\ndatabase contains the following sequence of parcel types:\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo =1\nActivityCount = 1\nActivityType = 91 (PCLMONVCONFIG)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on request (Data or IndicData), data is in record or indicator mode.\nThis record contains the BYNET status data and the type of system running the\ndatabase software.\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = Number of vprocs\nActivityType = 91 (PCLMONVCONFIG)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nLake - Monitor Resources and Performance\nPage 176 of 420Parcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on request (Data or IndicData), data is in record or indicator mode.\nThis record contains the vproc-speciﬁc information; one record per vproc.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe following table describes the order in which the Record parcel in the ﬁrst statement of the MONITOR VIRTUAL CONFIG returns the BYNET status values and the system type.\nColumn Field/Column Name Data T ype Description\n1 NetAUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide\nbasis.\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\n2 NetBUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide\nbasis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nThis output parameter is available on monitor software version 9 or later only.\n3 SystemType VARCHAR (7)\nNOT NULLType of system running the database software, such as 5650, 6700, or ‘Other’.\nIf all the nodes in the system are the same type, this ﬁeld returns the type of the\nsystem.\nIf any of the nodes are of a different type, this ﬁeld returns ‘Mixed’.\nThis output parameter is available on monitor software version 9 or later only.\nStatement 2\nThe Record parcels in the second statement of the MONITOR VIRTUAL CONFIG response return one record for each processor, with six ﬁelds in each record. Records are sorted\nbased on VProcNo. For example, if you have 32 vprocs, 32 records are returned with speciﬁc information for each vproc and the one record of BYNET data for the whole system.\nField/Column Name Data T ype Description\nProcId INTEGER ID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For\nexample, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nVProcNo SMALLINT\nNOT NULLID of an AMP (that is, a set of disk) and the associated tasks or processes that, in combination, make up\nthe AMP), PE or TVS vproc.\nVProcType VARCHAR (3)\nNOT NULLType of vproc:\nAMP\nPE\nMISC\nHostId SMALLINT Logical host ID for the PEs. This ﬁeld shows NULL for the AMP or TVS vprocs associated with this record.\nEach channel- or TCP/IP network-connected host is assigned an ID at the time the system is conﬁgured.\nEach PE is assigned to a (single) channel-connected host (or client) or a TCP/IP network-connected host.\nThe host ID of zero is reserved for the PEs processing internal sessions.\nLake - Monitor Resources and Performance\nPage 177 of 420Field/Column Name Data T ype Description\nStatus VARCHAR (1)\nNOT NULLStatus of the vproc associated with this record. A vproc is considered up or down from the standpoint of\nwhether the vproc is helping a query process SQL statements. For example, an AMP doing ofﬂine\nrecovery is considered to be down because the AMP is not helping to process SQL statements. However,\nan up vproc is one that is online and fully up or is in online recovery.\nThe status of the vproc:\nU = The vproc is up/online.\nD = The vproc is down/ofﬂine.\nDiskSlice SMALLINT Virtual disk ID deﬁning the portion of a physical disk assigned to an AMP.\nThis value is NULL for TVS vprocs.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR VIRTUAL CONFIG request, built by CLIv2, appear when sent to the database server. In this example, the size of the response\nbuffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 26 Request MONITOR VIRTUAL CONFIG\n0003 Data 6 MonVerID 2\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis example shows the values returned in character text format for the MONITOR VIRTUAL CONFIG request. Your application program may display returned values in a different\nformat.\nSubmitting request MONITOR VIRTUAL CONFIG; ...\nNetAUp:  U NetBUp:  U\nSystemType: 5500C\n8 vproc(s) found\nProcId          Node Loc        VProcNo VProcType       HostId  Status  DiskSlice\n========        ========        ======= =========       ======  ======  =========\n10001           (1-1)           0       AMP             0       U       0\n10001           (1-1)           1       AMP             0       U       1\n10001           (1-1)           2       AMP             0       U       2\n10001           (1-1)           3       AMP             0       U       3\n10001           (1-1)           28670   TVS             0       U       0\n10001           (1-1)           28671   TVS             0       U       0\n10001           (1-1)           30718   PE              1       U       0\n10001           (1-1)           30719   PE              1       U       0\nRelationship between MONIT OR VIRTUAL  CONFIG and MONIT OR VIRTUAL  SUMMAR Y\nUse MONITOR VIRTUAL SUMMARY with the MONITOR VIRTUAL CONFIG request for an overall system status. These are low overhead requests.\nRun the MONITOR VIRTUAL SUMMARY request every 5 or 10 minutes for a low-cost, continuous monitoring of your system.\nRun the MONITOR VIRTUAL CONFIG request to get a picture of your system conﬁguration at deﬁned times, such as at the beginning of a day, different times during the day, or\nwhen the system is down.\nUsing these requests to spot problems, such as abnormal AMP CPU load balancing, and possible sources of system performance bottlenecks. For example, if the HiCPUAMPUse,\nHiCPUPEUse, LoCPUAMPUse, and LoCPUPEUse ﬁgures are consistently widely separated and do not approximate the AMPAvgCPU ﬁgure, you may need to evaluate whether the\nsystem is using available resources efﬁciently. Alternatively, if the PEAvgCPU is consistently much higher than the AMPAvgCPU, the system may not be conﬁgured to efﬁciently use\nAMP resources. How often you perform a health check of your system depends on the size of your system and the type of applications run.\nKnowledge of the overall system status can help you to determine:\nLake - Monitor Resources and Performance\nPage 178 of 420Concern Comments\nWhen to run production applications, especially large ones For example, if you have a down AMP, you may decide that recovering the AMP ﬁrst and then running the job is less\ncostly than running the job without full system availability.\nWhy an application runs more slowly than usual This situation may be caused by a down AMP, which makes the backup AMP do more work (backup and primary\nprocessing). This can cause your application to run more slowly.\nWhether all vprocs have come back up after a system restartExamine the Status value returned in a MONITOR VIRTUAL CONFIG request to determine whether each vproc is up\nor down (see the MONITOR VIRTUAL CONFIG Status ﬁeld).\nThe response data returned by MONITOR VIRTUAL CONFIG is similar in content to the response data returned by a MONITOR VIRTUAL RESOURCE request, but in an abbreviated\nform. In your initial problem analysis, if the information returned from a MONITOR VIRTUAL SUMMARY query does not give you enough data. For example, you need BYNET or CPU%\nbusy information and you may want to use MONITOR VIRTUAL RESOURCE to get more detailed resource usage data.\nMONIT OR VIRTUAL  RESOURCE\nCollects performance information for each AMP, PE, or TVS vproc and returns:\nSystem-wide (identical for all vprocs) data\nData speciﬁc to the vproc\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using the indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have the MONRESOURCE privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR VIRTUAL  RESOURCE\nYou can use the MONITOR VIRTUAL RESOURCE request to:\nExpand on the data reported by the MONITOR VIRTUAL SUMMARY request.\nIn your initial problem analysis, a MONITOR VIRTUAL SUMMARY request may indicate a performance or system problem. MONITOR VIRTUAL RESOURCE allows you to collect\nRSS data on a vproc by vproc basis.\nContinually monitor your system.\nMonitor your system continually on a periodic basis, for example, every 10 minutes. Use this request to build a normal baseline proﬁle for your system. When you notice\nsomething abnormal, such as the last reading is signiﬁcantly different from the normal baseline reading, or when a user complains that a job is slow, this request can tell you if\nthere is a parallel efﬁciency problem or a constraint to throughput, and which vproc is the cause.\nFor example, if one PE shows a much higher usage than the other PEs, that PE may be overloaded. Also, if one AMP is loaded more heavily than the other AMPs, you may have\nproblems with a skewed index.\nDetermine whether a new application can be added to the current system load without disruption.\nThe vproc usage information collected by this request can help you evaluate the impact of adding new applications to an already heavily used system and help you plan\npotential system upgrades.\nHelp resolve problems that session-level usage information cannot resolve.\nWhen the MONITOR SESSION request does not show any cause for the problem, this request can supply information regarding congestion, memory allocations, BYNET outages, and\nsystem status.\nThe MONITOR VIRTUAL RESOURCE request can provide information about:\nLake - Monitor Resources and Performance\nPage 179 of 420How the system is being used (for example, the number of sessions associated with each vproc and the percentage of CPU usage by vproc).\nHow system resource usage is spread across the vprocs (for example, whether the vprocs are used evenly).\nHow much physical disk I/O, BYNET trafﬁc, or host reads and writes are occurring.\nWhether congestion or excessive swapping is a problem on any vproc or group of vprocs.\nThe ﬁelds that the MONITOR VIRTUAL RESOURCE request returns and the ﬁelds found in the resource usage tables overlap. You can use both MONITOR VIRTUAL RESOURCE and\nresource usage data for problem detection. Unlike resource usage data, MONITOR VIRTUAL RESOURCE data is near real time, and requires less overhead to produce, but is less\ncomprehensive. MONITOR VIRTUAL RESOURCE data can help detect the following:\nPoor AMP CPU parallel efﬁciency\nPoor disk parallel efﬁciency\nA higher than expected disk read/write ratio\nA high swap I/O rate\nYou must set the rate by which vproc resource usage data is updated in memory (ResMonitor rate) to nonzero for the MONITOR VIRTUAL RESOURCE request to return meaningful\ndata. If you set the ResMonitor rate to zero, NULL is returned for all vproc usage data.\nIf the TVS vproc is conﬁgured on a node without any AMPs, all ﬁelds return a value of zero.\nAfter a system outage or a change in the ResMonitor rate, do not request data again until after completion of the ﬁrst collection period requested after the outage or change in rate.\nOtherwise, the data returned contains NULL for all columns except NetAUp, NetBUp, SampleSec, CollectionDate, CollectionTime, VProcType, ProcId, VProcNo, HostId/ClusterNo, and\nStatus, and may not be fully representative.\nThis is because after a system outage, the in-memory counters are reset, and typically the contents of the counters are not well deﬁned until a full collection period has elapsed. If you\nwere logged on before the system outage and you issue your ﬁrst MONITOR VIRTUAL RESOURCE request after the outage, you get a warning that the database system has been\nrestarted.\nCLIv2 Response Parcels\nThe MONITOR VIRTUAL RESOURCE request is treated internally as a two statement request, with each statement generating a response. The two statement response returned from\nthe database contains the following sequence of parcel types:\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 95 (PCLMONVRES)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. One\nrecord is returned that contains the duration of the collection period (in seconds), BYNET\nstatus, and the date and time the Virtual Resource cache was last refreshed.\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = Number of vprocs\nActivityType = 95 (PCLMONVRES)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator\nmode)Depending on request (Data or IndicData), data is in record or indicator mode. One\nrecord per vproc is returned that contains a description for each vproc in the system.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe Record parcel in the ﬁrst statement of the MONITOR VIRTUAL RESOURCE response returns global data about collection duration and BYNET status in the following order.\nLake - Monitor Resources and Performance\nPage 180 of 420Field/Column Name Data T ype Description\nNetAUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nNetBUp VARCHAR (1)\nNOT NULLStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n“” = A temporary condition where the BYNET data is not available.\nSampleSec SMALLINT\nNOT NULLDuration of the collection period in seconds. This ﬁeld returns the ResMonitor rate. See Data Collection\nand SET RESOURCE RATE for more information on ResMonitor.\nCollectionDate DATE\nNOT NULLDate the Virtual Resource cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLTime the Virtual Resource cache was last refreshed.\nStatement 2\nThe response to the second statement returns multiple Record parcels that consist of a record for each vproc in the system. The Record parcels in the second statement of the\nMONITOR VIRTUAL RESOURCE response can return multiple records, speciﬁcally, one record of 32 ﬁelds for each vproc in the system. For example, if you have 50 vprocs, 50 records\nare returned with speciﬁc information for each vproc, one record describing the collection period, and BYNET status for the entire system. Records are sorted by VProcType and\nVProcNo.\nThe following table shows the order in which the data is returned from the Record parcel.\nColumn Name Data T ype Description\nVprocType VARCHAR (3)\nNOT NULLType of vproc:\nAMP\nPE\nMISC\nProcId INTEGER ID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000.\nFor example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nVprocNo SMALLINT\nNOT NULLID of an AMP (that is, a set of disks and the associated tasks or processes that, in combination, make\nup the AMP), PE or TVS vproc.\nHostId/ClusterNo SMALLINT For a PE vproc, this ﬁeld, HostId, identiﬁes one of the hosts or LANs associated with the described\nPE.\nFor an AMP vproc, this ﬁeld, ClusterNo, identiﬁes the compute cluster to which this AMP is assigned.\nThis ﬁeld is not applicable to TVS vproc and returns NULL.\nCPUUse FLOAT\nrange 0 - 100%% of CPU usage not spent being idle.\nThe value is computed from ResUsageSvpr table data as, where NCPUs is the number of CPUs in\nthe node:\n100.00 * (CPUUExecPart00 + CPUUExecPart01 + ... + CPUUExecPart47 + CPUUServPart00 +\nCPUUServPart01 + ... + CPUUServPart47) / (NCPUs * SampleSec * 100)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nStatus VARCHAR (1)\nNOT NULLStatus of the node, AMP, PE, or TVS vproc associated with this record:\nU = Up/online.\nD = Down/ofﬂine.\nA node is up (U) when the following are true:\nLake - Monitor Resources and Performance\nPage 181 of 420Column Name Data T ype Description\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nSessLogCount SMALLINT Number of current sessions logged to this PE. A logged on session is either a session whose logon\nrequest was delivered to this PE, or a session that was switched to this PE following its logon.\nThe SessLogCount ﬁeld contains the SubPoolId if the vproc type is TVS.\nSubpoolId identiﬁes the subpool associated with the allocator vproc. A subpool deﬁnes a set of\nstorage and allocator vprocs assigned to that storage.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nSessRunCount SMALLINT Number of current sessions whose Initiate Requests (TSR messages) are addressed to this vproc.\nFor example:\nPEs have a SessRunCount that includes all the Teradata SQL and MONITOR sessions logged\non to that PE.\nAMPs may have a nonzero SessRunCount, because AMPs get TSR messages from FastLoad\nor MultiLoad logons.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nThis ﬁeld is not applicable to TVS vprocs.\nDiskUse FLOAT % of disk usage per AMP.\nThis value is computed from the ResUsageSvdsk table data:    OutReqTime / SampleSec\nDiskUse does not take into account overlapping of operations among multiple storage controllers,\nbut does allow for the possibility of multiple requests for the same controller.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nDiskReads FLOAT Total number of physical disk reads per AMP during the collection period.\nThis value is computed from the ResUsageSvpr table data as:\nFilePCiAcqReads + FilePDbAcqReads + FileSCiAcqReads + FileSDbAcqReads + FileTjtAcqReads +\nFileAPtAcqReads;\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nThis ﬁeld is not applicable to TVS and PE vprocs.\nDiskWrites FLOAT Total number of physical disk writes per AMP during the collection period.\nFor PE and AMP-level displays, this value is computed from ResUsageSvpr table data as:\nFilePCiFWrites + FilePDbFWrites + FileSCiFWrites + FilesDbFWrites + FileTjtFWrites + FileAPtFWrites\n+ FilePCiDyaWrites + FilePDbDyaWrites + FileSciDyaWrites + FilesDbDyaWrites + FileTjtDyaWrites +\nFileAptDyaWrites\nFor TVS vproc displays, this value is computed from ResUsageSvpr table data as:\nAllocatorMapIOsDone\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nDiskOutReqAvg FLOAT Average number of outstanding disk requests.\nFor AMP-level displays, this value is computed from ResUsageSvdsk table data, assuming n is the\nnumber of storage devices used by this vproc:\n(ReadRespTot 1 + WriteRespTot 1 + ... + ReadRespTot n + WriteRespTot n) / CentiSecs\nThis ﬁeld is not applicable to PE vprocs.\nFor TVS vproc-level displays, this value is computed from ResUsageSvpr table data as:\nAllocatorMapIOsStarted - AllocatorMapIOsDone\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nHostBlockReads FLOAT Number of message blocks (one or more messages sent in one physical group) received from all\nclients.\nLake - Monitor Resources and Performance\nPage 182 of 420Column Name Data T ype Description\nThis value corresponds to the column totals in the ResUsageShst table supplying HostBlockReads\nfor this vproc.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nThis ﬁeld is not applicable to AMP or TVS vprocs.\nHostBlockWrites FLOAT Number of message blocks (that is, one or more messages sent in one physical group) sent to all\nhosts.\nThis value corresponds to the column totals in the HstBlkWrts column of the ResUsageShst table.\nThis ﬁeld is not applicable to AMP or TVS vprocs.\nMemAllocates FLOAT Number of segments allocated to memory resources.\nThis value is calculated from the following ResUsageSvpr table column:\nMemCtxtAllocs\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nMemAllocateKB FLOAT Value represents the change in vproc-level memory. MemAllocateKB represents a delta from the\nprevious reporting period, reporting negative values as less memory is used.\nThis value is calculated from the following ResUsageSvpr column:\nMemCtxAllocs * FIXEDPAGESIZE\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nPercentService FLOAT % of CPU resources spent in PDE user service processing.\nThis value is computed from the ResUsageSvpr table data, where x represents the number of CPUs:\n(CPUUServPart00 + CPUUServPart01 + ... + CPUUServPart47) /( x * SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nPercntAMPWT FLOAT\nrange 0 - 100%% of CPU resources used by either the AMP Worker Task (Partition 11) or by the TVS Task (Partition\n31) depending on the type of vproc this record represents.\nThis value depends on the number of CPUs in the node but does not exceed 100%. The value is\ncomputed from the ResUsageSvpr table data, where x represents the number of CPUs on a node:\nFor AMP vprocs:\n(CPUUExecPart11) / (x * SampleSec)\nFor TVS vprocs:\n(CPUUExecPart31) / (x * SampleSec)\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nPercntParser FLOAT\nrange 0 - 100%This ﬁeld is deprecated and returns zero or NULL.\nPercntDispatcher FLOAT\nrange 0 - 100%% of CPU resources spent in PE Dispatcher processing.\nThis value depends on the number of CPUs in the node but does not exceed 100%. This value is\ncomputed from the ResUsageSvpr table data, where x represents the number of CPUs on a node:\n(CPUUExecPart13 + CPUUServPart13) / (x * SampleSec)\nThe PercntParser CPU time is included in the PercntDispatcher value.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nPercntDispatcher is not applicable to AMP and TVS vprocs.\nNetReads FLOAT Number of Reads from the BYNET to the vproc.\nThis value is computed from the ResUsageSvpr table data as follows:\nNetBrdReads + NetPtPReads\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nLake - Monitor Resources and Performance\nPage 183 of 420Column Name Data T ype Description\nNetWrites FLOAT Number of messages written from the AMP, PE, or vproc to the BYNET during the collection period.\nThis value is computed from the ResUsageSvpr table data as follows:\nNetBrdWrites + NetPtPWrites\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nMaxIOResp FLOAT Value is computed from ResUsageSvpr table data using the IoRespMax ﬁeld. IoRespMax is the\nmaximum I/O response time in milliseconds on an AMP.\nThis ﬁeld is not applicable to PE and TVS vprocs.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL RESOURCE.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR VIRTUAL RESOURCE request, built by CLIv2, look when sent to the database server. The size of the response buffer is set in the\nexample at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Char/Decimal\n0001 Req 28 Request MONITOR VIRTUAL RESOURCE\n0003 Data 6 MonVerID 9\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis example shows the values returned in character text format (a record for each vproc) for the MONITOR VIRTUAL RESOURCE request. Your application program may display\nreturned values in a different format.\nYou can rename the SampleSec ﬁeld in your application. In the following output, the SampleRate value is the SampleSec value.\nPay attention to SampleRate when interpreting the results of this request.\nSubmitting request MONITOR VIRTUAL RESOURCE; ...\nNetAUp:  U NetBUp:  U\nSampleRate: 60\nCollection Date/Time:   07/06/2016 13:48:00.00\nVprocNo:      0   Vproctype: AMP   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 0\nSessLogCount: 0   SessRunCount: 0\nCPUUse:       24.7   PctService:  0.4\nPctAMPWT:     24.3   DiskUse: 12.7\nDiskReads:    5.00   DiskWrites: 1323.00   DiskOutReqAvg:    0.17\nNetReads:    74.00   NetWrites:    69.00\nNVMemAllocSegs:  265.00\n---------------------------------------------------------\nVprocNo:      1   Vproctype: AMP   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 1\nSessLogCount: 0   SessRunCount: 0\nCPUUse:       24.7   PctService:  0.4\nPctAMPWT:     24.2   DiskUse: 12.9\nDiskReads:    7.00   DiskWrites: 1345.00   DiskOutReqAvg:    0.17\nNetReads:    55.00   NetWrites:    56.00\nNVMemAllocSegs:  300.00\nLake - Monitor Resources and Performance\nPage 184 of 420---------------------------------------------------------\nVprocNo:      2   Vproctype: AMP   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 0\nSessLogCount: 0   SessRunCount: 0\nCPUUse:       24.8   PctService:  0.6\nPctAMPWT:     24.2   DiskUse: 13.6\nDiskReads:    6.00   DiskWrites: 1355.00   DiskOutReqAvg:    0.19\nNetReads:    54.00   NetWrites:    57.00\nNVMemAllocSegs:  302.00\n---------------------------------------------------------\nVprocNo:      3   Vproctype: AMP   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 1\nSessLogCount: 0   SessRunCount: 0\nCPUUse:       24.6   PctService:  0.4\nPctAMPWT:     24.2   DiskUse: 13.4\nDiskReads:   10.00   DiskWrites: 1355.00   DiskOutReqAvg:    0.19\nNetReads:    55.00   NetWrites:    60.00\nNVMemAllocSegs:  319.00\n---------------------------------------------------------\nVprocNo:  28670   Vproctype: TVS   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 0\nSubPoolId: 1\nCPUUse:        0.1   PctService:  0.0\nCPUExecPart31:      0.1        DiskUse:  0.0\nAllocatorMapIOsDone:   94.00   PendingAllocatorMapIOs:    0.00\nNetReads:    99.00   NetWrites:   100.00\nNVMemAllocSegs:    0.00\n---------------------------------------------------------\nVprocNo:  28671   Vproctype: TVS   Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 0\nSubPoolId: 0\nCPUUse:        0.1   PctService:  0.0\nCPUExecPart31:      0.1        DiskUse:  0.0\nAllocatorMapIOsDone:   93.00   PendingAllocatorMapIOs:    0.00\nNetReads:    98.00   NetWrites:    97.00\nNVMemAllocSegs:    0.00\n---------------------------------------------------------\nVprocNo:  30718   Vproctype: PE    Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 1025\nSessLogCount: 0   SessRunCount: 0\nCPUUse:        0.0   PctService:  0.0\nPctParser:     0.0   PctDispatcher:  0.0   HstBlkRds:    0.00   HstBlkWrts:    \n0.00\nNetReads:   100.00   NetWrites:    99.00\nNVMemAllocSegs:    0.00\n---------------------------------------------------------\nVprocNo:  30719   Vproctype: PE    Status:  U\nProcId:    10001 (1-1) HostId/ClusterNo: 1025\nSessLogCount: 1   SessRunCount: 0\nLake - Monitor Resources and Performance\nPage 185 of 420CPUUse:        0.0   PctService:  0.0\nPctParser:     0.0   PctDispatcher:  0.0   HstBlkRds:    0.00   HstBlkWrts:    \n0.00\nNetReads:    18.00   NetWrites:    17.00\nNVMemAllocSegs:    0.00\nWarning and Error Messages\nAll users who are logged on and issue a MONITOR VIRTUAL RESOURCE request after a system restart, or after the last rate change can expect a warning message. Two types of\nsituations can produce warning messages:\nAfter a system restart, before and after a collection period has expired.\nIf the collection period has not expired and the user issues the next MONITOR VIRTUAL RESOURCE request, multiple NULL values are returned.\nAfter the last rate change, before and after a collection period has expired.\nIf the collection period has not expired and the user issues the next MONITOR VIRTUAL RESOURCE request, multiple NULL values are returned.\nFor a discussion of general warning and error messages that may be returned by MONITOR VIRTUAL RESOURCE and other requests, see Common Warning and Error Messages.\nFor more detailed information on warning and error messages, see Database Messages.\nRelationship between MONIT OR VIRTUAL  RESOURCE and ABORT SESSION\nIf you ran an ABORT SESSION request, data returned in a MONITOR PHYSICAL RESOURCE or MONITOR VIRTUAL RESOURCE request may be altered. Whether you notice the\nchange in data depends on the scope of the ABORT SESSION request. For example, if you run an ABORT SESSION and log off all of the sessions associated with a speciﬁc host (or\nclient), the PEs associated with that client report a large decrease in resource consumption. However, if the ABORT SESSION request only aborts one transaction from one session, you\nmay not notice a change in AMP or PE resource use.\nRelationship between MONIT OR VIRTUAL  RESOURCE and SET RESOURCE RA TE\nYou must run the SET RESOURCE RATE request to activate resource data collection before you run a MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request.\nTherefore, you must set the resource monitoring rate (ResMonitor) to nonzero. If the ResMonitor rate is set to zero, you get an error message.\nA change in the resource collection rate by User A, for example, may affect the data reported by MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request made\nby User B. If the ResMonitor rate is altered, User B gets a warning message when executing a subsequent MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE\nrequest.\nMONIT OR VIRTUAL  SUMMAR Y\nCollects global summary information on system usage.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have any one of the following monitor privileges as part of your default role or any of these privileges must be granted directly to you:\nABORTSESSION\nMONRESOURCE\nMONSESSION\nSETRESRATE\nSETSESSRATE\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nLake - Monitor Resources and Performance\nPage 186 of 420Usage Notes - MONIT OR VIRTUAL  SUMMAR Y\nThe MONITOR VIRTUAL SUMMARY request reports the following types of information:\nCPU usage (average by vproc type online only)\nDisk usage (average, high, and low by Vproc ID)\nAMP usage (average, high, and low by AMP ID)\nPE usage (average, high, and low by PE ID)\nNumber of logged on sessions\nRate information:\nVproc resource logging rate\nVproc resource monitoring rate\nSession-level system\nLocal monitoring rates\nCurrent software release and version numbers\nYou must set the ResMonitor rate (the rate at which vproc resource usage data is updated in memory) to a nonzero value for the MONITOR VIRTUAL SUMMARY request to return\nmeaningful data. If you set the ResMonitor rate to zero, NULL is returned for all columns related to vproc usage.\nAfter a system outage or a change in the ResMonitor rate, do not request data again until after the completion of the ﬁrst collection period requested after the outage or change in rate.\nIf you ignore this, the data returned contains NULL.\nThis is because after an outage, the in-memory counters are reset, and typically the contents of the counters are not well deﬁned until a full collection period has elapsed. For example,\nif you were logged on before the system outage and you issue your ﬁrst MONITOR VIRTUAL SUMMARY request after the outage, you get a warning that the database server has been\nrestarted.\nCLIv2 Response Parcels\nThe response returned from the database resembles a summary of the type of response returned by a MONITOR VIRTUAL RESOURCE request. The response is one row of 35 ﬁelds.\nThe response returned from the database contains the following sequence of parcel types.\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 ActivityCount =1\nActivityType = 93 (PCLMONVSUMMARY)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on request (Data or IndicData), data is in record or indicator mode. This\ncontains the IndicData virtual summary information and the date and time the Virtual\nResource cache was last refreshed.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nThe following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each of the ﬁelds correspond to a ResultSet column. See Teradata JDBC Driver\nReference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe statement response returns a Record parcel containing resource usage information.\nField/Column Name Data T ype Description\nAMPAvgCPU FLOAT\nrange 0 to 100%Average % CPU usage (CPUUse) of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgCPU is computed from\nCPUUse data as:\n(CPUUse 1+ ... + CPUUse n) / n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nAMPAvgDisk FLOAT Average physical disk usage (DiskUse) of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDisk is computed from\nDiskUse data as:\n(DiskUse 1+ ... + DiskUse n) / n\nLake - Monitor Resources and Performance\nPage 187 of 420Field/Column Name Data T ype Description\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nAMPAvgDiskIO FLOAT Average physical disk DiskReads and DiskWrites of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDiskIO is computed\nfrom DiskReads and DiskWrites data as:\n(DiskReads 1+ DiskWrites 1+ ... + DiskReads 1+ DiskWrites n) / n\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUAMPUse FLOAT Highest CPUUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUAMPNo SMALLINT VProcNo of an AMP with CPUUse equal to the value reported as HiCPUAMPUse.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUAMPProc INTEGER ID of the node responsible for managing the AMP reported as HiCPUAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoCPUAMPUse FLOAT Lowest CPUUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoCPUAMPNo SMALLINT VProcNo of an AMP with CPUUse equal to the value reported as LoCPUAMPUse.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoCPUAMPProc INTEGER ID of the node responsible for managing the AMP reported as LoCPUAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiDiskAMP FLOAT Highest DiskUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiDiskAMPNo SMALLINT Number of an AMP with DiskUse equal to the value reported as HiDiskAMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiDiskAMPProc INTEGER ID of the node responsible for managing the AMP reported in HiDiskAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when HiDiskAMPNo is NULL.\nLoDiskAMP FLOAT Lowest DiskUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoDiskAMPNo SMALLINT Number of an AMP with DiskUse equal to the value reported as LoDiskAMP.\nLake - Monitor Resources and Performance\nPage 188 of 420Field/Column Name Data T ype Description\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoDiskAMPProc INTEGER ID of the node responsible for managing the AMP reported as LoDiskAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when LoDiskAMPNo is NULL.\nHiDiskAMPIO FLOAT Highest DiskReads and DiskWrites value associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiDiskAMPIONo SMALLINT Number of an AMP with the highest DiskReads and DiskWrites equal to the value reported as\nHiDiskAMPIO.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiDiskAMPIOProc INTEGER ID of the node responsible for managing the AMP reported in HiDiskAMPIONo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when HiDiskAMPIONo is NULL.\nLoDiskAMPIO FLOAT Lowest DiskReads and DiskWrites number associated with any online AMP.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoDiskAMPIONo SMALLINT ID of an AMP with lowest DiskReads and DiskWrites equal to the value reported as\nLoDiskAMPIO.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nLoDiskAMPIOProc INTEGER ID of the node responsible for managing the AMP reported as LoDiskAMPIONo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when LoDiskAMPIONo is NULL.\nPEAvgCPU FLOAT Average CPUUse for all online PEs in the conﬁguration.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUPEUse FLOAT Highest CPUUse percentage associated with any online PE.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUPENo SMALLINT VProcNo of a PE with CPUUse equal to the value reported as HiCPUPEUse.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nHiCPUPEProc INTEGER ID of the node responsible for managing the PE reported in HiCPUPENo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL when HiCPUPENo is NULL.\nLoCPUPEUse FLOAT Lowest CPUUse percentage associated with any online PE.\nThis value is NULL if certain conditions apply.\nLoCPUPENo SMALLINT VProcNo of a PE with CPUUse equal to the value reported as LoCPUPEUse.\nLake - Monitor Resources and Performance\nPage 189 of 420Field/Column Name Data T ype Description\nThis value is NULL when LoCPUPEUse is NULL.\nLoCPUPEProc INTEGER ID of the node responsible for managing the PE reported as LoCPUPENo.\nThis value is computed as the module number within a cabinet plus the cabinet number times\n10000. For example, a node #123 on cabinet #4 returns an INTEGER value of 40123.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nSessLogCount FLOAT Total number of sessions logged onto the system. This value is typically equal to the sum of\nthe SessLogCount values for all PEs.\nThis value is NULL if certain conditions apply, see Usage Notes - MONITOR VIRTUAL\nSUMMARY.\nSesMonitorSys SMALLINT, NOT NULL, range 0-\n3600 seconds,Maximum acceptable age of collected session-level data in memory to the PM/API application\nor end user.\nThis global rate is the default collection rate for all MONITOR sessions. If the value is set to\nzero, the collection capability is disabled.\nThis rate can be changed with the SET SESSION RATE request by specifying a system-wide\noption and can be saved on disk (in the version record) when changed.\nSesMonitorLoc SMALLINT, NOT NULL, range 0-\n3600 seconds,Sets the maximum acceptable age of collected session-level data in memory for an individual\nMonitor partition session that submits a MONITOR SESSION request.\nA rate of zero allows SesMonitorSys to override the current local rate for that session.\nThis rate can be changed with the SET SESSION RATE request by specifying the a LOCAL\nrate change option and can be saved on disk and may be lost during a system outage.\nResLogging SMALLINT, NOT NULL\nrange 0- 3600 secondsInterval in seconds at which resource usage data is written to one or more active resource\nusage database tables.\nResMonitor SMALLINT\nNOT NULLInterval in seconds at which all resource usage data is collected in memory for reporting using\nthe PM/API.\nRelease VARCHAR (29)\nNOT NULLRelease number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nVersion VARCHAR (32)\nNOT NULLVersion number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nCollectionDate DATE\nNOT NULLDate the Virtual Resource cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLTime the Virtual Resource cache was last refreshed.\nSample Input - CLIv2 Request\nThis example shows how the parcels for a MONITOR VIRTUAL SUMMARY request, built by CLIv2, look when sent to the database. The size of the response buffer in the example is set\nat the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name LengthField Value\n0001 Req 27 Request MONITOR VIRTUAL SUMMARY\n0003 Data 6 MonVerID 2\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nLake - Monitor Resources and Performance\nPage 190 of 420For an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis example shows the values returned in character text format for the MONITOR VIRTUAL SUMMARY request. Your application program may display returned values in a different\nformat.\nSubmitting request MONITOR VIRTUAL SUMMARY; ...\nAMPAvgCPU:     24.59   AMPAvgDisk:     6.79   AMPAvgDiskIO:  1184.75\nHiCPUAMPUse:   24.65   HiDiskAMP:      7.20   HiDiskAMPIO:   1218.00\nHiCPUAMPNo:        0   HiDiskAMPNo:       2   HiDiskAMPIONo:       0\nHiCPUAMPProc:  10001   HiDiskAMPProc: 10001   HiDiskAMPIOProc: 10001\nLoCPUAMPUse:   24.53   LoDiskAMP:      6.50   LoDiskAMPIO:   1142.00\nLoCPUAMPNo:        2   LoDiskAMPNo:       0   LoDiskAMPIONo:       3\nLoCPUAMPProc:  10001   LoDiskAMPProc: 10001   LoDiskAMPIOProc: 10001\nPEAvgCPU:       0.00\nHiCPUPEUse:     0.00   LoCPUPEUse:     0.00\nHiCPUPENo:     30719   LoCPUPENo:     30719\nHiCPUPEProc:   10001   LoCPUPEProc:   10001\nSessionCnt:     1.00\nSesMonitorSys:     1   SesMonitorLoc:     0\nVprocLogging:     60   VprocMonitor:     60\nRelease: 16u.00.00.41                Version: 16u.00.00.41_dr182707m\nCollection Date/Time:   07/20/2016 12:39:00.00\nWarning and Error Messages\nAll users who are logged on and issue a MONITOR VIRTUAL SUMMARY request after a system restart or after the last rate change can expect to receive one of the warnings. Typically,\nthe situations that can produce warning messages are the following:\nAfter a system restart, before and after a collection period has expired.\nIf the collection period has not expired and the user issues the next MONITOR VIRTUAL SUMMARY request, multiple NULL values are returned.\nAfter the last rate change, before and after a collection period has expired.\nIf the collection period has not expired and the user issues the next MONITOR VIRTUAL SUMMARY request, multiple NULL values are returned.\nIf the resource monitoring rate (ResMonitor) is not enabled, that is, if rate is set to zero. When the user issues the next MONITOR VIRTUAL SUMMARY request, multiple NULL\nvalues are returned.\nRelationship between MONIT OR VIRTUAL  SUMMAR Y and SET RESOURCE RA TE\nThe SET RESOURCE RATE request sets the ResMonitor and ResLogging rates, which are among the responses returned by the MONITOR PHYSICAL SUMMARY or MONITOR\nVIRTUAL SUMMARY request. Any change to either the ResMonitor or ResLogging rate causes changes in the corresponding response returned by the MONITOR VIRTUAL SUMMARY\nor MONITOR PHYSICAL SUMMARY request.\nYou must set ResMonitor to a nonzero rate for MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL SUMMARY to return meaningful resource usage data. A zero ResMonitor rate\nreturns NULL for resource usage information.\nRelationship between MONIT OR VIRTUAL  SUMMAR Y and SET SESSION RA TE\nChanges to the session-level rates (global and local) speciﬁed by SET SESSION RATE are reported in the data returned by MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL\nSUMMARY.\nThe local rate reported is your own local rate. If the local rate is not set, the local rate is reported as zero.\nAs more session-level monitoring is done (by setting a faster SET SESSION RATE), the resulting overhead may increase the level of CPU usage (reported in MONITOR PHYSICAL\nSUMMARY or MONITOR VIRTUAL SUMMARY data) by your system. However, this may depend on the size of the rate change and the type of work done by other sessions.\nRelationship between MONIT OR VIRTUAL  SUMMAR Y and MONIT OR VIRTUAL  CONFIG\nUse MONITOR VIRTUAL SUMMARY with the MONITOR VIRTUAL CONFIG request for an overall system status. These are low overhead requests.\nRun the MONITOR VIRTUAL SUMMARY request every 5 or 10 minutes for a low-cost, continuous monitoring of your system.\nLake - Monitor Resources and Performance\nPage 191 of 420Run the MONITOR VIRTUAL CONFIG request to get a picture of your system conﬁguration at deﬁned times, such as at the beginning of a day, different times during the day, or\nwhen the system is down.\nFor information on this PMPC PM/API request relationship, see Relationship Between MONITOR VIRTUAL CONFIG and MONITOR VIRTUAL SUMMARY.\nMONIT OR WD\nReturns a subset of the RSS ResUsageSps data.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This must be version 9 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have the MONRESOURCE privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - MONIT OR WD\nThe data returned through MONITOR WD is ResUsageSps data from the RSS memory buffer.\nYou can use SET RESOURCE RATE to enable RSS collection.\nThe data in the buffer is summarized to unique service-level-goal-driven Priority Scheduler workload deﬁnition ID (pWDid) and VprType ﬁeld values. For a description of the pWDid\nﬁeld, see resusagespsV.\nThe WDId and pWDid ﬁelds return valid ID values.\nZero is a valid value for the pWDid ﬁeld.\nTASM Workloads rule is enabled.\nCLIv2 Response Parcels\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 Statement No =1\nActivityCount = 1\nActivityType = PCLMONWDRESRSTMT (202)\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n11 to 64100 (indicator mode)Depending on the request (Data or IndicData) data is returned in record or\nindicator mode. See Statement 1 for details on the data returned.\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 Statement No =2\nActivityCount = Number of Record parcels in statement 2\nActivityType = PCLMONWDRESRSTMT (202)\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nLake - Monitor Resources and Performance\nPage 192 of 420Parcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nRecord 10\n5 to 64100 (record mode)\n11 to 64100 (indicator mode)Depending on the request (Data or IndicData) data is returned in Record or\nindicator mode. See Statement 2 for details on the data returned.\nEndStatement 11 6 StatementNo = 2-byte integer\nEnd Request 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe response to the ﬁrst statement returns a Record parcel containing the following ﬁelds.\nField/Column Name Data T ype Description\nSampleSec SMALLINT\nNOT NULLDuration of the collection period in seconds.\nAMPNodes SMALLINT\nNOT NULLNumber of nodes with at least one online AMP.\nPENodes SMALLINT\nNOT NULLNumber of nodes with at least one online PE.\nCollectionDate DATE,\nNOT NULLDate the WD resource cache was last refreshed.\nCollectionTime FLOAT\nNOT NULLTime the WD resource cache was last refreshed.\nStatement 2\nThe second statement of the response returns multiple Record parcels. For more information, see resusagespsV.\nField/Column Name Data T ype Description\nPPId SMALLINT\nNOT NULL* The Workload Share\nPercent Management Method\nworkload is assigned a\nproportion of the resources that\nare available after allocations\nhave been made for tactical\nworkloads. The percentage of\nresources is divided equally\nbetween all requests running in\nthe WD. For example, if the\nWorkload Share Percent is 5%\nand there are ﬁve SQL requests,\neach SQL request gets 1% of the\nshare resources.This ﬁeld is deprecated and returns a value of zero.\nPGId SMALLINT\nNOT NULL* The Workload Share Percent Management Method workload is assigned a proportion of\nthe resources that are available after allocations have been made for tactical workloads.\nThe percentage of resources is divided equally between all requests running in the WD. For\nexample, if the Workload Share Percent is 5% and tThis ﬁeld returns the pWDid value.\nLake - Monitor Resources and Performance\nPage 193 of 420Field/Column Name Data T ype Description\nVprType VARCHAR (4)\nNOT NULLType of vproc:\nAMP\nPE\nMISC\nWDId INTEGER\nNOT NULLWD ID. On SLES 11 or later systems, TASM Workloads rule is enabled.\nAGId SMALLINT\nNOT NULLThis ﬁeld is deprecated and returns a value of zero.\nRelWgt SMALLINT\nNOT NULLThis ﬁeld is deprecated and returns a value of zero.\nNumTasks INTEGER\nNOT NULLAverage number of tasks of online nodes. The ﬁeld is the result of:\nNumTasks = SUM of (NumTasks-i) / N\nwhere:\nNumTasks-i is the number of tasks assigned to the WD at the end of the reporting period.\ni varies from 1 to N, where N is the number of online nodes.\nQWaitTime FLOAT\nNOT NULLTotal wait time in milliseconds that work requests waited on an input queue before being\nserviced.\nQWaitTimeMax FLOAT\nNOT NULLMaximum time in milliseconds that work requests waited on an input queue before being\nserviced.\nThe ﬁeld is the result of:\nQWaitTimeMax = MAX (QWaitTimeMax-i)\nwhere:\nQWaitTimeMax-iis QWaitTimeMax in each online node.\ni varies from 1 to N, where N is the number of online nodes.\nCPUUserPct FLOAT\nNOT NULLWeighted average of CPUUserPct of each node.\nThis ﬁeld is the result of:\nCPUUserPct = SUM of (CPUUserPct-i* ScalingFactor-i) / SUM of (ScalingFactor-i)\nwhere:\nCPUUserPct-i is calculated as:\n(CPUUServAwt + CPUUServDisp + CPUUServMisc + CPUUExecAwt +\nCPUUExecDisp + CPUUExecMisc) * 100 /(NCPUs*Centisecs*10)\nNCPUs is the number of CPUs in the node.\ni varies from 1 to N, where N is the number of online nodes.\nScalingFactor-i is the node CPU normalization factor in each node.\nThe CPU times are in milliseconds.\nThe Parser CPU times are included in the Dispatcher CPU times.\nWorkMsgMaxDelay FLOAT\nNOT NULLGeneral indicator only. This ﬁeld is result of the following calculation:\nWorkMsgMaxDelay = MAX (WorkMsgMaxDelay-i)\nwhere:\nWorkMsgMaxDelay-iis calculated in each online node as:\nWorkMsgsendDelayMax + WorkMsgReceiveDelayMax\ni varies from 1 to N, where N is the number of online nodes.\nLake - Monitor Resources and Performance\nPage 194 of 420Field/Column Name Data T ype Description\nWorkMsgMaxDelay does not represent the subtotal of the same message on the send and\nreceive side.\nWorkTypeInuseMax INTEGER\nNOT NULLTotal of the AMP Worker Task (AWT) columns:\nWorkTypeInuseMax = MAX (WorkTypeInuseMax-i)\nwhere:\nWorkTypeInuseMax-i is the sum of WorkTypeMax00 through WorkTypeMax15 in\neach node.\ni varies from 1 to N, where N is the number of online nodes.\nWorkTimeInuseAvg FLOAT\nNOT NULLAverage number of AWTs used. This ﬁeld is result of:\nWorkTimeInuseAvg = SUM of (WorkTimeInuse-i) / N\nwhere:\nWorkTimeInuse-i is calculated in each online node as:\nWorkTimeInuse/(Centisecs * 10 * NCPUs)\nNCPUs is the number of CPUs in the node.\ni varies from 1 to N, where N is the number of online nodes.\nThis value is available in the ResSpsView view as AwtUsedAvg.\nIODelay FLOAT\nNOT NULLNumber of I/Os that are delayed. This ﬁeld is result of:\nProcBlksFsgRead + ProcBlksFsgWrite + ProcBlksFsgNIOs\nIODelayTime FLOAT\nNOT NULLTotal time the I/O is delayed for. This ﬁeld is the result of:\nProcWaitFsgRead + ProcWaitFsgWrite + ProcWaitFsgNIOs\nPhysicalRead FLOAT\nNOT NULLNumber of physical reads performed for this period. This ﬁeld is the result of:\nFilePDbAcqReads + FilePDbPreReads + FilePCiAcqReads + FileSDbAcqReads +\nFileSCiAcqReads + FileTJtAcqReads + FileAPtAcqReads + FilePCiPreReads +\nFileSDbPreReads + FileSCiPreReads + FileTJtPreReads + FileAPtPreReads\nPhysicalReadKB FLOAT\nNOT NULLNumber of physical reads in KB performed for this period. This ﬁeld is result of:\nFilePDbAcqReadKB + FilePDbPreReadKB + FilePCiAcqReadKB + FileSDbAcqReadKB +\nFileSCiAcqReadKB + FileTJtAcqReadKB + FileAPtAcqReadKB + FilePCiPreReadKB +\nFileSDbPreReadKB + FileSCiPreReadKB + FileTJtPreReadKB + FileAPtPreReadKB\nPhysicalWrite FLOAT\nNOT NULLNumber of physical writes performed for this period. This ﬁeld is result of:\nFilePDbFWrites + FilePCiFWrites + FileSDbFWrites + FileSCiFWrites + FileTJtFWrites +\nFileAPtFWrites\nPhysicalWriteKB FLOAT\nNOT NULLNumber of physical writers in KB performed for this period. This ﬁeld is result of:\nFilePDbFWriteKB + FilePCiFWriteKB + FileSDbFWriteKB + FileSCiFWriteKB +\nFileTJtFWriteKB + FileAPtFWriteKB\nLogicalRead FLOAT\nNOT NULLNumber of logical reads performed for this period. This ﬁeld is result of:\nFilePDbAcqs + FilePDbPres + FilePCiAcqs + FileSDbAcqs + FileSCiAcqs + FileTJtAcqs +\nFileAPtAcqs + FilePCiPres + FileSDbPres + FileSCiPres + FileTJtPres + FileAPtPres\nLogicalReadKB FLOAT\nNOT NULLNumber of logical reads in KB performed for this period. This ﬁeld is result of:\nFilePDbAcqKB + FilePDbPresKB + FilePCiAcqKB + FileSDbAcqKB + FileSCiAcqKB +\nFileTJtAcqKB + FileAPtAcqKB + FilePCiPresKB + FileSDbPresKB + FileSCiPresKB +\nFileTJtPresKB + FileAPtPresKB\nLogicalWrite FLOAT\nNOT NULLNumber of logical writes performed for this period. This ﬁeld is result of:\nFilePDbDyRRels + FilePCiDyRRels + FileSDbDyRRels + FileSCiDyRRels + FileTJtDyRRels\n+ FileAPtDyRRels\nLogicalWriteKB FLOAT Number of logical writes in KB performed for this period. This ﬁeld is result of:\nLake - Monitor Resources and Performance\nPage 195 of 420Field/Column Name Data T ype Description\nNOT NULL FilePDbDyRRelKB + FilePCiDyRRelKB + FileSDbDyRRelKB + FileSCiDyRRelKB +\nFileTJtDyRRelKB + FileAPtDyRRelKB\nVPId FLOAT\nNOT NULLVirtual partition ID.\nWaitIO FLOAT\nNOT NULLNumber of milliseconds tasks in WD waited for I/O over the reporting period.\nWaitIO is updated when the wait for I/O is completed.\nWaitOther FLOAT\nNOT NULLNumber of milliseconds tasks in WD waited for reasons other than I/O over the reporting\nperiod (for example, a task waiting for a message).\nWaitOther is updated when wait is completed.\nCPURunDelay FLOAT\nNOT NULLNumber of milliseconds tasks in the WD sat in the CPU runqueue waiting to run over the\nreporting period.\nThis data can be used in determining demand for the virtual partition and Workload Share\nPercent. The Workload Share Percent is a workload management method.\n*If the CPU and I/O percentages for a virtual partition or WD are below their relative share\nvalues and the CPURunDelay values are low, there was insufﬁcient demand to meet the\nshare percentage. If the CPURunDelay values are high, higher tier SQL requests were\nallocated more resources so that there were insufﬁcient resources remaining to allocate to\nSQL requests in this WD to meet its relative share.\nA virtual partition divides a system so that a percentage of resources are allocated to a\ncollection of workloads. A virtual partition can consist of WDs from all management\nmethods.\nIOSubmitted FLOAT\nNOT NULLNumber of I/Os submitted on behalf of this WD.\nIOSubmittedKB FLOAT\nNOT NULLKB of I/O submitted on behalf of this WD.\nIOCompleted FLOAT\nNOT NULLNumber of AgeOut Now data blocks not to keep in memory (fsgcache) and to be written to\ndisk.\nIOCompletedKB FLOAT\nNOT NULLKB of AgeOut Now data blocks not to keep in memory (fsgcache) and to be written to disk.\nIOCriticalSubmitted FLOAT\nNOT NULLNumber of I/Os submitted with critical status. These I/Os run at top priority instead of being\nbased on the I/O priority of the SQL request.\nIOCriticalSubmittedKB FLOAT\nNOT NULLKB of I/O submitted with critical status. These I/Os run at top priority instead of being based\non the I/O priority of the SQL request.\nDecayLevel1IO FLOAT\nNOT NULLNumber of times SQL requests in the WD reach decay level 1 due to I/O.\nDecayLevel1IO is used for Timeshare WDs** only.\nDecayLevel2IO FLOAT\nNOT NULLNumber of times SQL requests in the WD decay level 2 due to I/O.\nDecayLevel2IO is used for Timeshare WDs** only.\nDecayLevel1CPU FLOAT\nNOT NULLNumber of times SQL requests in the WD reach decay level 1 due to CPU.\nDecayLevel1CPU is used for Timeshare WDs** only.\nDecayLevel2CPU FLOAT\nNOT NULLNumber of times SQL requests in the WD reach decay level 2 due to CPU.\nDecayLevel2CPU is used for Timeshare WDs** only.\nTacticalExceptionIO FLOAT Number of times SQL requests in the WD reach a tactical per-node exception due to I/O.\nLake - Monitor Resources and Performance\nPage 196 of 420Field/Column Name Data T ype Description\nNOT NULL An exception, used only for Tactical WDs, is created for each Tactical WD***.\nTacticalExceptionCPU FLOAT\nNOT NULLNumber of times SQL requests in the WD reach a tactical per-node exception due to CPU.\nTacticalExceptionCPU is used for Tactical WDs***.\n** The Timeshare Workload Management Method workload can be assigned to one of four stepped access levels, Top, High, Medium, or Low. The higher access levels are given\nlarger access rates than the lower levels. For example, an SQL request assigned to a Timeshare WD with a Top access level, which has an access rate of 8, gets eight times the\namount of resources than an SQL request assigned to a Low access level.\nTimeshare workloads are assigned resources remaining after all allocations have been made for tactical and Workload Share Percent workloads.\n*** The Tactical Workload Management Method workload yields the fastest available response time and runs at the highest tier, preempting all resource needs of other tiers. This\nmethod is well suited for critical, short-running queries that require fast response times.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a MONITOR WD request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum NameBytesField Value\n0001 Req 14 Request MONITOR WD\n0003 Data 6 MonVerID 9\n0004 Resp 6 Buffer Size 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe MONITOR WD request returns the following approximate values when TASM Workloads are enabled:\nThe Monitor WD request commonly returns values in text character format. Your application program may return the values in a different format or display.\nResRate: 30;      AMP Nodes: 1;    PE Nodes: 1\nCollection Date/Time:  06/15/2011 18:34:01.00\nPGId VT   PP   CPUUsrPct QWaitTime QWTimeMax WkMsgMaxD WTypeMax  WTimeAvg\nWDId AGId RWgt IODelay   IODelayTi PhyRead   PhyReadMB PhyWrite  PhyWriteMB\n          NPrc Reserved1 Reserved2 LogRead   LogReadMB LogWrite  LogWriteMB\n          VPId WaitIO    WaitOther CPURunDly\n               IOsubmit  IOSubmKB  IOComplet IOComplKB IOCriticl IOCritKB\n               Decay1IO  Decay2IO  Decay1CPU Decay2CPU TacExcpIO TacExcpCPU\n==== ==== ==== ========= ========= ========= ========= ========= =========\nSUCCESS parcel:\nStatementNo=2,    ActivityCount=10,\nActivityType=202, FieldCount=39\n   0 AMP     0     98.56      0.00      0.00      0.00         4      3.99\n  12    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n           132      0.00      0.00      0.00      0.00      0.00      0.00\n             1    300.00   7558.00  82602.00\n                  151.00   9664.00    151.00   9664.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n   0 PE      0      0.00      0.00      0.00      0.00         0      0.00\n  12    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n            33      0.00      0.00      0.00      0.00      0.00      0.00\n             1      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 250 AMP     0      0.00      0.00      0.00      0.00         1      1.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n          2288      0.00      0.00      0.00      0.00      0.00      0.00\n           100      0.00 119692.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\nLake - Monitor Resources and Performance\nPage 197 of 420                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 251 MISC    0      0.00      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n           160      0.00      0.00      0.00      0.00      0.00      0.00\n           100      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 251 AMP     0      0.00      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n           892      0.00      0.00      0.00      0.00      0.00      0.00\n           100      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 254 MISC    0      0.32      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n          4400      0.00      0.00      0.00      0.00      0.00      0.00\n           102      0.00 218950.00    318.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 254 AMP     0      0.00      0.00      0.00      0.00         0      0.01\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n         79844      0.00      0.00      0.00      0.00      0.00      0.00\n           102    359.00 3511485.00   1701.00\n                   38.00    228.00     38.00    228.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 254 PE      0      0.00      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n         58034      0.00      0.00      0.00      0.00      0.00      0.00\n           102    272.00 2644347.0    399.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 255 MISC    0      0.09      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n          2992      0.00      0.00      0.00      0.00      0.00      0.00\n           101      0.00 548164.00  2922.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n--------------------------------------------------------------------------\n 255 AMP     0      0.03      0.00      0.00      0.00         0      0.00\n   0    0    0      0.00      0.00      0.00      0.00      0.00      0.00\n          3520      0.00      0.00      0.00      0.00      0.00      0.00\n           101      0.00 315555.00 45137.00\n               13567.00 1722001.00  13569.00 1722255.00     0.00      0.00\n                    0.00      0.00      0.00      0.00      0.00      0.00\n                                       .\n                                       .\n                                       .\nSET RESOURCE RA TE\nSets either the ResMonitor or ResLogging rate.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT MONITOR software version ID. This can be version 2 or later.\nLake - Monitor Resources and Performance\nPage 198 of 420Element Data T ype Description\nNOT NULL For a general explanation of monitor version choices, see MONITOR VERSION.\nsample_rate SMALLINT\nNOT NULL\nrange 0-3600 secsValue of the collection rate. This ﬁeld is used either to collect resource data or to log resource data to\nthe resource usage tables.\nYou can specify one of the following:\nThe ResMonitor rate value if you want to change the resource monitoring rate.\nThe ResLogging rate value if you want to change the resource logging rate.\nThe value must be an integral divisor of 3600.\nZero to turn off the resource collection or logging.\nlog_change VARCHAR (1) Indicator of whether this rate applies to the ResLogging or ResMonitor rate:\nY or y = ResLogging rate\nN, n, NULL, or blank = ResMonitor rate\nvirtual_change VARCHAR (1) This ﬁeld is deprecated.\nMonitor Privileges\nTo use this request, you must have the SETRESRATE privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - SET RESOURCE RA TE\nYou can set the ResMonitor or ResLogging rates using the SET RESOURCE RATE request. For a description of these rates, see Data Collection.\nResMonitor and ResLogging are independent, because you can monitor without wanting to log to the resource usage tables, or you can log without monitoring.\nYou can set only one ResMonitor or ResLogging rate within one SET RESOURCE RATE request. For example, to set both the ResMonitor and ResLogging rates at the same time, you\nmust issue two SET RESOURCE RATE requests and specify the USING Data String appropriately.\nResource data is placed in a memory repository separate and independent from session usage data. Therefore, any changes in the ResMonitor rate does not impact session usage\ndata.\nResource usage data collected by the ResMonitor rate is collected and reported differently from session usage data. Whereas session usage data is collected cumulatively, resource\ndata is collected for a collection period. The data reported is based on the activity that occurred during that collection period and does not include any cumulative data over collection\nperiods.\nThere is a difference between saving statistics in the resource memory repository and returning the data for display. Resource data can be saved after a collection rate is set to a\nnonzero rate, but no return of data occurs until a MONITOR request is issued.\nThe ResMonitor rate and the ResLogging rate are saved on disk in the Version Record when changed. For this reason, the SET RESOURCE RATE request can block if someone else is\nupdating the GDO control record. If a block occurs, you must wait until the block clears.\nWhen you run the SET RESOURCE RATE request, the change is saved in the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view) and written to the\nsystem Console running Database Windows.\nCLIv2 Response Parcels\nThe response returned from the database contains the following sequence of parcel types.\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 Activity Count = Contains previous rate.\nActivity Type = 87 (PCLSETRESSR)\nDataInfo 71 6 to 64100 This parcel is present if request was IndicReq parcel; depends on the data type.\nEndStatement 11 6 StatementNo: 2-byte integer\nEndRequest 12 4 None\nSample Input - CLIv2 Request\nLake - Monitor Resources and Performance\nPage 199 of 420This example shows how the parcels for a SET RESOURCE RATE request, built by CLIv2, look when sent to the database server using a sample_rate of 600 seconds and a\nlogging_change of Y. The size of the response buffer is set in the example at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 21 Request SET RESOURCE RATE\n0030 Data 11 MonVerID\nSampleRate\nLoggingChg\nVirtualChg2\n600\nY\nN\n0004 Resp 6 Buffer Size 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nWith a sample_rate of 600 and a logging_change of y, this example shows the values returned in character text format for the SET RESOURCE RATE request. Your application program\nmay display returned values in a different format.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 60\n ActivityType: 87    FieldCount: 0\nDataInfo parcel:\n FieldCount: 0\nEndStatement.\nEndRequest.\nRelationship between SET RESOURCE RA TE and MONIT OR PHYSICAL  RESOURCE or MONIT OR VIRTUAL\nRESOURCE\nYou must run the SET RESOURCE RATE request to activate resource data collection before you run a MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request.\nYou must set the ResMonitor rate to nonzero, otherwise you get an error message.\nA change in the resource collection rate by User A, for example, may affect the data reported by MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE request made\nby User B. If the ResMonitor rate is altered, User B gets a warning message when running a subsequent MONITOR VIRTUAL RESOURCE or MONITOR PHYSICAL RESOURCE\nrequest.\nRelationship between SET RESOURCE RA TE and MONIT OR PHYSICAL  SUMMAR Y or MONIT OR VIRTUAL\nSUMMAR Y\nThe SET RESOURCE RATE request sets the ResMonitor and ResLogging rates, which are among the responses returned by the MONITOR PHYSICAL SUMMARY or MONITOR\nVIRTUAL SUMMARY request. Any change to either the ResMonitor or ResLogging rate causes changes in the corresponding response returned by the MONITOR VIRTUAL SUMMARY\nor MONITOR PHYSICAL SUMMARY request.\nYou must set ResMonitor to a nonzero rate for MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL SUMMARY to return meaningful resource usage data. A zero ResMonitor rate\nreturns NULL for resource usage information.\nSET SESSION ACCOUNT\nChanges the account string for the session or for the request.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nLake - Monitor Resources and Performance\nPage 200 of 420Element Data T ype Description\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT\nNOT NULLID of the host on which the session was issued. host_id cannot exceed 1023. A host_id of zero identiﬁes the\ndatabase operator Console. If you do not specify a valid host_id, an error message is returned to CLIv2.\nUse only if you have DBA privileges.\nsession_no INTEGER\nNOT NULLNumber of the session. session_no combined with the host_idproduces a unique Session ID. If you do not\nspecify a valid session_no, an error message is returned to CLIv2. Use only if you have DBA privileges.\naccount VARCHAR (512)\nNOT NULLAccount string for the session or request.\nsess_req VARCHAR (1) Indicator of how the new account or priority affects requests for a speciﬁed session.\nIf you specify Y or y, the change applies to all current and future requests for a speciﬁed session. If no\nrequests or steps are running, the new account/priority takes effect at the next request, and the\nDBC.SessionTbl table reﬂects the new account/priority for the current session.\nIf you specify NULL, blank, N, or n, the change applies to the current request for the speciﬁed session. If no\nrequest is running, the next request for the speciﬁed session has the old account/priority.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION or an equivalent privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - SET SESSION ACCOUNT\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nThe account or priority change is recorded in the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view) with the following text in the TEXT column:\nSESSION  session_no   HOSTID  host_id  CHANGED FROM ACCOUNT  account  TO ACCOUNT  account  ON  sess_req\nThe EVENT_TAG ﬁeld contains an event number. THEDATE and THETIME ﬁelds, which make up the index of the DBC.SW_Event_Log table (accessible from the\nDBC.Software_Event_LogV view), contain the date and time of the account/priority change. All other ﬁelds of the table are blank.\nWhen TASM Workloads are enabled, the SET SESSION ACCOUNT request fails and returns an error or succeeds for a session. If the request succeeds for a session, the session in\nwhich the request is running continues to run the old (existing) account string, but future requests run with the new account string.\nCLIv2 Response Parcels\nThe response returned from the database contains the following sequence of parcel types:\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 108 (SET SESSION ACCOUNT)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicReq parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)This record contains the old account and an error code.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nLake - Monitor Resources and Performance\nPage 201 of 420The Data parcel sent from the host must be 39 bytes long for record mode or 40 bytes long for indicator mode.\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe statement response returns a Record parcel containing:\nThe Column Name and Column Contents ﬁeld values are not returned in the Record parcel. These values are returned in an IDENTIFY request.\nField/Column Name Data T ype Description\nOldAccount VARCHAR (128)\nCHARACTER SET UNICODE\nNOT NULLExisting account string.\nErrorCode INTEGER\nNOT NULLAn error code.\nThe Error Code column can contain any of the following return codes:\nError-Name Code Text\nErrPFMNoAr 3250 No access right.\nErrPFMBadSes 3256 User entered invalid session x HostId.\nErrPFMBadAcc 3292 User entered invalid account.\nErrPFMUpdSesTbl 3293 Failed to update the session table with the new account.\nErrPFMBadSesReqInd 3294 Invalid session/request indicator value for set session account.\nErrPFMInvSes 3295 Invalid session.\nSample Input - CLIv2 Request\nThis example of the request parcels sent from a mainframe client shows how the parcels for a SET SESSION ACCOUNT request, built by CLIv2, look when sent to the database server,\nwhere account is $Haccnt, sess_req is Y, host_id is 348, and session_no is 1000.\nIn this sample, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 22 Request SET SESSION ACCOUNT\n0003 Data 45 MonVerID 2\nHostId 348\nSessionNo 1000\nAccount $Haccnt\nSession/Request IndicatorY\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThis sample shows typical values returned in character text format for SET SESSION ACCOUNT. Your application may return values in a different format.\nSuccess Parcel:\n Statement No: 1 Activity Count: 1   \n Activity Type: 108 FieldCount: 2\nDataInfo Parcel: \n Field Count: 2 \nRecord Parcel: \n Parcel Flavor: 10 Parcel Body Length:32 \nLake - Monitor Resources and Performance\nPage 202 of 420 OldAcct: \"$MAcct\", ErrorCode = 0\nEndStatement.EndRequest.\nSET SESSION RA TE\nSets the global and local rates for updating session-level statistics in memory.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 2 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nsample_rate SMALLINT\nNOT NULL\nrange 1-3600 secondsValue of the collection interval.\nIf the global sample rate is set to zero an error is returned.\nlocal_change VARCHAR (1) Type of session to which this rate change applies.\nSpecify Y or y if the rate is set within a local session or N, n, NULL, or blank if the rate applies to global\nqueries.\nMonitor Privileges\nTo use this request, you must have the SETSESSRATE privilege as part of your default role or this privilege must be granted directly to you.\nIf you make changes to either the system or local rate, this can reset the starting point at which data is collected. Therefore, Teradata recommends that the SETSESSRATE privilege be\ngranted to a restricted number of users (such as DBAs or certain application programmers)\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes - SET SESSION RA TE\nThis request is recorded in the DBC.SW_Event_Log table (accessible from the DBC.Software_Event_LogV view) and also written to the DBW. Global rate updates are recorded only in\nthe GDO control record.\nSession usage data is placed in a separate, independent memory repository from the processor resource data. Therefore, any changes in the session monitoring rate have no impact\non the resource data. However, a user who sets a local collection rate may affect the session usage data that other users see because all session usage data is stored in the same\nmemory repository.\nSession-level usage data is collected differently from the way processor resource usage data is collected. Processor resource usage data is collected for a collection period, while\nsession usage data is collected cumulatively. The report can include cumulative data over multiple collection periods.\nMonitoring a system may cause global performance degradation. To limit the overhead cost, Teradata recommends that you set the global rate at 3600 seconds (or 1 hour) for general\nsystem monitoring. To perform problem analysis more quickly, you can set a more frequent local rate. After the analysis is done, terminate the session or set the local rate to zero. The\nlower global rate takes effect again in that session.\nTo avoid confusion, Teradata recommends that applications not query data more frequently than the faster of the two rates. If MONITOR SESSION requests are run too frequently, one\nof the following may occur:\nThe user application program sees duplicated data and CPU resources are wasted.\nThe user application program sees data showing the result of an alteration caused by another user.\nTeradata also recommends that you restrict the SET SESSION RATE privilege to the database administrator or system administrator.\nA change to the global rate may cause a block because:\nSomeone else is changing the global rate at the same time.\nRate change requests are queued and processed in the order received because the system does not allow different rates to be used on different processors. The system\nmakes sure that all processors use the same rate.\nLake - Monitor Resources and Performance\nPage 203 of 420The GDO control record is being updated.\nRate Scenario 1: Effects on Other Users When Increasing the Global Rate\nUser A has the SET SESSION RATE privilege. User B does not.\nStep Action\n1 User A changes the global rate from 10 minutes to 5 minutes at 8:55. User A now requests data every 5 minutes instead of 10 minutes.\n2 User A makes a request at 8:57. Data returned shows data from the interval of 8:50 to 8:57, plus the cumulative data from 8:00 to 8:50. By forcing an\nupdate of the data at 8:57, User A has reset the collection start time (or time-stamp) to 8:57 because the current time (8:57) minus the time-stamp of\nthe data (8:50) is greater than the session collection rate of 5 minutes. Resetting the collection start time means resetting the time from which the\ninterval is calculated to 8:57.\n3 User A makes a next request at 9:00. Data returned is the same data that was returned at 8:57. The reason is that the current session-level data that\nwas available was considered current, that is, the age of the data (9:00 - 8:57 = 3) is less than the session collection rate of 5.\nIf User B is not aware that the global rate changed to 5 minutes, the application for User B continues to request data every 10 minutes. User B is requesting data at a less frequent rate\nthan the data collection rate. User B may not notice a difference in data, because the data is cumulative. However, because all session resource data is deposited in the same memory\npool, a change in collection rate by another user may affect the data User B sees.\nAlthough transparent to the user, the user data impacted depends on which user request is received ﬁrst. This typically happens when the user is not requesting data at the same rate\nas data is collected.\nFor example, User A makes a request at 9:00 and the request made by User A is received before the request (also at 9:00) made by User B. As described previously, User A sees\ndata returned that is cumulative from 8:00 to 8:57.\nStep Action\n1 The request made by User B at 9:00 is queued. User B gets the cumulative data from 8:00 to 8:57 because User A made a request at 8:57. The request\nmade by User B does not trigger an update because the request made by User A resets the time-stamp (or start time) to 8:57, and the elapsed time\nbetween 8:57 to 9:00 is less than 5 minutes (the data collection rate of the session). Thus, User B gets data from 8:50 to 8:57, plus the cumulative data\nfrom 8:00 to 8:50. There is no difference in the data User A or User B sees as a result of the request order.\n2 User B gets a warning message that the rate changed to 5 minutes. User B can check to see what the new global rate is if MONITOR SESSION is being\nrun. The data returned in the ﬁrst Record parcel is the SampleSec, which indicates the duration of the collection period in seconds. User B can see that\nSampleSec reports 300 seconds (or 5 minutes) instead of 600 seconds (or 10 minutes).\nRate Scenario 2: Effects on Other Users When Increasing the Local Rate\nUsers A and B are requesting session-level data at the same rate as data is collected.\nStep Action\n1 User A wants to troubleshoot a new application program and at 9:00 sets a local rate of 1 minute within their session. The local rate now overrides the\nglobal rate of 10 minutes within the session for User A. User A now requests data every 1 minute instead of 10 minutes.\n2 User A makes a request at 9:01. Data returned shows data from the interval of 9:00 to 9:01 (because User A has reset the session beginning collection\ntime to 9:00), plus the cumulative data from 8:00 to 9:00.\n3 User A makes the next request at 9:02. Data returned shows data from the interval of 9:01 to 9:02, plus the cumulative data from 8:00 to 9:01. From now\non, responses to queries for User A returns data updated every 1 minute.\nThe actions made by User A in setting a local rate does not change the current global collection rate of 10 minutes.\nThe way the session for User B is calculating its collection interval does not change. Therefore, the collection rate and request rate for User B continues at 10-minute intervals.\nHowever, because all session usage data is stored in the same memory repository, the more frequent collection for User A may affect the cumulative data that User B may see.\nUser B may see more dynamic data than previously and receive more data than expected. Each of the requests made by User B can include data from one collection period mixed in\nwith data from a subsequent collection period that was initiated by a different use. The 1-minute interval collection for User A.\nWhile the local rate for User A is in effect, User B makes a request at 9:00. Data returned shows data from the interval of 8:50 to 9:00, plus the cumulative data from 8:00 to 8:50.\nIf User B makes a request at 9:04, User B sees data returned from 9:00 to 9:04, plus the cumulative data from 8:00 to 9:00. Because of the local data collecting for User A, User B can\ntake advantage of the faster collection rate and thus receive more data than expected.\nHowever, if the local rate for User A is not in effect and User B makes a request at 9:04, the data returned is from the interval of 8:00 to 9:00 only.\nRate Scenario 3: How Request Order Affects Data Reported\nThe DBA sets the global rate at 8:00 a.m. to collect every 10 minutes. User A decides to reset the global or global rate from 10 minutes to 5 minutes. In addition, User B decides to\nrequest session-level data at a different rate than the data collection rate.\nStep Action\n1 User A resets the global session collection rate to 300 seconds (or 5 minutes) at 9:00, thus setting the timestamp for any current data to 9:00.\nLake - Monitor Resources and Performance\nPage 204 of 420Step Action\n2 At 9:00, User A also sets a local collection rate of 1 minute for their session.\n3 User B makes a request for data at 9:05:25.\n4 User B gets the cumulative data from 8:00 to 9:05:25 and, in the process, resets the data time-stamp to 9:05:25.\nUser A does not know that the data timestamp is altered by the request made by User B because User A had sent in a request immediately after the request made by User B.\nThe request made by User A for data at 9:06:00 is queued behind the request made by User B of 9:05:25. Because the current data is considered current (9:06:00 - 9:05:25 = 0:00:35,\nwhich is less than the local collection rate of 1 minute), User A gets the same data (from 8:00 to 9:05:25) that User B received.\nThe request order affects the data User A gets. If not for the earlier request made by User B, User A may have received data from the 8:00 to 9:06 interval, which User A likely\nexpected.\nRate Scenario 4: Different Collection and Request Rates\nUsers A and B are running different application programs and are monitoring the applications with MONITOR SESSION or MONITOR VIRTUAL SUMMARY. User A has the SET\nSESSION RATE privilege. User A is requesting session-level data at a different rate from the rate at which data is collected.\nUser A is using the global collection rate of 10 minutes set by the DBA. However, User A wants to troubleshoot a new program and decides to set the application program to request\ndata every 6 seconds.\nClearly, User A is requesting data more frequently than the data collection rate. Every 6 seconds, User A sees a data display that show the same data until the 10-minute interval has\nelapsed.\nData returned from monitoring the session for User A is likely to be more meaningful if User A sets the global collection rate to the same rate as the request rate.\nCLIv2 Response Parcels\nThe response returned from the the database contains the following sequence of parcel type:\nParcel Sequence Parcel NumberLength\n(Bytes)\nComments/Key Parcel Body Fields\nSuccess 8 18 to 273 Activity Count = Previous rate\nActivity Type = 83 (PCLSETSESSR)\nDataInfo 71 6 to 64100 This parcel is present if request was IndicReq parcel; depends on the data type.\nEndStatement 11 6 StatementNo: 2-byte integer\nEndRequest 12 4 None\nSample Input - CLIv2 Request\nThis example shows how the parcels for a SET SESSION RATE request, built by CLIv2, look when sent to the database server with a sample_rate of 6 and a local_change of y. In the\nexample, the size of the response buffer is set at the maximum (64,000 bytes). The minimum response size is 32,000 bytes.\nNumber Length Body\nNum Name BytesField Value\n0001 Req 20 Request SET SESSION RATE\n0003 Data 9 MonVerID\nSampleRate\nLocalChg2\n6\nY\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nWith a sample_rate of 6 and a local_change of y, this example shows the values returned in character text format for the SET SESSION RATE request. Your application program may\ndisplay returned values in a different format.\nLake - Monitor Resources and Performance\nPage 205 of 420Success parcel:\n StatementNo: 1    ActivityCount: 0\n ActivityType: 83    FieldCount: 0\nDataInfo parcel:\n FieldCount: 0\nEndStatement.\nEndRequest.\nRelationship between SET SESSION RA TE and MONIT OR SESSION\nYou must run the SET SESSION RATE request to activate session-level data collection before you run a MONITOR SESSION request. Therefore, either the global rate or local rate must\nbe set to nonzero. If both rates are set to zero, an error message is returned.\nFor information on this PMPC PM/API request relationship, see Relationship Between MONITOR SESSION and SET SESSION RATE.\nRelationship between SET SESSION RA TE and MONIT OR PHYSICAL  SUMMAR Y or MONIT OR VIRTUAL  SUMMAR Y\nChanges to the session-level rates (global and local) speciﬁed by SET SESSION RATE are reported in the data returned by MONITOR PHYSICAL SUMMARY or MONITOR VIRTUAL\nSUMMARY.\nThe local rate reported is your own local rate. If the local rate is not set, the local rate is reported as zero.\nAs more session-level monitoring is done (by setting a faster SET SESSION RATE), the resulting overhead may increase the level of CPU usage (reported in MONITOR PHYSICAL\nSUMMARY or MONITOR VIRTUAL SUMMARY data) by your system. However, this may depend on the size of the rate change and the type of work done by other sessions.\nSystem PMPC Open APIs (SQL Interfaces)\nThis section describes how to access PMPC data through SQL interfaces consisting of UDFs. The PMPC UDFs, like the PMPC PM/API requests, are used to monitor system and\nsession-level performance and set collection and logging rates. However, the PMPC UDFs can be invoked from any application.\nThe PMPC UDFs provide similar functionality to the PMPC PM/API requests.\nYou need not fully qualify PMPC UDFs by the database name, SYSLIB, because the DBS automatically searches that database for these UDFs.\nAbortListSessions\nAbortSessions\nIdentifyDatabase\nIdentifySession\nIdentifyTable\nIdentifyUser\nMonitorAMPLoad\nMonitorAWTResource\nMonitorMySessions\nMonitorPhysicalConﬁg\nMonitorPhysicalResource\nMonitorPhysicalSummary\nMonitorSession\nMonitorSessionRate\nMonitorSQLCurrentStep\nMonitorSQLSteps\nMonitorSQLText\nMonitorSystemPhysicalConﬁg\nMonitorVirtualConﬁg\nMonitorVirtualResource\nMonitorVirtualSummary\nMonitorWD\nMonitorWDRate\nSetResourceRate\nSetSessionAccount\nSetSessionRate\nAbortListSessions\nAborts the session and lists the status of the aborted sessions.\nAbortListSessions Syntax\nAbortListSessions Usage Notes\nExample: AbortListSessions\nAbortListSessions Syntax\nREPLACE FUNCTION SYSLIB.AbortListSessions (\n  HostIdIn  SMALLINT,\n  UserNameIn  TD_ANYTYPE,\n  SessionNoIn  INTEGER,\nLake - Monitor Resources and Performance\nPage 206 of 420  LogoffSessions  VARCHAR(1) CHARACTER SET LATIN,\n  UserOverride  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER,\n    UserName VARCHAR(128) CHARACTER SET UNICODE,\n    AbortStatus CHAR CHARACTER SET LATIN\n  )\n  ... \n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on. A value of -1 indicates all hosts.\nUserNameIn\nUser name of the session. An asterisk (*) or NULL indicates all users.\nSessionNoIn\nID of the session to abort. A value of zero indicates all sessions.\nLogoffSessions\nIndicator of whether to log off sessions to Vantage after aborting them:\nY = Log off and end sessions.\nN or NULL = Do not log sessions off.\nUserOverride\nIndicator of whether to override an ABORT SESSION failure:\nY = Override the ABORT SESSION request to fail in any of the following cases:\nAn identiﬁed session is being session-switched.\nAn identiﬁed session is running its own ABORT SESSION request.\nAn identiﬁed session has a PEState of IDLE: IN-DOUBT as a result of a 2PC.\nSessions are marked IN-DOUBT by the 2PC protocol, which governs how transactions are committed by multiple systems that do not share memory. The\nprotocol guarantees that either all systems commit or all roll back.\nN or NULL = Do not override.\nHostId\nLogical host ID of (or client) the aborted sessions were logged on to. For a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE. For a session, the\ncombination of a host ID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nSessionNo\nNumber of the session that was aborted. With a given host ID, a session number uniquely identiﬁes a session on the Teradata system. This value is assigned by the host (or\nclient) at logon time.\nUserName\nUser name of the session that was aborted.\nAbortStatus\nStatus of the sessions aborted:\nI = In-Doubt\nA = Aborting a transaction\nC = Committing a transaction\nE = Executing (running) an ABORT SESSION request\nS = Switching\nAn empty string = A state other than the preceding. This value returns when issuing an SQL function.\nFor an ABORT without LOGOFF, any status except NULL indicates the reason the request did not impact the associated session.\nFor an ABORT with LOGOFF, an I, E, or S status value indicates that the associated session cannot be aborted or logged off.\nAbortListSessions Usage Notes\nThis table function is only supported in Constant Mode.\nAbortListSessions cannot be used to end delayed utility sessions because these sessions are not completely logged on.\nThis function provides similar functionality to the PMPC ABORT SESSION request with ListSessions set to ‘N’ or ‘No’.\nExample: AbortListSessions\nSELECT * FROM TABLE (AbortListSessions(1, 'User14', 0, 'Y', 'Y')) AS t1;\n *** Query completed. 5 rows found. 4 columns returned.\n *** Total elapsed time was 4 seconds.\nHostId    SessionNo  UserName    AbortStatus\n------  -----------  ----------- -----------\n     1         1007  USER14\n     1         1011  USER14\n     1         1010  USER14\n     1         1009  USER14\n     1         1008  USER14\nLake - Monitor Resources and Performance\nPage 207 of 420AbortSessions\nAborts any outstanding request or transaction of one or more sessions, and optionally logs those sessions off the database.\nIf successful, this function returns the number of sessions that were aborted.\nAbortSessions Syntax\nAbortSessions Usage Notes\nExamples: AbortSessions\nAbortSessions Syntax\nREPLACE FUNCTION SYSLIB.AbortSessions (\n  HostIdIn  SMALLINT,\n  UserNameIn  TD_ANYTYPE,\n  SessionNoIn  INTEGER,\n  LogoffSessions  VARCHAR(1) CHARACTER SET LATIN,\n  UserOverride  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS INTEGER\n  ... \n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on. A value of -1 indicates all hosts.\nUserNameIn\nUser name of the session. An asterisk (*) or NULL indicates all users.\nSessionNoIn\nID of the session to abort. A value of zero indicates all sessions.\nLogoffSessions\nIndicator of whether to log off sessions to Vantage after aborting them:\nY = Log off and end sessions.\nN or NULL = Do not log sessions off.\nUserOverride\nIndicator of whether to override an ABORT SESSION failure:\nY = Override the ABORT SESSION request to fail in any of the following cases:\nAn identiﬁed session is being session-switched.\nAn identiﬁed session is running its own ABORT SESSION request.\nAn identiﬁed session has a PEState of IDLE: IN-DOUBT as a result of a 2PC.\nSessions are marked IN-DOUBT by the 2PC protocol, which governs how transactions are committed by multiple systems that do not share memory. The\nprotocol guarantees that either all systems commit or all roll back.\nN or NULL = Do not override.\nAbortSessions Usage Notes\nThe AbortSessions function provides similar functionality to the PMPC ABORT SESSION request with ListSessions set to 'Y' or 'Yes'. For information about this interface, see ABORT\nSESSION.\nExamples: AbortSessions\nExample: Using AbortSessions\nSELECT AbortSessions (1, 'User14', 0, 'Y', 'Y');\n* * * Query completed. One row found. one column returned.\n* * * Total elapsed time was 5 seconds.\nAbortSessions (1, 'User14', 0, 'Y', 'Y')\n----------------------------------------\n                                      5\nExample: Using AbortSessions with MonitorSession\nSELECT AbortSessions (HostId, UserName, SessionNo, 'Y', 'Y');\n     FROM TABLE (MonitorSession(-1, '*', 0)) AS t1\nWHERE username= 'user14';\n* * * Query completed. 5 rows found. one column returned.\n* * * Total elapsed time was 2 seconds.\nAbortSessions (HostId, UserName, SessionNo, 'Y', 'Y')\n----------------------------------------------------\n                                                   1\n                                                   1\nLake - Monitor Resources and Performance\nPage 208 of 420                                                   1\n                                                   1\nIdentifyDatabase\nReturns the name of the speciﬁed database ID.\nIdentifyDatabase Syntax\nIdentifyDatabase Usage Notes\nIdentifyDatabase Example\nIdentifyDatabase Syntax\nREPLACE FUNCTION SYSLIB.IdentifyDatabase (\n  DatabaseId  INTEGER\n) RETURNS VARCHAR(128) CHARACTER SET UNICODE\n  ...\n;\nSyntax Elements\nDatabaseId\nDatabase ID.\nIdentifyDatabase Usage Notes\nThe IdentifyDatabase function provides similar functionality to the PMPC IDENTIFY DATABASE request. For information about this interface, see IDENTIFY.\nIdentifyDatabase Example\nSELECT IdentifyUser(blk1userid) as \"blocking user\",\n    IdentifyTable(blk1objtid) as \"blocking table\",\n    IdentifyDatabase(blk1objdbid) as \"blocking db\"\nFROM TABLE (MonitorSession(-1,'*',0)) AS t1\nWHERE Blk1UserId > 0;\n *** Query completed. One row found. 3 columns returned.\n *** Total elapsed time was 4 seconds.\nblocking user               blocking table             blocking db\n--------------------------- -------------------------- -------------\nuser1                       skewAmp1                   DBaaa\nIdentifySession\nReturns the name of the user, by session, who is causing a block.\nIdentifySession Syntax\nIdentifySession Usage Notes\nIdentifySession Example\nIdentifySession Syntax\nREPLACE FUNCTION SYSLIB.IdentifySession (\n  HostId INTEGER,\n  SessionNo  INTEGER\n) RETURNS VARCHAR(128) CHARACTER SET UNICODE\n  ... \n;\nSyntax Elements\nHostId\nID of the blocking host.\nSessionNo\nNumber of the session that is blocked.\nIdentifySession Usage Notes\nThe IdentifySession function provides similar functionality to the PMPC IDENTIFY SESSION request. For information about this interface, see IDENTIFY.\nIdentifySession Example\nSELECT IdentifySession(blk1Hostid,blk1sessno)\nFROM TABLE (MonitorSession(-1,'*',0)) AS t1\nWHERE Blk1UserId > 0;\n *** Query completed. One row found. One column returned.\nLake - Monitor Resources and Performance\nPage 209 of 420 *** Total elapsed time was 1 second.\nIdentifySession(Blk1HostId,Blk1SessNo)\n--------------------------------------\nUSER1 \nIdentifyT able\nReturns the name of the speciﬁed table ID.\nIdentifyTable Syntax\nIdentifyTable Usage Notes\nIdentifyTable Example\nIdentifyTable Syntax\nREPLACE FUNCTION SYSLIB.IdentifyTable (\n  TableID  INTEGER\n) RETURNS VARCHAR(128) CHARACTER SET UNICODE\n  ...\n;\nSyntax Elements\nTableID\nID of the locked table.\nIdentifyTable Usage Notes\nThe IdentifyTable function provides similar functionality to the PMPC IDENTIFY TABLE request. For information about this interface, see IDENTIFY.\nIdentifyTable Example\nSELECT IdentifyUser(blk1userid) as \"blocking user\",\n    IdentifyTable(blk1objtid) as \"blocking table\",\n    IdentifyDatabase(blk1objdbid) as \"blocking db\"\nFROM TABLE (MonitorSession(-1,'*',0)) AS t1\nWHERE Blk1UserId > 0;\n *** Query completed. One row found. 3 columns returned.\n *** Total elapsed time was 4 seconds.\nblocking user                blocking table          blocking db\n---------------------------  ----------------------- -------------\nuser1                        skewAmp1                DBaaa\nIdentifyUser\nReturns the name of the speciﬁed user ID who is causing a block.\nIdentifyUser Syntax\nIdentifyUser Usage Notes\nIdentifyUser Example\nIdentifyUser Syntax\nREPLACE FUNCTION SYSLIB.IdentifyUser (\n  UserId  INTEGER\n) RETURNS VARCHAR(128) CHARACTER SET UNICODE\n  ...\n;\nSyntax Elements\nUserId\nID of the user who is causing the block.\nIdentifyUser Usage Notes\nThe IdentifyUser function provides similar functionality to the PMPC IDENTIFY USER request. For information about this interface, see IDENTIFY.\nIdentifyUser Example\nSELECT IdentifyUser(blk1userid) as \"blocking user\",\n    IdentifyTable(blk1objtid) as \"blocking table\",\n    IdentifyDatabase(blk1objdbid) as \"blocking db\"\nFROM TABLE (MonitorSession(-1,'*',0)) AS t1\nWHERE Blk1UserId > 0;\nLake - Monitor Resources and Performance\nPage 210 of 420 *** Query completed. One row found. 3 columns returned.\n *** Total elapsed time was 4 seconds.\nblocking user               blocking table          blocking db\n--------------------------- ----------------------- -------------\nuser1                       skewAmp1                DBaaa\nMonitorAMPLoad\nReturns the data from the third statement of the MONITOR AWT RESOURCE request response.\nMonitorAMPLoad Syntax\nMonitorAMPLoad Usage Notes\nMonitorAMPLoad Example\nMonitorAMPLoad Syntax\nREPLACE FUNCTION SYSLIB.MonitorAMPLoad (\n) RETURNS TABLE (\n    VprocNo SMALLINT,\n    AvailableAWTs INTEGER,\n    InUseAWTs INTEGER,\n    MsgCount INTEGER,\n    DQMsgCount INTEGER\n    AvailableAWTsForAll INTEGER\n  )\n  ...\n;\nSyntax Elements\nVprocNo\nAMP vproc number.\nAvailableAWTs\nNumber of available AMP worker tasks in each AMP.\nInUseAWTs\nNumber of active AMP worker tasks in each AMP.\nMsgCount\nNumber of messages queued for delivery to each AMP.\nDQMsgCount\nNumber of messages processed by each AMP.\nAvailableAWTsForAll\nThe number of available AMP worker tasks in the unreserved pool in each AMP.\nMonitorAMPLoad Usage Notes\nFor information on the third statement returned from the MONITOR AWT RESOURCE request response, see Statement 3 - MONITOR AWT RESOURCE.\nMonitorAMPLoad Example\nThis example shows the data reported in statement 3 of MONITOR AWT RESOURCE.\nSELECT * FROM TABLE (MonitorAMPLoad()) AS t1;\n*** Query completed. 4 rows found. 6 columns returned.\n*** Total elapsed time was 1 second.\n            VprocNo       0\n      AvailableAWTs           49\n          InUseAWTs            2\n           MsgCount            0\n         DQMsgCount          737\nAvailableAWTsForAll           55\n            VprocNo       1\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount          765\nAvailableAWTsForAll           56\n            VprocNo       2\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount          695\nLake - Monitor Resources and Performance\nPage 211 of 420AvailableAWTsForAll           56\n            VprocNo       3\n      AvailableAWTs           48\n          InUseAWTs            2\n           MsgCount            0\n         DQMsgCount          863\nAvailableAWTsForAll           56\nMonitorA WTResource\nCollects statistics on AMPs based on the in-use AMP Worker Tasks (AWTs).\nMonitorAWTResource Syntax\nMonitorAWTResource Usage Notes\nMonitorAWTResource Example\nMonitorAWTResource Syntax\nREPLACE FUNCTION SYSLIB.MonitorAWTResource (\n  Threshold1  INTEGER,\n  Threshold2  INTEGER,\n  Threshold3  INTEGER,\n  Threshold4  INTEGER\n) RETURNS TABLE (\n    IntervalCount1 INTEGER,\n    IntervalCount2 INTEGER,\n    IntervalCount3 INTEGER,\n    IntervalCount4 INTEGER,\n    FlowControl INTEGER,\n    HighAMP1VprocId INTEGER,\n    HighAMP1InUseCount INTEGER,\n    HighAMP2VprocId INTEGER,\n    HighAMP2InUseCount INTEGER,\n    HighAMP3VprocId INTEGER,\n    HighAMP3InUseCount INTEGER,\n    HighAMP4VprocId INTEGER,\n    HighAMP4InUseCount INTEGER,\n    HighAMP5VprocId INTEGER,\n    HighAMP5InUseCount INTEGER,\n    LowAMP1VprocId INTEGER,\n    LowAMP1InUseCount INTEGER,\n    LowAMP2VprocId INTEGER,\n    LowAMP2InUseCount INTEGER,\n    LowAMP3VprocId INTEGER,\n    LowAMP3InUseCount INTEGER,\n    LowAMP4VprocId INTEGER,\n    LowAMP4InUseCount INTEGER,\n    LowAMP5VprocId INTEGER,\n    LowAMP5InUseCount INTEGER,\n    FCVprocId1 INTEGER,\n    FCVprocId2 INTEGER,\n    FCVprocId3 INTEGER,\n    FCVprocId4 INTEGER,\n    FCVprocId5 INTEGER\n  )\n  ...\n;\nSyntax Elements\nThreshold1\nMinimum value for in-use AWTs to qualify an AMP for inclusion into this interval.\nThreshold2\nThreshold3\nThreshold4\nStart value for in-use AWTs to qualify an AMP for inclusion into this interval.\nIntervalCountn\nWhere n in [1, 4]: Number of AMPs in the system whose in-use AWT counts fall at, or above, the Thresholdn value and do not qualify for the higher thresholds.\nFlowControl\nNumber of AMPs in a form of Flow Control.\nHighAMPnVprocId\nWhere n in [1, 5]: Vproc ID of the AMP with the nth highest in-use count in the system. A value of -1 indicates this ﬁeld is not deﬁned.\nHighAMPnInUseCount\nLake - Monitor Resources and Performance\nPage 212 of 420Where n in [1, 5]: In-use count associated with HighAMPnVprocId. Applicable only if HighAMPnVprocId is deﬁned.\nLowAMPnVprocId\nWhere n in [1, 5]: Vproc ID of the AMP with the nth lowest in-use count in the system. A value of -1 indicates this ﬁeld is not deﬁned.\nLowAMPnInUseCount\nWhere n in [1, 5]: In-use count associated with LowAMPnVprocId. Applicable only if LowAMPnVprocId is deﬁned.\nFCVprocIdn\nWhere n in [1, 5]: The vproc ID of the AMP in ﬂow control. A value of -1 indicates this ﬁeld is not deﬁned.\nMonitorAWTResource Usage Notes\nThe MonitorAWTResource functions are two overloaded functions. One requires the threshold values to be passed in; the other sets the threshold values to 45, 55, 62, and 75.\nThe MonitorAWTResource function provides similar functionality to the PMPC MONITOR AWT RESOURCE request. For information about this interface, see MONITOR AWT\nRESOURCE.\nMonitorAWTResource Example\nSELECT * FROM TABLE (MonitorAWTResource(1,2,3,4)) AS t1;\n *** Query completed. One row found. 30 columns returned.\n *** Total elapsed time was 1 second.\n    IntervalCount1            0\n    IntervalCount2            0\n    IntervalCount3            2\n    IntervalCount4            4\n       FlowControl            0\n   HighAMP1VprocId            2\nHighAMP1InUseCount            6\n   HighAMP2VprocId            5\nHighAMP2InUseCount            4\n   HighAMP3VprocId            3\nHighAMP3InUseCount            4\n   HighAMP4VprocId            1\nHighAMP4InUseCount            4\n   HighAMP5VprocId            4\nHighAMP5InUseCount            3\n    LowAMP1VprocId            4\n LowAMP1InUseCount            3\n    LowAMP2VprocId            0\n LowAMP2InUseCount            3\n    LowAMP3VprocId            5\n LowAMP3InUseCount            4\n    LowAMP4VprocId            3\n LowAMP4InUseCount            4\n    LowAMP5VprocId            1\n LowAMP5InUseCount            4\n        FCVprocId1           -1\n        FCVprocId2           -1\n        FCVprocId3           -1\n        FCVprocId4           -1\n        FCVprocId5           -1\nMonitorMySessions\nCollects the session information for the current user on the current host.\nMonitorMySessions Syntax\nMonitorMySessions Syntax Elements\nMonitorMySessions Usage Notes\nMonitorMySessions Examples\nMonitorMySessions Syntax\nREPLACE FUNCTION syslib.MONITORMYSESSIONS () \n RETURNS TABLE \n  (HostId SMALLINT, \n   SessionNo INTEGER, \n   LogonPENo SMALLINT, \n   RunVprocNo SMALLINT, \n   PartName VARCHAR(16) CHARACTER SET LATIN, \n   PEstate VARCHAR(18) CHARACTER SET LATIN, \n   LogonTime VARCHAR(22) CHARACTER SET LATIN, \n   UserId INTEGER, \n   LSN INTEGER, \n   UserName VARCHAR(128) CHARACTER SET UNICODE, \nLake - Monitor Resources and Performance\nPage 213 of 420   UserAccount VARCHAR(128) CHARACTER SET UNICODE, \n   PECPUsec FLOAT, \n   XActCount FLOAT, \n   ReqCount FLOAT, \n   ReqCacheHits FLOAT, \n   AMPState VARCHAR(18) CHARACTER SET LATIN, \n   AMPCPUSec FLOAT, \n   AMPIO FLOAT, \n   ReqSpool FLOAT, \n   Blk1HostId SMALLINT, \n   Blk1SessNo INTEGER, \n   Blk1UserId INTEGER, \n   Blk1Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk1Otype CHAR(2) CHARACTER SET LATIN, \n   Blk1ObjDBID INTEGER, \n   Blk1ObjTID INTEGER, \n   Blk1Status CHAR(1) CHARACTER SET LATIN, \n   Blk2HostId SMALLINT, \n   Blk2SessNo INTEGER, \n   Blk2UserId INTEGER, \n   Blk2Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk2Otype CHAR(2) CHARACTER SET LATIN, \n   Blk2ObjDBID INTEGER, \n   Blk2ObjTID INTEGER, \n   Blk2Status CHAR(1) CHARACTER SET LATIN, \n   Blk3HostId SMALLINT, \n   Blk3SessNo INTEGER, \n   Blk3UserId INTEGER, \n   Blk3Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk3Otype CHAR(2) CHARACTER SET LATIN, \n   Blk3ObjDBID INTEGER, \n   Blk3ObjTID INTEGER, \n   Blk3Status CHAR(1) CHARACTER SET LATIN, \n   MoreBlockers CHAR(1) CHARACTER SET LATIN, \n   LogonSource VARCHAR(128) CHARACTER SET UNICODE, \n   HotAmp1CPU FLOAT, \n   HotAmp2CPU FLOAT, \n   HotAmp3CPU FLOAT, \n   HotAmp1CPUId SMALLINT, \n   HotAmp2CPUId SMALLINT, \n   HotAmp3CPUId SMALLINT, \n   HotAmp1IO FLOAT, \n   HotAmp2IO FLOAT, \n   HotAmp3IO FLOAT, \n   HotAmp1IOId SMALLINT, \n   HotAmp2IOId SMALLINT, \n   HotAmp3IOId SMALLINT, \n   LowAmp1CPU FLOAT, \n   LowAmp2CPU FLOAT, \n   LowAmp3CPU FLOAT, \n   LowAmp1CPUId SMALLINT, \n   LowAmp2CPUId SMALLINT, \n   LowAmp3CPUId SMALLINT, \n   LowAmp1IO FLOAT, \n   LowAmp2IO FLOAT, \n   LowAmp3IO FLOAT, \n   LowAmp1IOId SMALLINT, \n   LowAmp2IOId SMALLINT, \n   LowAmp3IOId SMALLINT, \n   AvgAmpCPUSec FLOAT, \n   AvgAmpIOCnt FLOAT, \n   AmpCount SMALLINT, \n   TempSpaceUsg FLOAT, \n   ReqStartTime VARCHAR(22) CHARACTER SET LATIN, \n   ReqCPU FLOAT, \n   ReqIO FLOAT, \n   ReqNo INTEGER, \n   WlcId INTEGER, \n   DontReclassifyFlag SMALLINT, \n   ProxyUser VARCHAR(128) CHARACTER SET UNICODE, \n   CPUDecayLevel SMALLINT, \n   IODecayLevel SMALLINT, \nLake - Monitor Resources and Performance\nPage 214 of 420   TacticalCPUException INTEGER, \n   TacticalIOException INTEGER, \n   ReqIOKB FLOAT, \n   ReqPhysIO FLOAT, \n   ReqPhysIOKB FLOAT, \n   ReqStepsCompletedCnt INTEGER, \n   RedriveProtection CHAR(2) CHARACTER SET LATIN, \n   CurrentRedriveParticipation CHAR(1) CHARACTER SET LATIN, \n   ReqRedriveSpoolSpace FLOAT, \n   BlockerSessionCnt SMALLINT, \n   ReqTblOpBytesIn FLOAT, \n   ReqTblOpBytesOut FLOAT, \n   ProxyUserId INTEGER, \n   ZoneId INTEGER, \n   ReqHotAmpCPU FLOAT, \n   ReqHotAmpCPUId SMALLINT, \n   ReqHotAmpIO FLOAT, \n   ReqHotAmpIOId SMALLINT, \n   ReqInvolvedAMPCnt SMALLINT, \n   ReqFirstRespTime VARCHAR(22) CHARACTER SET LATIN, \n   ReqLocalQueryStatus SMALLINT, \n   ReqRemoteHostId SMALLINT, \n   ReqRemoteSessionId INTEGER, \n   ReqRemoteRequestId INTEGER, \n   ReqRemoteQueryId FLOAT, \n   ReqHotAmpSpool FLOAT, \n   ReqHotAmpSpoolId SMALLINT, \n   ReqMapNo SMALLINT, \n   ReqMaxNumMapAMPs INTEGER, \n   ReqMinNumMapAMPs INTEGER, \n   ReqSysDefNumMapAMPs INTEGER, \n   ReqRemoteHostIp VARCHAR(128) CHARACTER SET UNICODE, \n   ReqServerName VARCHAR(128) CHARACTER SET UNICODE, \n   ReqFlexReleased SMALLINT, \n   ReqAdmissionTime VARCHAR(22) CHARACTER SET LATIN\n,\n   QueryID DECIMAL(18,0), \n   CollectionTime TIMESTAMP(6)) \n SPECIFIC MonitorMySessions \n LANGUAGE C \n NO SQL\n NO EXTERNAL DATA\n PARAMETER STYLE SQL \n NOT DETERMINISTIC \n CALLED ON NULL INPUT \n TRUSTTYPE TRUSTED\n EXTERNAL NAME 'SL!api!F!MonitorMySessions_U'\nMonitorMySessions Syntax Elements\nSyntax Elements\nHostId\nLogical Host ID associated with a PE or session.\nFor a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE.\nFor a session, the combination of a host ID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nLogonPENo\nVproc number of the PE the session is logged on to, which identiﬁes the PE that has control responsibility for the session. Typically, this is the PE that processed the logon\nrequest; but if that PE goes ofﬂine, this is the PE to which the session was switched.\nRunVprocNo\nVproc number of the AMP or PE assigned to process the session requests.\nFor sessions in Teradata SQL partitions, this value is identical to the LogonPENo. For sessions in FastLoad or MultiLoad partitions, this is the AMP that initially processes the\ndata being loaded.\nIf a RunVprocNo value of -1 in record mode or NULL in indicator mode is returned by MonitorMySessions for FastLoad, MultiLoad, or FastExport sessions, this indicates that the\nsession is in the process of starting up.\nPartName\nName of the session partition associated with this session. Following a successful logon request by a session or as part of a connect request, the session identiﬁes the partition\nwith which the user wants the session to be associated. FASTLOAD, Teradata SQL, MONITOR, INTERNAL are examples of valid partition names.\nLake - Monitor Resources and Performance\nPage 215 of 420PEstate\nCurrent state of the session within the PE. See the MONITOR SESSION PEState ﬁeld for a list of the PEState values.\nLogonTime\nDate and time portion of the information recorded by Session Control when a session logs on, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the\nyear, month, day, hours: minutes: seconds.\nUserId\nUser or internal ID of a user for this session. Within the database, UserId is equivalent to Database ID. Typically, UserId is used when the associated record is known to be a\nuser name, and Database ID is used when the associated record is known to be a database. However, UserId can identify either a given user or database name.\nLSN\nLogon Sequence Number (LSN) associated with a session when the session logs on, which identiﬁes a collection of sessions performing a related activity. For example, in a\nFastLoad job, a user is logged on as a Teradata SQL session and n FastLoad sessions with the same user name. Therefore, n+1 sessions (1 Teradata SQL and n FastLoad)\nwith the same LSN are all associated with the given FastLoad job. To see how the FastLoad job is doing, the user can pick out all sessions reported with the same LSN number.\nThis information supplies the parent-child relationship for sessions involved with FastLoad and MultiLoad jobs.\nUserName\nUser name of the session.\nUserAccount\nCurrent account for the session.\nPECPUsec\nCPU time (in seconds) used in a PE by the associated session for parsing and dispatching requests, accurate to the second.\nThis value is valid only when associated with Teradata SQL and MONITOR partition sessions.\nXActCount\nNumber of explicit and implicit transactions run by the session.\nThis value is valid only when returned for Teradata SQL sessions, and is NULL for all other partition sessions. For this value, you must make a request for data before completion\nof the ﬁrst collection period that follows either a system outage or a change in the ResMonitor rate.\nReqCount\nNumber of requests (Tequel Start Request [TSR] messages) initiated by the session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or change in the ResMonitor rate.\nReqCacheHits\nNumber of times this session processed a request using information from the Teradata SQL Parser request cache (number of times there was a request cache hit).\nThis value is valid only for Teradata SQL sessions, and is NULL for all other partition sessions. This value is also NULL when a request for data is made before completion of the\nﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPState\nCurrent state of the associated session in AMP vprocs in decreasing priority:\nState Description\nABORTING Transaction being rolled back; session aborting.\nBLOCKED Background activity in progress; last request on hold until background activity is\ncompleted.\nACTIVE Normal, on-going activity.\nIDLE No work in progress on any AMP.\nUNKNOWN No recorded activity since monitoring began.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or\nSesMonitorSys rate.\nAMPCPUSec\nCurrent elapsed CPU time, in seconds, used on all AMPs by the associated session for executing requests. For example, for Teradata SQL requests, this is the time spent by\nthe database actively working or rolling back an aborted transaction. This does not include any PDE CPU time spent handling database requests.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPIO\nCurrent number of logical Reads and Writes issued across all AMPs by the associated session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nReqSpool\nCurrent spool used by current request across all AMPs, expressed in bytes.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nBlk1HostId\nBlk2HostId\nBlk3HostId\nLogical host ID of a session causing a block. This value is derived from equating the transactions causing a database lock conﬂict to the sessions that issued those\ntransactions. The Blk_x_H ostId, in combination with Blk_x_S essNo , uniquely identiﬁes the session that is causing a block.\nThis value is NULL if:\nThe host ID is not available.\nThe session does not have an AMPState of BLOCKED.\nIf the Blk_x_H ostId, Blk_x_S essNo, and Blk_x_Use rID values all return as NULLs and AMPState is BLOCKED, a host utility lock left over after the session holding the lock was\naborted or logged off. The lock was never released, and no blocking information is available because the session no longer exists.\nBlk1SessNo\nBlk2SessNo\nBlk3SessNo\nLake - Monitor Resources and Performance\nPage 216 of 420Number of the session causing a block. This value is derived from associating the transactions causing a lock conﬂict to the sessions that issued those transactions. The\nBlk_x_S essNo, in combination with Blk_x_H ostId, uniquely identiﬁes the session causing a block.\nThis value is NULL if:\nSessNo is not available.\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nIf the Blk_x_H ostId, Blk_x_S essNo, and Blk_x_Use rID values all return as NULLs and AMPState is BLOCKED, a host utility lock left over after the session holding the lock was\naborted or logged off. The lock was never released, and no blocking information is available because the session no longer exists.\nBlk1UserId\nBlk2UserId\nBlk3UserId\nID of the user or host utility job preventing the session from being granted a lock. The user ID is the only information available about who placed the lock.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nIf the Blk_x_H ostId, Blk_x_S essNo, and Blk_x_Use rID values all return as NULLs and AMPState is BLOCKED, a host utility lock left over after the session holding the lock was\naborted or logged off. The lock was never released, and no blocking information is available because the session no longer exists. If you need the user name who placed the\nHUT lock, contact Teradata Support.\nBlk1Lmode\nBlk2Lmode\nBlk3Lmode\nMode (severity) of the lock involved in causing a block:\nE = Exclusive\nW = Write\nR = Read\nA = Access\nLocks are reported in decreasing order of severity because removing the most severe lock conﬂict may eliminate the source of the lock conﬂict.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA session may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock in the queue and is in conﬂict with the lock requested by this blocked\nsession. For information on whether the lock is granted, see the MONITOR SESSION ﬁelds: Blk1Status, Blk2Status, and Blk3Status.\nBlk1Otype\nBlk2Otype\nBlk3Otype\nType of object whose lock is causing the session described by the associated row to be blocked:\nD = Database\nT= Table\nR = Row hash\nTP = Table Partition range\nRP = RowHash in Partition range\nRK = RowHash in one partition\nRN = RowKey range\nHowever, this object is not necessarily the type of object the blocked session is trying to access. For example, if the session is requesting a row hash lock, the blocking object\nmay be a database, table, or row hash.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nFor a Table T, User A can block User B with a table-level lock on Table T on AMP_1 and with a Row Hash Level lock on that same Table T on AMP_2. When that occurs, the only\nlock conﬂict reported is that User B is blocked by User A on a table.\nBlk1ObjDBID\nBlk2ObjDBID\nBlk3ObjDBID\nUnique ID of the database object over which a lock conﬂict is preventing the session from being granted a lock.\nWithin the database system, Database ID is equivalent to User ID. Typically, User ID is used when the associated record is known to be a user name, and Database ID is used\nwhen the associated record is known to be a database. However, Database ID can identify either a user or database name.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1ObjTID\nBlk2ObjTID\nBlk3ObjTID\nUnique ID of the table object over which a lock conﬂict is preventing the session from being granted a lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nThe Blk_x_OT ype is D.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1Status\nBlk2Status\nLake - Monitor Resources and Performance\nPage 217 of 420Blk3Status\nStatus of lock causing a block:\nW= Waiting\nG = Granted\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA lock request may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock request in the queue and is in conﬂict with it.\nA status of Waiting has a higher priority than that of Granted when there is more than one lock involved. For example, for a given object and a given session, a session that is\nblocked by a Waiting lock on one AMP and a Granted lock on another AMP has Waiting reported as its status.\nMoreBlockers\nIndicator of more lock conﬂicts:\nBlank = Blk x information is a complete list of sessions blocking the session described.\nAsterisk (*) = Additional sessions are blocking the session described.\nThis value is NULL if:\nThe state of the session is not BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLogonSource\nLogon source information. At logon time, this information is optionally supplied by the Teradata Director Program or the Gateway to further identify the physical or logical location\nof the session, the logon user name, and the interface under which the session was initiated. (For example, the data string may include DBC as the user ID and BTEQ as the\ninterface.)\nA two-byte value precedes the LogonSource data to indicate the length of the string. The length value is zero if LogonSource is NULL.\nHotAmpnCPU\nWhere n in [1, 3]: CPU time of the nth highest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth highest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIO\nWhere n in [1, 3]: I/O count of the nth highest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth highest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPU\nWhere n in [1, 3]: CPU time of the nth lowest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth lowest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIO\nWhere n in [1, 3]: I/O count of the nth lowest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth lowest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nAvgAmpCPUSec\nAverage AMP CPU usage for the last session collection interval. The average is calculated as the sum of CPU usage for all amps participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nAvgAmpIOCnt\nAverage AMP I/O usage for the last session collection interval. The average is calculated as the sum of I/O usage for all AMPs participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nAmpCount\nCurrent number of AMPs executing on the associated node.\nTempSpaceUsg\nTotal amount, in bytes, of temporary space used by the session.\nThis value is NULL if the session did not materialize any temporary tables.\nReqStartTime\nDate and time of the current request on the session started, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the year, month, day hours: minutes:\nseconds.\nReqCPU\nLake - Monitor Resources and Performance\nPage 218 of 420Total CPU usage by the current SQL request on the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL requests only.\nIgnore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nThis ﬁeld is equivalent to the MONITOR SESSION RequestAmpCPU ﬁeld.\nReqIO\nTotal number of accesses by the current SQL request for the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL\nrequests only. Ignore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nThis ﬁeld is equivalent to the MONITOR SESSION RequestAmpI/O ﬁeld.\nIn the early phase of a request in parsing state, when PEState = PARSING, the request number may not be available and returned as zero or NULL. The active request number\nis available on the next collection.\nWlcId\nWorkload ID associated with the speciﬁed request.\nDontReclassifyFlag\nFlag indicating that the next request on the session is not classiﬁed, but uses the workload ID (WlcId) already assigned to the session. This occurs if this is a utility session or a\nWlcId was assigned to the session using the TDWMAssignWD function or the TDWM WD ASSIGNMENT request. See Teradata Dynamic Workload Management APIs: PM/APIs.\nProxyUser\nName of the proxy user in a trusted session.\nCPUDecayLevel\nCurrent most severe decay level, as reached due to CPU usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nIODecayLevel\nCurrent most severe decay level, as reached due to I/O usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nTacticalCPUException\nNumber of nodes that encountered a CPU exception.\nTacticalIOException\nNumber of nodes that encountered an I/O exception.\nReqIOKB\nTotal logical I/O usage in KB.\nReqPhysIO\nNumber of physical I/Os.\nReqPhysIOKB\nPhysical I/O usage in KB.\nReqStepsCompletedCnt\nCount of completed steps for the current request. No change in ReqStepsCompletedCnt from the previous Monitor Session collection indicates no new steps completed.\nRedriveProtection\nRedrive protection type:\n' ' = No Redrive protection. The session does not participate in Redrive and database restarts are not transparent to applications and users.\nMN = Memory-based Redrive protection, no fallback spools\nCurrentRedriveParticipation\nIndicates if the session is participating in Redrive. Sessions that use Redrive can enable or disable the functionality using the REDRIVE reserved query band. Possible values:\nT = Redrive functionality is enabled (database restarts are transparent to applications and users)\nF = Redrive functionality is disabled (database restarts are not transparent to applications and users)\nReqRedriveSpoolSpace\nPersistent spool space for the current request.\nBlockerSessionCnt\nTotal number of blocker sessions for the session. Unlike the MONITOR SESSION request, this ﬁeld returns only the ﬁrst three blocker sessions in the record parcel. There are no\nadditional blocker sessions if there are more than three blocker sessions.\nReqTblOpBytesIn\nThe total number of bytes transferred into the database from a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesIn output parameter shows bytes transferred across all invocations within the request.\nReqTblOpBytesOut\nThe total number of bytes transferred out of the database and into a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesOut output parameter shows bytes transferred across all invocations within the request.\nProxyUserId\nThe user ID charged for SPOOL and TEMP space if being charged to the proxy user.\nZoneId\nThe unique identiﬁer of the zone.\nReqHotAmpCPU\nThe CPU time of the highest CPU used AMP during the life of the current request on the session.\nReqHotAmpCPUId\nVproc ID of the highest CPU used AMP for the current request.\nReqHotAmpIO\nI/O count of the highest I/O used AMP during the life of the current request on the session.\nReqHotAmpIOId\nVproc ID of the highest I/O used AMP for the current request.\nReqInvolvedAMPCnt\nThe number of AMPs involved in processing the current request.\nReqFirstRespTime\nDate and time that the ﬁrst response of the current request on the session is ready. The response may be held to meet the TASM Minimum Response Time.\nReqLocalQueryStatus\nThe current state of the Uniﬁed Data Architecture (UDA) query.\nReqRemoteHostId\nLake - Monitor Resources and Performance\nPage 219 of 420Host ID of the remote system.\nReqRemoteSessionId\nSession ID of the executing remote query.\nReqRemoteRequestId\nRequest ID of the executing remote query.\nReqRemoteQueryId\nQuery ID of the executing remote query.\nReqHotAmpSpool\nSpool value of the highest spool used AMP during the life of the current request on the session.\nThis value is NULL if no request is running on the session.\nReqHotAmpSpoolId\nVproc ID of the highest spool used AMP for the current request.\nThis value is NULL if no request is running on the session.\nReqMapNo\nMap number for the largest map the request is using.\nReqMaxNumMapAMPs\nNumber of AMPs in the largest contiguous map used by the request.\nReqMinNumMapAMPs\nNumber of AMPs in the smallest contiguous map used by the request.\nReqSysDefNumMapAMPs\nNumber of AMPs in the system-default map used by the request.\nReqRemoteHostIp\nHost IP address of the remote system.\nReqServerName\nName of the foreign server.\nReqFlexReleased\nThe TDWM Flex Throttle feature detects available system resources, overrides existing workload throttle limits, and automatically releases queries from the delay queue. This\nminimizes the DBA manually managing the TASM delay queue. Only Workload throttles are overridden; all System level throttles are still honored.\nReturn values:\n0: Indicates that the request was not released by TDWM Flex Throttles.\n1: Indicates that the request was released by TDWM Flex Throttles.\nReqAdmissionTime\nReturns the date and time when a request is admitted into the system by TDWM.\nQueryID\nQuery ID of the session being monitored.\nCollectionTime\nDatabase time of when the session cache was last refreshed.\nMonitorMySessions Usage Notes\nThe following CPU ﬁelds in the MonitorMySessions response are affected by the MonSesCPUNormalization ﬁeld:\nAMPCPUSec\nAvgAmpCPUSec\nHotAmp1CPU\nHotAmp2CPU\nHotAmp3CPU\nLowAmp1CPU\nLowAmp2CPU\nLowAmp3CPU\nPECPUSec\nRequestAmpCPU\nThe MonSesCPUNormalization ﬁeld, controls whether normalized or non-normalized statistical CPU data is reported by the functions MonitorMySessions and MonitorSession, and by\nthe MONITOR SESSION request.\nSee MonitorSession and MONITOR SESSION for a list of these CPU ﬁelds.\nA Trusted Session enables a middle-tier application to switch the user on an already active database session to another user (proxy user). When the user is switched, all subsequent\nrequests use the privileges and session attributes of the proxy user. MonitorMySessions returns the logon user name and ID in the UserName and UserId ﬁelds and the proxy user\nname and ID in the ProxyUserName and ProxyUserId ﬁelds.\nWhen connected as a permanent proxy user, MonitorMySessions returns information on sessions directly logged on as the permanent proxy user, but does not return the current\nsession or any other proxy user sessions for the permanent proxy user.\nMonitorMySessions Examples\nExample 1: Generic Use of MonitorMySessions\nSELECT * FROM TABLE (monitormysessions()) as t1;\nResult:\nLake - Monitor Resources and Performance\nPage 220 of 420                     HostId       1\n                  SessionNo         1025\n                  LogonPENo   30719\n                 RunVprocNo   30719\n                   PartName  DBC/SQL\n                    PEstate  IDLE\n                  LogonTime  2024/02/07 14:45:25.00\n                     UserId            1\n                        LSN            0\n                   UserName  DBC\n                UserAccount  DBC\n                   PECPUsec   6.28000000000000E-001\n                  XActCount   3.00000000000000E 000\n                   ReqCount   4.00000000000000E 000\n               ReqCacheHits   1.00000000000000E 000\n                   AMPState  IDLE\n                  AMPCPUSec   1.60000000000000E-002\n                      AMPIO   1.84000000000000E 002\n                   ReqSpool   0.00000000000000E 000\n                 Blk1HostId       0\n                 Blk1SessNo            0\n                 Blk1UserId            0\n                  Blk1Lmode\n                  Blk1Otype\n                Blk1ObjDBID            0\n                 Blk1ObjTID            0\n                 Blk1Status\n                 Blk2HostId       0\n                 Blk2SessNo            0\n                 Blk2UserId            0\n                  Blk2Lmode\n                  Blk2Otype\n                Blk2ObjDBID            0\n                 Blk2ObjTID            0\n                 Blk2Status\n                 Blk3HostId       0\n                 Blk3SessNo            0\n                 Blk3UserId            0\n                  Blk3Lmode\n                  Blk3Otype\n                Blk3ObjDBID            0\n                 Blk3ObjTID            0\n                 Blk3Status\n               MoreBlockers\n                LogonSource  (TCP/IP) 9436 127.0.0.1 DBC     10412  ROOT  BTEQ  01 LSS\n                 HotAmp1CPU   0.00000000000000E 000\n                 HotAmp2CPU   0.00000000000000E 000\n                 HotAmp3CPU   0.00000000000000E 000\n               HotAmp1CPUId       0\n               HotAmp2CPUId       0\n               HotAmp3CPUId       0\n                  HotAmp1IO   0.00000000000000E 000\n                  HotAmp2IO   0.00000000000000E 000\n                  HotAmp3IO   0.00000000000000E 000\n                HotAmp1IOId       0\n                HotAmp2IOId       0\n                HotAmp3IOId       0\n                 LowAmp1CPU   0.00000000000000E 000\n                 LowAmp2CPU   0.00000000000000E 000\n                 LowAmp3CPU   0.00000000000000E 000\n               LowAmp1CPUId       0\n               LowAmp2CPUId       0\n               LowAmp3CPUId       0\n                  LowAmp1IO   0.00000000000000E 000\n                  LowAmp2IO   0.00000000000000E 000\n                  LowAmp3IO   0.00000000000000E 000\n                LowAmp1IOId       0\n                LowAmp2IOId       0\n                LowAmp3IOId       0\n               AvgAmpCPUSec   0.00000000000000E 000\n                AvgAmpIOCnt   0.00000000000000E 000\n                   AmpCount       0\nLake - Monitor Resources and Performance\nPage 221 of 420               TempSpaceUsg   0.00000000000000E 000\n               ReqStartTime  0000/00/00 00:00:00.00\n                     ReqCPU   0.00000000000000E 000\n                      ReqIO   0.00000000000000E 000\n                      ReqNo            0\n                      WlcId           30\n         DontReclassifyFlag       0\n                  ProxyUser\n              CPUDecayLevel       0\n               IODecayLevel       0\n       TacticalCPUException            0\n        TacticalIOException            0\n                    ReqIOKB   0.00000000000000E 000\n                  ReqPhysIO   0.00000000000000E 000\n                ReqPhysIOKB   0.00000000000000E 000\n       ReqStepsCompletedCnt            0\n          RedriveProtection  MN\nCurrentRedriveParticipation  F\n       ReqRedriveSpoolSpace   0.00000000000000E 000\n          BlockerSessionCnt       0\n            ReqTblOpBytesIn   0.00000000000000E 000\n           ReqTblOpBytesOut   0.00000000000000E 000\n                ProxyUserId            0\n                     ZoneId            0\n               ReqHotAmpCPU   0.00000000000000E 000\n             ReqHotAmpCPUId      -1\n                ReqHotAmpIO   0.00000000000000E 000\n              ReqHotAmpIOId      -1\n          ReqInvolvedAMPCnt       0\n           ReqFirstRespTime  0000/00/00 00:00:00.00\n        ReqLocalQueryStatus       0\n            ReqRemoteHostId       0\n         ReqRemoteSessionId            0\n         ReqRemoteRequestId            0\n           ReqRemoteQueryId   0.00000000000000E 000\n             ReqHotAmpSpool   0.00000000000000E 000\n           ReqHotAmpSpoolId      -1\n                   ReqMapNo       0\n           ReqMaxNumMapAMPs            0\n           ReqMinNumMapAMPs            0\n        ReqSysDefNumMapAMPs            0\n            ReqRemoteHostIp\n              ReqServerName\n            ReqFlexReleased       0\n           ReqAdmissionTime  0000/00/00 00:00:00.00\n         ComputeWorkerInUse  F\n                    QueryID   307187241654251639.\n             CollectionTime  2024-03-18 01:42:00.000002\nMonitorPhysicalConﬁg\nCollects overall information on node availability. Node status information is returned for all nodes in the system.\nMonitorPhysicalConﬁg Syntax\nMonitorPhysicalConﬁg Usage Notes\nMonitorPhysicalConﬁg Example\nMonitorPhysicalConﬁg Syntax\nREPLACE FUNCTION SYSLIB.MonitorPhysicalConfig (\n) RETURNS TABLE (\n    ProcId INTEGER,\n    Status CHAR CHARACTER SET LATIN,\n    CPUType VARCHAR(7) CHARACTER SET LATIN,\n    CPUCount SMALLINT,\n    SystemType VARCHAR(7) CHARACTER SET LATIN,\n    CliqueNo SMALLINT,\n    NetAUp CHAR(1) CHARACTER SET LATIN,\n    NetBUp CHAR(1) CHARACTER SET LATIN,\n    PhyMemory INTEGER\n  )\n  ...\n;\nLake - Monitor Resources and Performance\nPage 222 of 420Syntax Elements\nProcId\nID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nStatus\nStatus of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nS = Standby\nA node is up (U) when the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nStandby (S) indicates the node is ready to join the conﬁguration in place if another node goes down. When the node status is Standby, the SystemType, NetAUp, and NetBUp\nﬁelds are not available and NULL or spaces are returned.\nCPUType\nType of CPU installed in this node, for example: 'Pentium', 'PentPro', or 'Unknown'.\nCPUCount\nNumber of CPUs in this node.\nSystemType\nType of system running the database software, such as 5650, 6700, or 'Other'.\nIf all the nodes in the system are the same type, this ﬁeld returns the type of the system.\nIf any of the nodes are of a different type, this ﬁeld returns 'Mixed'.\nCliqueNo\nClique number of the node.\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nPhyMemory\nSize of the physical memory of the node in MBs.\nMonitorPhysicalConﬁg Usage Notes\nThe MonitorPhysicalConﬁg function provides similar functionality to the PMPC MONITOR PHYSICAL CONFIG request. For information about this interface, see MONITOR PHYSICAL\nCONFIG.\nMonitorPhysicalConﬁg Example\nSELECT t2.* FROM TABLE (MonitorPhysicalConfig()) AS t2;\n *** Query completed. One row found. 9 columns returned.\n *** Total elapsed time was 1 second.\n    ProcId   10001\n    Status  U\n   CPUType  Xeon\n  CPUCount       1\nSystemType  5500C\n  CliqueNo       0\n    NetAUp\n    NetBUp\n PhyMemory         5720\nMonitorPhysicalResource\nCollects RSS data and returns node-speciﬁc data.\nMonitorPhysicalResource Syntax\nMonitorPhysicalResource Syntax Elements\nMonitorPhysicalResource Usage Notes\nMonitorPhysicalResource Example\nMonitorPhysicalResource Syntax\nREPLACE FUNCTION SYSLIB.MonitorPhysicalResource (\n) RETURNS TABLE (\n    ProcId INTEGER,\nLake - Monitor Resources and Performance\nPage 223 of 420    Status CHAR CHARACTER SET LATIN,\n    AmpCount SMALLINT,\n    PECount SMALLINT,\n    CPUUse FLOAT,\n    PrcntKernel FLOAT,\n    PrcntService FLOAT,\n    PrcntUser FLOAT,\n    DiskUse FLOAT,\n    DiskReads FLOAT,\n    DiskWrites FLOAT,\n    DiskOutReqAvg FLOAT,\n    NetAUse FLOAT,\n    NetReads FLOAT,\n    NetWrites FLOAT,\n    HstBlkRd FLOAT,\n    HstBlkWrts FLOAT,\n    MemAllocates FLOAT,\n    MemAllocateKB FLOAT,\n    MemFailures FLOAT,\n    MemAgings FLOAT,\n    NetAUp CHAR(1) CHARACTER SET LATIN,\n    NetBUp CHAR(1) CHARACTER SET LATIN ,\n    VProcCount SMALLINT,\n    SegSizeMBperVProc INTEGER,\n    SegCurrAvailMBperVProc INTEGER\n  )\n  ...\n;\nMonitorPhysicalResource Syntax Elements\nSyntax Elements\nbu\nProcId\nID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nStatus\nStatus of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nA node is up (U) when the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nAmpCount\nCurrent number of AMPs executing on the associated node.\nPECount\nCurrent number of active PEs on the associated node.\nCPUUse\n% of CPU usage not spent being idle. The node-level display is computed from ResUsageSpma table data as PercntUser + PercntService.\nThis value is NULL if certain conditions apply, see usage notes.\nPrcntKernel\n% of CPU resources in idle and waiting for I/O completion. This value is computed from ResUsageSpma data as follows, where NCPUsis the number of CPUs:\n((CPUIOWAIT/100) / (NCPUs * SampleSec)) * 100\nThis value is NULL if certain conditions apply, see usage notes.\nPrcntService\n% of CPU resources spent in PDE user service processing. The value is computed from the ResUsageSpma table data, where x represents the number of CPUs:\nCPUUServ / (x * SampleSec)\nThis value is NULL if certain conditions apply, see usage notes.\nPrcntUser\n% of CPU resources spent in non-service user code processing. This value is computed from the ResUsageSpma table data, where x represents the number of CPUs:\nCPUUExec / (x * SampleSec)\nThis value is NULL if certain conditions apply, see usage notes.\nDiskUse\n% of disk usage per node.\nThis value is computed from ResUsageSldv table data as follows, assuming n is the number of vdisks used by this AMP:\n(LdvOutReqTime 1 + ... + LdvOutReqTime n) / (n*SampleSec)\nThe DiskUse ﬁeld does not take into account overlapping of operations among multiple storage devices, but does allow for the possibility of multiple requests for the same\ndevice.\nLake - Monitor Resources and Performance\nPage 224 of 420This value is NULL if certain conditions apply, see usage notes.\nDiskReads\nTotal number of physical disk reads per node during the collection period. This value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv\ndevices used by this node:\nLdvReads 1 + ... + LdvReads n\nThis value is NULL if certain conditions apply, see usage notes.\nDiskWrites\nTotal number of physical disk writes per node during the collection period. This value is computed from ResUsageSldv table data as:\nLdvWrites 1 + ... + LdvWrites n\nThis value is NULL if certain conditions apply, see usage notes.\nDiskOutReqAvg\nAverage number of outstanding disk requests.\nThe value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv controllers used by this node:\n((LdvOutReqSum 1 / NULLIFZERO(LdvOutReqDiv 1)) + … + (LdvOutReqSum n / NULLIFZERO(LdvOutReqDiv n))) / n\nThe range of the value is typically 0 to 25.\nThis value is NULL if certain conditions apply, see usage notes.\nNetAUse\n% of BYNET A usage (BYNET receiver usage). (The BYNET transmitter usage is maintained in resource usage separately and is typically lower than the receiver usage. This is\ncaused by multicasts, where one transmitter sends a message to multiple receivers.) This value is computed from the ResUsageSpma table data as:\n((NetSamples - NetTxIdle) / NetSamples) * 100\nThis value is NULL if certain conditions apply, see usage notes.\nNetReads\nNumber of Reads from the BYNET to the node. This value is computed from the ResUsageSpma table data as:\nNetRxCircBrd + NetRxCircPtP\nThis value is NULL if certain conditions apply, see usage notes.\nNetWrites\nNumber of messages written from the node to the BYNET during the collection period.\nThe value is computed from the ResUsageSpma table data as NetTxCircBrd + NetTxCircPtP.\nThis value is NULL if certain conditions apply, see usage notes.\nHstBlkRds\nNumber of message blocks (one or more messages sent in one physical group) received from all clients.\nThis value is computed from ResUsageShst data, assuming n is the number of host channel and network connections on this node:\nHostBlockReads 1 + ... + HostBlockReads n\nThis value is NULL if certain conditions apply, see usage notes.\nHstBlkWrts\nNumber of message blocks (that is, one or more messages sent in one physical group) sent to all hosts.\nThis value is computed from ResUsageShst data, assuming n is the number of host channel and network connections on this node:\nHostBlockWrites 1 + ... + HostBlockWrites n\nThis value is NULL if certain conditions apply, see usage notes.\nMemAllocates\nThis column is deprecated and returns zero or NULL.\nMemAllocateKB\nValue represents the change in node-level memory. MemAllocateKB represents a delta from the previous reporting period, reporting negative values as less memory is used.\nThis value is calculated from the ResUsageSpma column MemVprAllocKB.\nThis value is NULL if certain conditions apply, see usage notes.\nMemFailures\nThis column is deprecated and returns zero or NULL.\nMemAgings\nThis column is deprecated and returns zero or NULL.\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nVProcCount\nTotal count of Vprocs of all types in each node.\nSegSizeMBperVProc\nSize of the segment space for each Vproc in MB.\nSegCurrAvailMBperVProc\nAvailable segment space for each Vproc in MB.\nMonitorPhysicalResource Usage Notes\nThe MonitorPhysicalResource function returns the detailed resource usage information for each node. Because the function reports on each node, you can isolate performance\nconcerns by node.\nThe MonitorPhysicalResource function provides similar functionality to the PMPC MONITOR PHYSICAL RESOURCE request. For information about this interface, see MONITOR\nPHYSICAL RESOURCE.\nMonitorPhysicalResource Example\nLake - Monitor Resources and Performance\nPage 225 of 420SELECT t2.* from table (MonitorPhysicalResource()) as t2;\n *** Query completed. One row found. 28 columns returned.\n *** Total elapsed time was 1 second.\n              ProcId   10001\n              Status   U\n            AmpCount   4\n             PECount   2\n              CPUUse   1.00000000000000E 002\n         PrcntKernel   0.00000000000000E 000\n        PrcntService   2.34804329725229E 000\n           PrcntUser   9.76519567027477E 001\n             DiskUse   9.08909242298085E 000\n           DiskReads   8.48000000000000E 002\n          DiskWrites   6.56500000000000E 003\n       DiskOutReqAvg   1.58467943380516E-001\n             NetAUse   0.00000000000000E 000\n             NetBUse   0.00000000000000E 000\n            NetReads   0.00000000000000E 000\n           NetWrites   0.00000000000000E 000\n              CICUse   0.00000000000000E 000\n            HstBlkRds  2.00000000000000E 000\n           HstBlkWrts  1.00000000000000E 000\n         MemAllocates  0.00000000000000E 000\n        MemAllocateKB  1.28000000000000E 002\n          MemFailures  0.00000000000000E 000\n            MemAgings  0.00000000000000E 000\n        NVMemAllocate  0.00000000000000E 000\n       NVMemAllocSegs  0.00000000000000E 000\n          NVMemAgings  0.00000000000000E 000\n               NetAUp  U\n               NetBUp  U\n           VProcCount  12\n    SegSizeMBperVProc  1109\nSegCurrAvailMBperVProc  924\nMonitorPhysicalSummary\nCollects global summary information that includes the following types of information:\nCPU usage (average, high, and low)\nDisk usage (average, high, and low)\nBYNET usage (total, up/down)\nRate information (resource logging rate and resource monitoring rate)\nCurrent software release and version numbers\nSee the following sections:\nMonitorPhysicalSummary Syntax\nMonitorPhysicalSummary Syntax Elements\nMonitorPhysicalSummary Usage Notes\nMonitorPhysicalSummary Example\nMonitorPhysicalSummary Syntax\nREPLACE FUNCTION SYSLIB.MonitorPhysicalSummary (\n) RETURNS TABLE (\n    AvgCPU FLOAT, \n    AvgDisk FLOAT, \n    AvgDiskIO FLOAT, \n    HighCPUUse FLOAT, \n    HighDisk FLOAT, \n    HighDiskIO FLOAT, \n    HighCPUProcId INTEGER,\n    HighDiskProcId INTEGER,\n    HighDiskIOProcId INTEGER,\n    LowCPUUse FLOAT, \n    LowDisk FLOAT, \n    LowDiskIO FLOAT, \n    LowCPUProcId INTEGER,\n    LowDiskProcId INTEGER,\n    LowDiskIOProocId INTEGER,\nLake - Monitor Resources and Performance\nPage 226 of 420    NetUse FLOAT, \n    NetAUp CHAR(1)CHARACTER SET LATIN,\n    NetBUp CHAR(1)CHARACTER SET LATIN,\n    ResLogging SMALLINT,\n    ResMonitor SMALLINT,\n    ReleaseNum VARCHAR(30)CHARACTER SET LATIN,\n    Version VARCHAR(32) CHARACTER SET LATIN\n  )\n  ...\n;\nMonitorPhysicalSummary Syntax Elements\nAvgCPU\nAverage % CPU usage (CPUUse) time of all online nodes in the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nAvgDisk\nAverage % disk usage (from DiskUse) of all online nodes in the database conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDisk is computed from DiskUse data as:\n(DiskUse 1+ ... + DiskUse n) / n\nThis value is NULL if certain conditions apply, see usage notes.\nAvgDiskIO\nAverage physical disk DiskReads and DiskWrites of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDiskIO is computed from DiskReads and DiskWrites data as:\n(DiskReads 1+ DiskWrites 1+ ... + DiskReads 1+ DiskWrites n) / n\nThis value is NULL if certain conditions apply, see usage notes.\nHighCPUUse\nHighest CPUUse number associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nHighDisk\nHighest % disk usage (from DiskUse) associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nHighDiskIO\nID of a node with DiskReads and DiskWrites equal to the value reported as HighDiskIO.\nThis value is NULL if certain conditions apply, see usage notes.\nHighCPUProcId\nID of a node with CPPUse equal to the value reported as HighCPUUse.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nHighDiskProcId\nID of a node with DiskUse equal to the value reported as HighDisk.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nHighDiskIOProcId\nID of a node with DiskReads and DiskWrites equal to the value reported as HighDiskIO.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nLowCPUUse\nLowest CPUUse number associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nLowDisk\nLowest % disk usage (from DiskUse) associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nLowDiskIO\nLowest DiskReads and DiskWrites number associated with any online node that is part of the database conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nLowCPUProcId\nID of a node with CPPUse equal to the value reported as LowCPUUse.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nLowDiskProcId\nID of a node with DiskUse equal to the value reported as LowDisk.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nLowDiskIOProocId\nID of a node with DiskReads and DiskWrites equal to the value reported as LowDiskIO.\nLake - Monitor Resources and Performance\nPage 227 of 420This value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nNetUse\n% of total BYNET use (that is, average of the online BYNETs).\nIf both BYNETs are up, the value is computed from ResUsageSpma table data as:\nNetUse = Average NetAUse per node / NetCount\nwhere:\nNetCount is 2 if both NetA and NetB are up or 1 if only one of the BYNET is up.\nAverage NetAUse is the sum of all NetAUse of each node divided by the number of online nodes.\nThis value is NULL if certain conditions apply, see usage notes.\nNetUse returns a value of zero because resource usage data is not available.\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nResLogging\nInterval in seconds at which resource usage data is written to one or more active resource usage database tables.\nResMonitor\nInterval in seconds at which all resource usage data is collected in memory for reporting using the PM/API.\nReleaseNum\nRelease number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nVersion\nVersion number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nMonitorPhysicalSummary Usage Notes\nThe MonitorPhysicalSummary function provides similar functionality to the PMPC MONITOR PHYSICAL SUMMARY request. For information about this interface, see MONITOR\nPHYSICAL SUMMARY.\nMonitorPhysicalSummary Example\nSELECT * FROM TABLE (MonitorPhysicalSummary()) AS t1;\n *** Query completed. One row found. 22 columns returned.\n *** Total elapsed time was 1 second.\n          AvgCPU   1.00000000000000E 002\n         AvgDisk   7.51986754966887E 000\n       AvgDiskIO   6.64700000000000E 003\n      HighCPUUse   1.00000000000000E 002\n        HighDisk   7.51986754966887E 000\n      HighDiskIO   6.64700000000000E 003\n   HighCPUProcId        10001\n  HighDiskProcId        10001\nHighDiskIOProcId        10001\n       LowCPUUse   1.00000000000000E 002\n         LowDisk   7.51986754966887E 000\n       LowDiskIO   6.64700000000000E 003\n    LowCPUProcId        10001\n   LowDiskProcId        10001\n LowDiskIOProcId        10001\n          NetUse   0.00000000000000E 000\n          NetAUp  U\n          NetBUp  U\n      ResLogging      60\n      ResMonitor      60\n      ReleaseNum  16t.00.00.97\n         Version  16t.00.00.97_dr182707k\nMonitorSession\nReturns session or request resource usage statistics.\nMonitorSession Syntax\nMonitorSession Syntax Elements\nMonitorSession Usage Notes\nMonitorSession Examples\nLake - Monitor Resources and Performance\nPage 228 of 420MonitorSession Syntax\nREPLACE FUNCTION syslib.MONITORSESSION \n  (HostIdIn INTEGER, \n   UserNameIn TD_ANYTYPE, \n   SessionNoIn INTEGER) \n RETURNS TABLE \n  (HostId SMALLINT, \n   SessionNo INTEGER, \n   LogonPENo SMALLINT, \n   RunVprocNo SMALLINT, \n   PartName VARCHAR(16) CHARACTER SET LATIN, \n   PEstate VARCHAR(18) CHARACTER SET LATIN, \n   LogonTime VARCHAR(22) CHARACTER SET LATIN, \n   UserId INTEGER, \n   LSN INTEGER, \n   UserName VARCHAR(128) CHARACTER SET UNICODE, \n   UserAccount VARCHAR(128) CHARACTER SET UNICODE, \n   PECPUsec FLOAT, \n   XActCount FLOAT, \n   ReqCount FLOAT, \n   ReqCacheHits FLOAT, \n   AMPState VARCHAR(18) CHARACTER SET LATIN, \n   AMPCPUSec FLOAT, \n   AMPIO FLOAT, \n   ReqSpool FLOAT, \n   Blk1HostId SMALLINT, \n   Blk1SessNo INTEGER, \n   Blk1UserId INTEGER, \n   Blk1Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk1Otype CHAR(2) CHARACTER SET LATIN, \n   Blk1ObjDBID INTEGER, \n   Blk1ObjTID INTEGER, \n   Blk1Status CHAR(1) CHARACTER SET LATIN, \n   Blk2HostId SMALLINT, \n   Blk2SessNo INTEGER, \n   Blk2UserId INTEGER, \n   Blk2Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk2Otype CHAR(2) CHARACTER SET LATIN, \n   Blk2ObjDBID INTEGER, \n   Blk2ObjTID INTEGER, \n   Blk2Status CHAR(1) CHARACTER SET LATIN, \n   Blk3HostId SMALLINT, \n   Blk3SessNo INTEGER, \n   Blk3UserId INTEGER, \n   Blk3Lmode CHAR(1) CHARACTER SET LATIN, \n   Blk3Otype CHAR(2) CHARACTER SET LATIN, \n   Blk3ObjDBID INTEGER, \n   Blk3ObjTID INTEGER, \n   Blk3Status CHAR(1) CHARACTER SET LATIN, \n   MoreBlockers CHAR(1) CHARACTER SET LATIN, \n   LogonSource VARCHAR(128) CHARACTER SET UNICODE, \n   HotAmp1CPU FLOAT, \n   HotAmp2CPU FLOAT, \n   HotAmp3CPU FLOAT, \n   HotAmp1CPUId SMALLINT, \n   HotAmp2CPUId SMALLINT, \n   HotAmp3CPUId SMALLINT, \n   HotAmp1IO FLOAT, \n   HotAmp2IO FLOAT, \n   HotAmp3IO FLOAT, \n   HotAmp1IOId SMALLINT, \n   HotAmp2IOId SMALLINT, \n   HotAmp3IOId SMALLINT, \n   LowAmp1CPU FLOAT, \n   LowAmp2CPU FLOAT, \n   LowAmp3CPU FLOAT, \n   LowAmp1CPUId SMALLINT, \n   LowAmp2CPUId SMALLINT, \n   LowAmp3CPUId SMALLINT, \n   LowAmp1IO FLOAT, \n   LowAmp2IO FLOAT, \nLake - Monitor Resources and Performance\nPage 229 of 420   LowAmp3IO FLOAT, \n   LowAmp1IOId SMALLINT, \n   LowAmp2IOId SMALLINT, \n   LowAmp3IOId SMALLINT, \n   AvgAmpCPUSec FLOAT, \n   AvgAmpIOCnt FLOAT, \n   AmpCount SMALLINT, \n   TempSpaceUsg FLOAT, \n   ReqStartTime VARCHAR(22) CHARACTER SET LATIN, \n   ReqCPU FLOAT, \n   ReqIO FLOAT, \n   ReqNo INTEGER, \n   WlcId INTEGER, \n   DontReclassifyFlag SMALLINT, \n   ProxyUser VARCHAR(128) CHARACTER SET UNICODE, \n   CPUDecayLevel SMALLINT, \n   IODecayLevel SMALLINT, \n   TacticalCPUException INTEGER, \n   TacticalIOException INTEGER, \n   ReqIOKB FLOAT, \n   ReqPhysIO FLOAT, \n   ReqPhysIOKB FLOAT, \n   ReqStepsCompletedCnt INTEGER, \n   RedriveProtection CHAR(2) CHARACTER SET LATIN, \n   CurrentRedriveParticipation CHAR(1) CHARACTER SET LATIN, \n   ReqRedriveSpoolSpace FLOAT, \n   BlockerSessionCnt SMALLINT, \n   ReqTblOpBytesIn FLOAT, \n   ReqTblOpBytesOut FLOAT, \n   ProxyUserId INTEGER, \n   ZoneId INTEGER, \n   ReqHotAmpCPU FLOAT, \n   ReqHotAmpCPUId SMALLINT, \n   ReqHotAmpIO FLOAT, \n   ReqHotAmpIOId SMALLINT, \n   ReqInvolvedAMPCnt SMALLINT, \n   ReqFirstRespTime VARCHAR(22) CHARACTER SET LATIN, \n   ReqLocalQueryStatus SMALLINT, \n   ReqRemoteHostId SMALLINT, \n   ReqRemoteSessionId INTEGER, \n   ReqRemoteRequestId INTEGER, \n   ReqRemoteQueryId FLOAT, \n   ReqHotAmpSpool FLOAT, \n   ReqHotAmpSpoolId SMALLINT, \n   ReqMapNo SMALLINT, \n   ReqMaxNumMapAMPs INTEGER, \n   ReqMinNumMapAMPs INTEGER, \n   ReqSysDefNumMapAMPs INTEGER, \n   ReqRemoteHostIp VARCHAR(128) CHARACTER SET UNICODE, \n   ReqServerName VARCHAR(128) CHARACTER SET UNICODE, \n   ReqFlexReleased SMALLINT, \n   ReqAdmissionTime VARCHAR(22) CHARACTER SET LATIN\n,\n   QueryID DECIMAL(18,0),\n   CollectionTime TIMESTAMP(6))\n SPECIFIC MonitorSession \n LANGUAGE C \n NO SQL\n NO EXTERNAL DATA\n PARAMETER STYLE SQL \n NOT DETERMINISTIC \n CALLED ON NULL INPUT \n TRUSTTYPE TRUSTED\n EXTERNAL NAME 'SL!api!F!MonitorSession_U'\nMonitorSession Syntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nA value of -1 indicates all hosts.\nUserNameIn\nUser name of the session.\nLake - Monitor Resources and Performance\nPage 230 of 420An asterisk (*) indicates all users.\nSessionNoIn\nNumber of the session.\nA value of zero indicates all sessions.\nHostId\nLogical host ID associated with a PE or session. For a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE. For a session, the combination of a host\nID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nLogonPENo\nVproc number of the PE the session is logged on to, which identiﬁes the PE that has control responsibility for the session. Typically, this is the PE that processed the logon\nrequest, but if that PE goes ofﬂine, this is the PE to which the session was switched.\nRunVprocNo\nVproc number of the AMP or PE assigned to process the session requests.\nFor sessions in Teradata SQL partitions, this value is identical to the LogonPENo. For sessions in FastLoad or MultiLoad partitions, this is the AMP that initially processes the\ndata being loaded.\nIf a RunVprocNo value of -1 in record mode or NULL in indicator mode is returned by MonitorSession for FastLoad, MultiLoad, or FastExport sessions, this indicates that the\nsession is in the process of starting up.\nPartName\nName of the session partition associated with this session. Following a successful logon request by a session or as part of a connect request, the session identiﬁes the partition\nwith which the user wants the session to be associated. FASTLOAD, Teradata SQL, MONITOR, INTERNAL are examples of valid partition names.\nPEstate\nCurrent state of the session within the PE. See the MONITOR SESSION PEState ﬁeld for a list of the PEState values.\nLogonTime\nDate and time portion of the information recorded by Session Control when a session logs on, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the\nyear, month, day, hours: minutes: seconds.\nUserId\nUser or internal ID of a user for this session. Within the database, UserId is equivalent to Database ID. Typically, UserId is used when the associated record is known to be a\nuser name, and Database ID is used when the associated record is known to be a database. However, UserId can identify either a given user or database name.\nLSN\nLogon Sequence Number (LSN) that is associated with a session when the session logs on, which identiﬁes a collection of sessions performing a related activity. For example,\nin a FastLoad job, a user is logged on as a Teradata SQL session and n FastLoad sessions with the same user name. Therefore, n+1 sessions (1 Teradata SQL and n FastLoad)\nwith the same LSN are all associated with the given FastLoad job. To see how the FastLoad job is doing, the user can pick out all sessions reported with the same LSN number.\nThis information supplies the parent-child relationship for sessions involved with FastLoad and MultiLoad jobs.\nUserName\nUser name of the session.\nUserAccount\nCurrent account for the session.\nPECPUsec\nCPU time, in seconds, used in a PE by the associated session for parsing and dispatching requests. Accurate to the second.\nThis value is valid only when associated with Teradata SQL and MONITOR partition sessions.\nXActCount\nNumber of explicit and implicit transactions run by the session.\nThis value is valid only when returned for Teradata SQL sessions, and is NULL for all other partition sessions. For this value, you must make a request for data before completion\nof the ﬁrst collection period that follows either a system outage or a change in the ResMonitor rate.\nReqCount\nNumber of requests (Tequel Start Request (TSR) messages) initiated by the session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or change in the ResMonitor rate.\nReqCacheHits\nNumber of times that this session processed a request using information from the Teradata SQL Parser request cache, speciﬁcally, number of times there was a request cache\nhit.\nThis value is valid only for Teradata SQL sessions, and is NULL for all other partition sessions. This value is also NULL when a request for data is made before completion of the\nﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPState\nCurrent state of the associated session in AMP vprocs in decreasing priority:\nState Description\nABORTING Transaction being rolled back; session aborting.\nBLOCKED Background activity in progress; last request on hold until background activity is\ncompleted.\nACTIVE Normal, on-going activity.\nIDLE No work in progress on any AMP.\nUNKNOWN No recorded activity since monitoring began.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or\nSesMonitorSys rate.\nAMPCPUSec\nCurrent elapsed CPU time, in seconds, used on all AMPs by the associated session for executing requests. For example, for Teradata SQL requests, this is the time spent by\nthe database actively working or rolling back an aborted transaction. This does not include any PDE CPU time spent handling database requests.\nLake - Monitor Resources and Performance\nPage 231 of 420This value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPIO\nCurrent number of logical Reads and Writes issued across all AMPs by the associated session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nReqSpool\nCurrent spool used by current request across all AMPs, expressed in bytes.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nBlk1HostId\nBlk2HostId\nBlk3HostId\nLogical host ID of a session causing a block. This value is derived from equating the transactions causing a database lock conﬂict to the sessions that issued those\ntransactions. The Blk_x_H ostId, in combination with Blk_x_S essNo , uniquely identiﬁes the session that is causing a block.\nThis value is NULL if:\nThe host ID is not available.\nThe session does not have an AMPState of BLOCKED.\nBlk1SessNo\nBlk2SessNo\nBlk3SessNo\nNumber of the session causing a block. This value is derived from associating the transactions causing a lock conﬂict to the sessions that issued those transactions. The\nBlk_x_S essNo, in combination with Blk_x_H ostId, uniquely identiﬁes the session causing a block.\nThis value is NULL if:\nSessNo is not available.\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1UserId\nBlk2UserId\nBlk3UserId\nID of the user or host utility job preventing the session from being granted a lock. The user ID is the only information available about who placed the lock.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1Lmode\nBlk2Lmode\nBlk3Lmode\nMode (severity) of the lock involved in causing a block:\nE = Exclusive\nW = Write\nR = Read\nA = Access\nLocks are reported in decreasing order of severity because removing the most severe lock conﬂict may eliminate the source of the lock conﬂict.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA session may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock in the queue and is in conﬂict with the lock requested by this blocked\nsession. For information on whether the lock is granted, see the MONITOR SESSION ﬁelds: Blk1Status, Blk2Status, and Blk3Status.\nBlk1Otype\nBlk2Otype\nBlk3Otype\nType of object whose lock is causing the session described by the associated row to be blocked:\nD = Database\nT= Table\nR = Row hash\nTP = Table Partition range\nRP = RowHash in Partition range\nRK = RowHash in one partition\nRN = RowKey range\nHowever, this object is not necessarily the type of object the blocked session is trying to access. For example, if the session is requesting a row hash lock, the blocking object\nmay be a database, table, or row hash.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nFor a Table T, User A can block User B with a table level lock on Table T on AMP_1 and with a Row Hash Level lock on that same Table T on AMP_2. When that occurs, the only\nlock conﬂict reported is that User B is blocked by User A on a table.\nBlk1ObjDBID\nBlk2ObjDBID\nBlk3ObjDBID\nUnique ID of the database object over which a lock conﬂict is preventing the session from being granted a lock.\nWithin the database system, Database ID is equivalent to User ID. Typically, User ID is used when the associated record is known to be a user name, and Database ID is used\nwhen the associated record is known to be a database. However, Database ID can identify either a user or database name.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLake - Monitor Resources and Performance\nPage 232 of 420Blk1ObjTID\nBlk2ObjTID\nBlk3ObjTID\nUnique ID of the table object over which a lock conﬂict is preventing the session from being granted a lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nThe Blk_x_OT ype is D.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1Status\nBlk2Status\nBlk3Status\nStatus of lock causing a block:\nW= Waiting\nG = Granted\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA lock request may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock request in the queue and is in conﬂict with it.\nA status of Waiting has a higher priority than that of Granted when there is more than one lock involved. For example, for a given object and a given session, a session that is\nblocked by a Waiting lock on one AMP and a Granted lock on another AMP has Waiting reported as its status.\nMoreBlockers\nIndicator of more lock conﬂicts:\nBlank = Blk x information is a complete list of sessions blocking the session described.\nAsterisk (*) = Additional sessions are blocking the session described.\nThis value is NULL if:\nThe state of the session is not BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLogonSource\nLogon source information. At logon time, this information is optionally supplied by the Teradata Director Program or the Gateway to further identify the physical or logical location\nof the session, the logon user name, and the interface under which the session was initiated. (For example, the data string may include DBC as the user ID and BTEQ as the\ninterface.)\nA two-byte value precedes the LogonSource data to indicate the length of the string. The length value is zero if LogonSource is NULL.\nHotAmpnCPU\nWhere n in [1, 3]: CPU time of the nth highest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth highest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIO\nWhere n in [1, 3]: I/O count of the nth highest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth highest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPU\nWhere n in [1, 3]: CPU time of the nth lowest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth lowest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIO\nWhere n in [1, 3]: I/O count of the nth lowest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth lowest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nAvgAmpCPUSec\nAverage AMP CPU usage for the last session collection interval. The average is calculated as the sum of CPU usage for all amps participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nAvgAmpIOCnt\nAverage AMP I/O usage for the last session collection interval. The average is calculated as the sum of I/O usage for all AMPs participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nLake - Monitor Resources and Performance\nPage 233 of 420AmpCount\nCurrent number of AMPs executing on the associated node.\nTempSpaceUsg\nTotal amount, in bytes, of temporary space used by the session.\nThis value is NULL if the session did not materialize any temporary tables.\nReqStartTime\nDate and time of the current request on the session started, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the year, month, day hours: minutes:\nseconds.\nReqCPU\nTotal CPU usage by the current SQL request on the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL requests only.\nIgnore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nThis ﬁeld is equivalent to the MONITOR SESSION RequestAmpCPU ﬁeld.\nReqIO\nTotal number of accesses by the current SQL request for the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL\nrequests only. Ignore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nThis ﬁeld is equivalent to the MONITOR SESSION RequestAmpI/O ﬁeld.\nReqNo\nActive request number.\nIf no request is running, a value of zero or NULL is displayed in indicator mode.\nIn the early phase of a request in parsing state, when PEState = PARSING, the request number may not be available and may be returned as zero or NULL. The active request\nnumber is available on the next collection.\nWlcId\nWorkload ID associated with the speciﬁed request.\nDontReclassifyFlag\nFlag indicating that the next request on the session is not classiﬁed, but uses the workload ID (WlcId) already assigned to the session. This occurs if this is a utility session or a\nWlcId was assigned to the session using the TDWMAssignWD function or the TDWM WD ASSIGNMENT request. See Teradata Dynamic Workload Management APIs: PM/APIs.\nProxyUser\nName of the proxy user in a trusted session.\nCPUDecayLevel\nCurrent most severe decay level, as reached due to CPU usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nIODecayLevel\nCurrent most severe decay level, as reached due to I/O usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nTacticalCPUException\nNumber of nodes that encountered a CPU exception.\nTacticalIOException\nNumber of nodes that encountered an I/O exception.\nReqIOKB\nTotal logical I/O usage in KB.\nReqPhysIO\nNumber of physical I/Os.\nReqPhysIOKB\nPhysical I/O usage in KB.\nReqStepsCompletedCnt\nCount of completed steps for the current request. If there is no change in ReqStepsCompletedCnt from the previous Monitor Session collection, this indicates that there are no\nnew steps completed.\nRedriveProtection\nRedrive protection type:\n' ' = No Redrive protection. The session does not participate in Redrive and database restarts are not transparent to applications and users.\nMN = Memory-based Redrive protection, no fallback spools\nCurrentRedriveParticipation\nIndicates if the session is participating in Redrive. Sessions that use Redrive can enable or disable the functionality using the REDRIVE reserved query band. Possible values:\nT = Redrive functionality is enabled (database restarts are transparent to applications and users)\nF = Redrive functionality is disabled (database restarts are not transparent to applications and users)\nReqRedriveSpoolSpace\nPersistent spool space for the current request.\nBlockerSessionCnt\nTotal number of blocker sessions for the session. Unlike the MONITOR SESSION request, this ﬁeld returns only the ﬁrst three blocker sessions in the record parcel. There are no\nadditional blocker sessions if there are more than three blocker sessions.\nReqTblOpBytesIn\nThe total number of bytes transferred into the database from a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesIn output parameter shows bytes transferred across all invocations within the request.\nReqTblOpBytesOut\nThe total number of bytes transferred out of the database and into a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesOut output parameter shows bytes transferred across all invocations within the request.\nProxyUserId\nThe UserID charged for SPOOL and TEMP space if being charged to the proxy user.\nZoneId\nThe unique identiﬁer of the zone.\nReqHotAmpCPU\nThe CPU time of the highest CPU used AMP during the life of the current request on the session.\nLake - Monitor Resources and Performance\nPage 234 of 420ReqHotAmpCPUId\nVproc ID of the highest CPU used AMP for the current request.\nReqHotAmpIO\nI/O count of the highest I/O used AMP during the life of the current request on the session.\nReqHotAmpIOId\nVproc ID of the highest I/O used AMP for the current request.\nReqInvolvedAMPCnt\nThe number of AMPs involved in processing the current request.\nReqFirstRespTime\nDate and time that the ﬁrst response of the current request on the session is ready. The response may be held to meet the TASM Minimum Response Time.\nReqLocalQueryStatus\nThe current state of the Uniﬁed Data Architecture (UDA) query.\nReqRemoteHostId\nHost ID of the remote system.\nReqRemoteSessionId\nSession ID of the executing remote query.\nReqRemoteRequestId\nRequest ID of the executing remote query.\nReqRemoteQueryId\nQuery ID of the executing remote query.\nReqHotAmpSpool\nSpool value of the highest spool used AMP during the life of the current request on the session.\nThis value is NULL if no request is running on the session.\nReqHotAmpSpoolId\nVproc ID of the highest spool used AMP for the current request.\nThis value is NULL if no request is running on the session.\nReqMapNo\nMap number for the largest map the request is using.\nReqMaxNumMapAMPs\nNumber of AMPs in the largest contiguous map used by the request.\nReqMinNumMapAMPs\nNumber of AMPs in the smallest contiguous map used by the request.\nReqSysDefNumMapAMPs\nNumber of AMPs in the system-default map used by the request.\nReqRemoteHostIp\nHost IP address of the remote system.\nReqServerName\nName of the foreign server.\nReqFlexReleased\nThe TDWM Flex Throttle feature detects available system resources, overrides existing workload throttle limits, and automatically releases queries from the delay queue. This\nminimizes the DBA manually managing the TASM delay queue. Only Workload throttles are overridden; all System level throttles are still honored.\nReturn values:\n0: Indicates that the request was not released by TDWM Flex Throttles.\n1: Indicates that the request was released by TDWM Flex Throttles.\nReqAdmissionTime\nReturns the date and time when a request is admitted into the system by TDWM.\nQueryID\nQuery ID of the session being monitored.\nCollectionTime\nDatabase time of when the session cache was last refreshed.\nMonitorSession Usage Notes\nThis table function is only supported in Constant Mode.\nThe following CPU ﬁelds in the MonitorSession response are affected by the MonSesCPUNormalization ﬁeld:\nAMPCPUSec\nAvgAmpCPUSec\nHotAmp1CPU\nHotAmp2CPU\nHotAmp3CPU\nLowAmp1CPU\nLowAmp2CPU\nLowAmp3CPU\nPECPUSec\nRequestAmpCPU\nThe MonSesCPUNormalization ﬁeld, controls whether normalized or non-normalized statistical CPU data is reported by the functions MonitorSession and MonitorMySessions, and by\nthe MONITOR SESSION request.\nSee MonitorMySessions or MONITOR SESSION for a list of these CPU ﬁelds.\nLake - Monitor Resources and Performance\nPage 235 of 420A Trusted Session enables a middle-tier application to switch the user on an already active database session to another user (proxy user). When the user is switched, all subsequent\nrequests use the privileges and session attributes of the proxy user. MonitorSession returns the logon user name and ID in the UserName and UserId ﬁelds and the proxy user name\nand ID in the ProxyUserName and ProxyUserId ﬁelds.\nThe MonitorSession function provides similar functionality to the PMPC MONITOR SESSION request. For information about this interface, see MONITOR SESSION.\nMonitorSession Examples\nsel * from table (monitorsession(-1,'*',0)) as t1;\nResult:\n                     HostId       1\n                  SessionNo         1025\n                  LogonPENo   30719\n                 RunVprocNo   30719\n                   PartName  DBC/SQL\n                    PEstate  IDLE\n                  LogonTime  2024/02/07 14:45:25.00\n                     UserId            1\n                        LSN            0\n                   UserName  DBC\n                UserAccount  DBC\n                   PECPUsec   3.08000000000000E-001\n                  XActCount   1.00000000000000E 000\n                   ReqCount   2.00000000000000E 000\n               ReqCacheHits   0.00000000000000E 000\n                   AMPState  IDLE\n                  AMPCPUSec   4.00000000000000E-003\n                      AMPIO   8.20000000000000E 001\n                   ReqSpool   0.00000000000000E 000\n                 Blk1HostId       0\n                 Blk1SessNo            0\n                 Blk1UserId            0\n                  Blk1Lmode\n                  Blk1Otype\n                Blk1ObjDBID            0\n                 Blk1ObjTID            0\n                 Blk1Status\n                 Blk2HostId       0\n                 Blk2SessNo            0\n                 Blk2UserId            0\n                  Blk2Lmode\n                  Blk2Otype\n                Blk2ObjDBID            0\n                 Blk2ObjTID            0\n                 Blk2Status\n                 Blk3HostId       0\n                 Blk3SessNo            0\n                 Blk3UserId            0\n                  Blk3Lmode\n                  Blk3Otype\n                Blk3ObjDBID            0\n                 Blk3ObjTID            0\n                 Blk3Status\n               MoreBlockers\n                LogonSource  (TCP/IP) 9436 127.0.0.1 DBC     10412  ROOT  BTEQ  01 LSS\n                 HotAmp1CPU   0.00000000000000E 000\n                 HotAmp2CPU   0.00000000000000E 000\n                 HotAmp3CPU   0.00000000000000E 000\n               HotAmp1CPUId       0\n               HotAmp2CPUId       0\n               HotAmp3CPUId       0\n                  HotAmp1IO   0.00000000000000E 000\n                  HotAmp2IO   0.00000000000000E 000\n                  HotAmp3IO   0.00000000000000E 000\n                HotAmp1IOId       0\n                HotAmp2IOId       0\n                HotAmp3IOId       0\n                 LowAmp1CPU   0.00000000000000E 000\n                 LowAmp2CPU   0.00000000000000E 000\n                 LowAmp3CPU   0.00000000000000E 000\n               LowAmp1CPUId       0\nLake - Monitor Resources and Performance\nPage 236 of 420               LowAmp2CPUId       0\n               LowAmp3CPUId       0\n                  LowAmp1IO   0.00000000000000E 000\n                  LowAmp2IO   0.00000000000000E 000\n                  LowAmp3IO   0.00000000000000E 000\n                LowAmp1IOId       0\n                LowAmp2IOId       0\n                LowAmp3IOId       0\n               AvgAmpCPUSec   0.00000000000000E 000\n                AvgAmpIOCnt   0.00000000000000E 000\n                   AmpCount       0\n               TempSpaceUsg   0.00000000000000E 000\n               ReqStartTime  0000/00/00 00:00:00.00\n                     ReqCPU   0.00000000000000E 000\n                      ReqIO   0.00000000000000E 000\n                      ReqNo            0\n                      WlcId           30\n         DontReclassifyFlag       0\n                  ProxyUser\n              CPUDecayLevel       0\n               IODecayLevel       0\n       TacticalCPUException            0\n        TacticalIOException            0\n                    ReqIOKB   0.00000000000000E 000\n                  ReqPhysIO   0.00000000000000E 000\n                ReqPhysIOKB   0.00000000000000E 000\n       ReqStepsCompletedCnt            0\n          RedriveProtection  MN\nCurrentRedriveParticipation  F\n       ReqRedriveSpoolSpace   0.00000000000000E 000\n          BlockerSessionCnt       0\n            ReqTblOpBytesIn   0.00000000000000E 000\n           ReqTblOpBytesOut   0.00000000000000E 000\n                ProxyUserId            0\n                     ZoneId            0\n               ReqHotAmpCPU   0.00000000000000E 000\n             ReqHotAmpCPUId      -1\n                ReqHotAmpIO   0.00000000000000E 000\n              ReqHotAmpIOId      -1\n          ReqInvolvedAMPCnt       0\n           ReqFirstRespTime  0000/00/00 00:00:00.00\n        ReqLocalQueryStatus       0\n            ReqRemoteHostId       0\n         ReqRemoteSessionId            0\n         ReqRemoteRequestId            0\n           ReqRemoteQueryId   0.00000000000000E 000\n             ReqHotAmpSpool   0.00000000000000E 000\n           ReqHotAmpSpoolId      -1\n                   ReqMapNo       0\n           ReqMaxNumMapAMPs            0\n           ReqMinNumMapAMPs            0\n        ReqSysDefNumMapAMPs            0\n            ReqRemoteHostIp\n              ReqServerName\n            ReqFlexReleased       0\n           ReqAdmissionTime  0000/00/00 00:00:00.00\n         ComputeWorkerInUse  F\n                    QueryID   307197241654252384.\n             CollectionTime  2024-03-16 12:35:00.00000\nMonitorSessionRate\nReturns session rate (duration of the collection period in seconds).\nMonitorSessionRate Syntax\nMonitorSessionRate Usage Notes\nMonitorSessionRate Example\nMonitorSessionRate Syntax\nREPLACE FUNCTION SYSLIB.MonitorSessionRate (\n  HostIdIn  SMALLINT,\n  UserNameIn  TD_ANYTYPE,\nLake - Monitor Resources and Performance\nPage 237 of 420  SessionNoIn  INTEGER\n) RETURNS SMALLINT\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nA value of -1 indicates all hosts.\nUserNameIn\nUser name of the speciﬁed sessions.\nA value of -1 indicates all hosts.\nSessionNoIn\nNumber of the speciﬁed session.\nA value of zero indicates all sessions.\nMonitorSessionRate Usage Notes\nBefore you monitor the collection rate, you use the SetSessionRate function to set the collection rate for updating session-level statistics in memory.\nThe MonitorSessionRate function provides similar functionality to the PMPC Monitor Session request. For information about this interface, see MONITOR SESSION.\nMonitorSessionRate Example\nSELECT MonitorSessionRate(1,'*',0);\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 7 seconds.\nMonitorSessionRate(1, '*', 0)\n-----------------------------\n                          60\nMonitorSQLCurrentStep\nReturns data about the step running of the running request for the speciﬁed host, session, and vproc.\nMonitorSQLCurrentStep Syntax\nMonitorSQLCurrentStep Syntax Elements\nMonitorSQLCurrentStep Usage Notes\nMonitorSQLCurrentStep Example\nMonitorSQLCurrentStep Syntax\nREPLACE FUNCTION SYSLIB.MonitorSQLCurrentStep (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER,\n    DynamicPlan  SMALLINT\n    PartialSteps SMALLINT,\n    NumOfSteps SMALLINT,\n    CurLvl1StepNo SMALLINT,\n    CurLvl2StepNo SMALLINT\n    ZoneID INTEGER,\n    SPName VARCHAR(128) CHARACTER SET UNICODE,\n    SPDBName VARCHAR(128) CHARACTER SET UNICODE\n    DefaultDBName VARCHAR(128) CHARACTER SET UNICODE\n  )\n  ...\n;\nMonitorSQLCurrentStep Syntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nA value of -1 indicates all hosts.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nLake - Monitor Resources and Performance\nPage 238 of 420Logical host ID associated with a PE or session. For a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE. For a session, the combination of a host\nID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nDynamicPlan\nPlan type:\n0 = Static plan\n1 = Dynamic plan\nSee EXPLAIN Request Modiﬁer.\nPartialSteps\nPossible values:\n0 = All steps are returned\n1 = Partial plan or no plan is returned\nIf a partial plan is returned, this indicates the steps for the ﬁnal plan fragment of the dynamic explanation of the request has not yet been generated.\nIf no plan is returned, this indicates the request has been throttled and is in the delay queue.\nA value 1 cannot occur for a static plan.\nFor more information on static and dynamic explanations of a request, see STATIC EXPLAIN and DYNAMIC EXPLAIN.\nNumOfSteps\nNumber of steps in the description text in the third statement of the response.\nPlan DynamicPlan Field V alue PartialSteps Field V alue NumOfSteps\nStatic 0   Number of steps for plan.\nComplete dynamic 1 0 Number of steps for plan.\nPartial dynamic 1 1 Number of steps generated.\nIf a request with a partial dynamic plan has been throttled and is in the delay queue (that is, no rows are returned in response to the third statement), NumOfSteps is zero.\nFor more information, see the MONITOR SQL DynamicPlan and PartialSteps ﬁelds.\nCurLvl1StepNo\nNumber of the running level 1 step. If parallel steps are running, this is the number of the lowest running step.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for example, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are\nPartialSteps ﬁeld values are 1), the CurLvl1StepNo ﬁeld value is zero.\nCurLvl2StepNo\nNumber of the running step. If parallel steps are running, this is the number of the highest executing step. If only one step is running, CurLvl1StepNo and CurLvl2StepNo are\nidentical.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for example, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are\nPartialSteps ﬁeld values are 1), the CurLvl2StepNo ﬁeld value is 1.\nIf only one step is executing, CurLvl1StepNo and CurLvl2StepNo are identical.\nZoneId\nThe unique identiﬁer of the zone.\nSPName\nThe outer stored procedure name, if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nSPDName\nThis is the owner database name of the outer stored procedure if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nDefaultDBName\nThis ﬁeld returns the default database name of the session at the start of the non-stored procedure request. For stored procedures, this ﬁeld returns the default database name\nof the session when the stored procedure was compiled.\nMonitorSQLCurrentStep Usage Notes\nThis table function is only supported in Constant Mode.\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned. The timeout interval can be set in PMPC_TimeoutSecs. The default timeout interval is 60 seconds.\nThe MonitorSQLCurrentStep function provides similar functionality to the PMPC MONITOR SQL request. For information about this interface, see MONITOR SQL.\nMonitorSQLCurrentStep Example\nselect * from table (monitorsqlcurrentstep(1,1472,30718)) as t1;\n*** Query completed. One row found. 11 columns returned.\n*** Total elapsed time was 1 second.\n       HostId      1\n    SessionNo        1472\n  DynamicPlan      0\nLake - Monitor Resources and Performance\nPage 239 of 420PartialSteps      0\n   NumOfSteps     13\nCurLvl1StepNo     10\nCurLvl2StepNo     10\n       ZoneId           0\n       SPName\n     SPDBName\nDefaultDBName TESTUSER\nMonitorSQLSteps\nReturns the step information (that is, a scaled-down version of the output of the EXPLAIN request modiﬁer) of the current or running request for the speciﬁed host, session, and vproc.\nMonitorSQLSteps Syntax\nMonitorSQLSteps Syntax Elements\nMonitorSQLSteps Usage Notes\nMonitorSQLSteps Example\nMonitorSQLSteps Syntax\nREPLACE FUNCTION SYSLIB.MonitorSQLSteps (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER,\n    DynamicPlan SMALLINT,\n    PartialSteps SMALLINT \n    StepNum INTEGER,\n    Confidence SMALLINT,\n    EstRowCount FLOAT,\n    ActRowCount FLOAT,\n    EstRowCountSkew FLOAT,\n    ActRowCountSkew FLOAT,\n    EstRowCountSkewMatch FLOAT,\n    ActRowCountSkewMatch FLOAT,\n    EstElapsedTime FLOAT,\n    ActElapsedTime FLOAT,\n    SQLStep  VARCHAR(2048)CHARACTER SET UNICODE\n  )\n  ...\n;\nMonitorSQLSteps Syntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nLogical host ID associated with a PE or session. For a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE. For a session, the combination of a host\nID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs. A value of zero represents the Supervisor window.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nDynamicPlan\nPlan type:\n0 = Static plan\n1 = Dynamic plan\nSee EXPLAIN Request Modiﬁer.\nPartialSteps\nPossible values:\n0 = All steps are returned\n1 = Partial plan or no plan is returned\nIf a partial plan is returned, this indicates the steps for the ﬁnal plan fragment of the dynamic explanation of the request has not yet been generated.\nIf no plan is returned, this indicates the request has been throttled and is in the delay queue.\nA value 1 cannot occur for a static plan.\nLake - Monitor Resources and Performance\nPage 240 of 420For more information on static and dynamic explanations of a request, see STATIC EXPLAIN and DYNAMIC EXPLAIN.\nStepNum\nUnique number identifying the EXPLAIN step.\nConﬁdence\nConﬁdence level as determined by the optimizer:\n0 = None\n1= Foreign Key\n2 = Low\n3 = High\nEstRowCount\nEstimated row count generated from the Optimizer plan for this step.\nFor a PRPD plan, the EstRowCount ﬁeld for the split step (that is, a RETRIEVE or JOIN step with “split into” appearing in the EXPLAIN when target spools are generated) is the\nestimated row counts for ALL split spools.\nFor more information on PRPD, see Join Strategies and Methods.\nActRowCount\nActual row count returned from the AMP for this step.\nFor a PRPD plan, this value includes rows from all split spools for a split step.\nSee Join Strategies and Methods\nEstRowCountSkew\nEstimated row count for the skew split spool in PRPD, which contains the rows with skewed values of this spool.\nSee Join Strategies and Methods\nActRowCountSkew\nActual number of rows for the skew split spool in PRPD.\nSee Join Strategies and Methods\nEstRowCountSkewMatch\nEstimated row count for the skew match split spool in PRPD, which contains the rows with skewed values of the other relation to be joined with this relation.\nFor more information on PRPD, see Join Strategies and Methods\nActRowCountSkewMatch\nActual number of rows for the skew match split spool in PRPD.\nFor more information on PRPD, see Join Strategies and Methods\nEstElapsedTime\nEstimated time for the query as generated from the Optimizer plan.\nActElapsedTime\nActual elapsed time calculated by the dispatcher.\nSQLStep\nGenerated text for the step.\nMonitorSQLSteps Usage Notes\nThis table function is only supported in Constant Mode.\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned. The timeout interval can be set in PMPC_TimeoutSecs. The default timeout interval is 60 seconds.\nThe MonitorSQLSteps function provides similar functionality to the PMPC MONITOR SQL request. For information about this interface, see MONITOR SQL.\nMonitorSQLSteps Example\nselect StepNum (format '99') Num,\nConfidence (format '9') C,\nEstRowCount (format '-99999999') ERC,\nActRowCount (format '99999999') ARC,\nEstRowCountSkew (format '-99999999') ERCS,\nActRowCountSkew (format '99999999') ARCS,\nEstRowCountSkewMatch (format '-99999999') ERCSM,\nActRowCountSkewMatch (format '99999999') ARCSM,\nEstElapsedTime (format '99999') EET,\nActElapsedTime (format '99999') AET,\nSQLStep\nfrom table (MonitorSQLSteps(1, 1164, 30719)) as t2;\n *** Query completed. 33 rows found. 11 columns returned.\n *** Total elapsed time was 3 seconds.\nNum C       ERC      ARC      ERCS     ARCS     ERCSM    ARCSM   EET   AET SQLStep\n--- - --------- -------- --------- -------- --------- -------- ----- ----- ------------------------------------------------------------\n 01 0  00000000 00000004  00000000 00000000  00000000 00000000 00000 00000 First, lock [DBId=0x0407]. for exclusive.\n 02 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 Next, we lock DBC.[TBId=0x0130] for write on a row hash.\n 03 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We lock DBC.DBSpace for write on a row hash.\n 04 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We lock DBC.Parents for write on a row hash.\n 05 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We lock DBC.Owners for write on a row hash.\n 06 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We lock DBC.AccessRights for write on a row hash.\n 07 0  00000000 00000004  00000000 00000000  00000000 00000000 00000 00000 We lock DBC.[TBId=0x0130] for write, we lock DBC.DBSpace for w\nte, we lock DBC.DBase for write on a row hash, we lock DBC.DBase for write on a row hash, we lock DB\nLake - Monitor Resources and Performance\nPage 241 of 420 08 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP ABORT test from DBC.DBase by way of the uni\n 08 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP ABORT test from DBC.[TBId=0x0138] by way of\n 08 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP ABORT test from DBC.DBase by way of the uni\n 08 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP ABORT test from DBC.DBase by way of the uni\n 08 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do an INSERT step into table DBC.DBase. This step is perfor\n 08 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP UPDATE from DBC.DBase by way of the unique \n 08 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP RETRIEVE step from DBC.Parents by way of th\node to few AMPs. This step ends a parallel block of steps.\n 09 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We do a MERGE into table DBC.Owners from Spool 54.\n 10 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do an INSERT step into table DBC.Owners. This step begins a\n 10 0  00000000 00000000  00000000 00000001  00000000 00000001 00000 00000 We do a Single-AMP RETRIEVE step from DBC.Parents by way of th\node to few AMPs. This step ends a parallel block of steps.\n 11 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We do a MERGE into table DBC.Parents from Spool 55.\n 12 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do an INSERT step into table DBC.Parents. This step begins \n 12 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do an INSERT step into table DBC.Accounts. This step is per\n 12 0  00000000 00000025  00000000 00000000  00000000 00000000 00000 00000 We do a Single-AMP RETRIEVE step from DBC.AccessRights accessi\n, which is redistributed by hash code to few AMPs. This step ends a parallel block of steps.\n 13 0  00000000 00000021  00000000 00000000  00000000 00000000 00000 00000 We do a Single-AMP RETRIEVE step from DBC.AccessRights accessi\n, which is redistributed by hash code to few AMPs. This step begins a parallel block of steps.\n 13 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We do an All-AMPs RETRIEVE step from DBC.AccessRights by way o\nh code to all AMPs. This step ends a parallel block of steps.\n 14 0  00000000 00000046  00000000 00000000  00000000 00000000 00000 00000 We do an All-AMPs JOIN step from DBC.Owners by way of an all-r\n7 are joined using a merge join . The result goes into Spool 56, which is redistributed by hash code\n 15 0  00000000 00000046  00000000 00000000  00000000 00000000 00000 00000 We do a MERGE into table DBC.AccessRights from Spool 56. This \n 15 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We do an INSERT step into table [TBId=0x0130]. This step ends \n 16 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We flush the DISKSPACE and AMPUSAGE caches.\n 17 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We do an All-AMPs ABORT test from DBC.DBSpace by way of the un\n 18 0  00000000 00000004  00000000 00000000  00000000 00000000 00000 00000 We do an INSERT step into table DBC.DBSpace.\n 19 0  00000000 00000004  00000000 00000000  00000000 00000000 00000 00000 We do an All-AMPs UPDATE from DBC.DBSpace by way of the unique\n 20 0  00000000 00000000  00000000 00000000  00000000 00000000 00000 00000 We flush the DISKSPACE and AMPUSAGE caches.\n 21 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00001 We Spoil the parser's dictionary cache for the database.\n 22 0  00000000 00000001  00000000 00000001  00000000 00000001 00000 00000 We send out an END TRANSACTION step to all AMPs involved in pr\nMonitorSQL Text\nReturns the SQL text of the request being run for the speciﬁed host, session, and vproc.\nMonitorSQLText Syntax\nMonitorSQLText Usage Notes\nMonitorSQLText Example\nMonitorSQLText Syntax\nREPLACE FUNCTION SYSLIB.MonitorSQLText (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER, \n    SeqNum SMALLINT,\n    SQLTxt VARCHAR(31000) CHARACTER SET UNICODE\n  )\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nHost ID of the SQLtext.\nSessionNo\nSession number of the SQLtext.\nSeqNum\nSequence number of the row. For example, if the SQL text exceeds 31,000 bytes, the system returns multiple rows.\nSQLTxt\nSQL text of the running request.\nLake - Monitor Resources and Performance\nPage 242 of 420MonitorSQLText Usage Notes\nThis table function is only supported in Constant Mode.\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned. The timeout interval can be set in PMPC_TimeoutSecs. The default timeout interval is 60 seconds.\nThe MonitorSQLText function provides similar functionality to the PMPC MONITOR SQL request. For information about this interface, see MONITOR SQL.\nMonitorSQLText Example\nSELECT SQLTxt FROM TABLE (MonitorSQLText(1, 1001, 16383)) AS t2;\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 58 seconds.\nSQLTxt\n------------------------------------------------------------------------\nselect a11.c1, a12.c1, a13.c1, a21.c1, a22.c1, a23.c1  from dbaaa.skewAmp1\n a11, dbaaa.skewAmp1 a12, dbaaa.skewAmp1 a13, dbaaa.skewAmp1 a21, dbaaa.sk\newAmp1 a22, dbaaa.skewAmp1 a23;\nMonitorSystemPhysicalConﬁg\nReturns BYNET status, system type and name values that are generated once for the whole system.\nMonitorSystemPhysicalConﬁg Syntax\nMonitorSystemPhysicalConﬁg Usage Notes\nMonitorSystemPhysicalConﬁg Examples\nMonitorSystemPhysicalConﬁg Syntax\nREPLACE FUNCTION SYSLIB.MonitorSystemPhysicalConfig (\n) RETURNS TABLE (\n    NetAUp CHAR CHARACTER SET LATIN,\n    NetBUp CHAR CHARACTER SET LATIN,\n    SystemType VARCHAR(7) CHARACTER SET LATIN,\n    SystemName VARCHAR(15) CHARACTER SET LATIN\n  )\n  ...\n;\nSyntax Elements\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nSystemType\nType of system running the database software, such as 5650, 6700, or 'Other'.\nIf all the nodes in the system are the same type, this ﬁeld returns the type of the system.\nIf any of the nodes are of a different type, this ﬁeld returns 'Mixed'.\nSystemName\nName of the system running Teradata.\nMonitorSystemPhysicalConﬁg Usage Notes\nThe MonitorSystemPhysicalConﬁg function provides similar functionality to statement 1 of the MONITOR PHYSICAL CONFIG request. For more information, see MONITOR PHYSICAL\nCONFIG.\nMonitorSystemPhysicalConﬁg Examples\nUsing MonitorSystemPhysicalConﬁg\nSELECT * FROM table (SYSLIB.MonitorSystemPhysicalConfig()) as t1;\n *** Query completed. One row found. 4 columns returned.\n *** Total elapsed time was 1 second.\nNetAUp  NetBUp  SystemType  SystemName\n------  ------  ----------  ---------------\nU       U       5500C       localhost\nUsing MonitorSystemPhysicalConﬁg to Select a Speciﬁc Column\nLake - Monitor Resources and Performance\nPage 243 of 420SELECT SystemName FROM table (SYSLIB.MonitorSystemPhysicalConfig()) as t1;\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nSystemName\n---------------\nlocalhost\nMonitorV irtualConﬁg\nCollects information on virtual processor (vproc) availability.\nMonitorVirtualConﬁg Syntax\nMonitorVirtualConﬁg Usage Notes\nMonitorVirtualConﬁg Example\nMonitorVirtualConﬁg Syntax\nREPLACE FUNCTION SYSLIB.MonitorVirtualConfig (\n) RETURNS TABLE (\n    ProcId INTEGER,\n    VprocNo SMALLINT,\n    Vproctype VARCHAR(3) CHARACTER SET LATIN,\n    HostId SMALLINT,\n    Status CHAR CHARACTER SET LATIN,\n    DiskSlice SMALLINT\n  )\n  ...\n;\nSyntax Elements\nProcId\nID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nVprocNo\nID of an AMP (that is, a set of disks and the associated tasks or processes that, in combination, make up the AMP), PE, or TVS vproc.\nVproctype\nType of vproc:\nAMP\nPE\nMISC\nHostId\nLogical host ID associated with a PE or session. For a PE, HostId identiﬁes one of the hosts or LANs associated with the described PE. For a session, the combination of a host\nID and a session number uniquely identiﬁes a user session on the system.\nThis value is NULL for AMPs and TVS vprocs. A value of zero represents the Supervisor window.\nStatus\nStatus of the vproc associated with this record. A vproc is considered up or down from the standpoint of whether the vproc is helping a query process SQL statements. For\nexample, an AMP doing ofﬂine recovery is considered to be down because the AMP is not helping to process SQL statements. However, an up vproc is one that is online and\nfully up or is in online recovery.\nThe status of the vproc:\nU = The vproc is up/online.\nD = The vproc is down/ofﬂine.\nDiskSlice\nVirtual disk ID deﬁning the portion of a physical disk assigned to an AMP.\nThis value is NULL for TVS vprocs.\nMonitorVirtualConﬁg Usage Notes\nThe MonitorVirtualConﬁg function provides similar functionality to the PMPC MONITOR VIRTUAL CONFIG request. For more information, see MONITOR VIRTUAL CONFIG.\nMonitorVirtualConﬁg Example\nSELECT t2.* FROM TABLE (MonitorVirtualConfig()) AS t2;\n *** Query completed. 8 rows found. 6 columns returned.\n *** Total elapsed time was 1 second.\nProcId  VprocNo  Vproctype  HostId  Status  DiskSlice\n------  -------  ---------  ------  ------  ---------\n 10001        0  AMP             0  U               0\n 10001        1  AMP             0  U               1\n 10001        2  AMP             0  U               2\nLake - Monitor Resources and Performance\nPage 244 of 420 10001        3  AMP             0  U               3\n 10001    28670  TVS             0  U               0\n 10001    28671  TVS             0  U               0\n 10001    30718  PE              1  U               0\n 10001    30719  PE              1  U               0\nMonitorV irtualResource\nCollects performance information for each AMP, PE, or TVS vproc.\nMonitorVirtualResource Syntax\nMonitorVirtualResource Syntax Elements\nMonitorVirtualResource Usage Notes\nMonitorVirtualResource Example\nMonitorVirtualResource Syntax\nREPLACE FUNCTION SYSLIB.MonitorVirtualResource (\n) RETURNS TABLE (\n    VprocNo SMALLINT,\n    VprocType VARCHAR(3) CHARACTER SET LATIN,\n    Status CHAR CHARACTER SET LATIN,\n    ProcId INTEGER,\n    ClusterNo SMALLINT,\n    SessLogCount SMALLINT,   \n    SessRunCount SMALLINT,\n    CPUUse FLOAT,\n    PctService FLOAT,\n    PctAMPWT FLOAT,\n    DiskUse FLOAT,\n    DiskReads FLOAT,\n    DiskWrites FLOAT,\n    DiskOutReqAvg FLOAT,\n    PctParser FLOAT,\n    PctDispatcher FLOAT,\n    HstBlkRds FLOAT,\n    HstBlkWrts FLOAT,\n    NetReads FLOAT,\n    NetWrites FLOAT,\n    NVMemAllocSegs FLOAT\n   )\n  ...\n;\nMonitorVirtualResource Syntax Elements\nVprocNo\nID of an AMP (that is, a set of disks and the associated tasks or processes that, in combination, make up the AMP), PE or TVS vproc.\nVprocType\nType of vproc:\nAMP\nPE\nMISC\nStatus\nStatus of the node, AMP, PE, or TVS vproc associated with this record:\nU = Up/online.\nD = Down/ofﬂine.\nA node is up (U) when the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can performing tasks associated with normal database activity.\nDown (D) represents all other potential states.\nProcId\nID associated with a node.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nClusterNo\nNumber that identiﬁes the compute cluster to which this AMP is assigned.\nClusterNo is not applicable to TVS vproc and returns NULL.\nSessLogCount\nNumber of current sessions logged to this PE. A logged on session is either a session whose logon request was delivered to this PE, or a session that was switched to this PE\nfollowing its logon.\nThe SessLogCount ﬁeld contains the SubPoolId if the vproc type is TVS.\nLake - Monitor Resources and Performance\nPage 245 of 420SubpoolId identiﬁes the subpool associated with the allocator vproc. A subpool deﬁnes a set of storage and allocator vprocs assigned to that storage.\nThis value is NULL if certain conditions apply, see usage notes.\nSessRunCount\nNumber of current sessions whose Initiate Requests (TSR messages) are addressed to this vproc. For example:\nPEs have a SessRunCount that includes all the Teradata SQL and MONITOR sessions logged on to that PE.\nAMPs may have a nonzero SessRunCount, because AMPs receive TSR messages from FastLoad or MultiLoad logons.\nThis value is NULL if certain conditions apply, see usage notes.\nThis ﬁeld is not applicable to TVS vprocs.\nCPUUse\n% of CPU usage not spent being idle.\nThis value is computed from ResUsageSvpr table data, where NCPUs is the number of CPUs in the node:\n100.00 * (CPUUExecPart00 + CPUUExecPart01 + ... + CPUUExecPart47 + CPUUServPart00 + CPUUServPart01 + ... + CPUUServPart47) / (NCPUs * SampleSec * 100)\nThis value is NULL if certain conditions apply, see usage notes.\nPctService\n% of CPU resources spent in PDE user service processing.\nThis value is computed from the ResUsageSvpr table data, where x represents the number of CPUs:\n(CPUUServPart00 + CPUUServPart01 + ... + CPUUServPart47) /(x * SampleSec)\nThis value is NULL if certain conditions apply, see usage notes.\nPctAMPWT\n% of CPU resources used by either the AMP Worker Task (Partition 11) or by the TVS Task (Partition 31) depending on the type of vproc this record represents.\nThis value depends on the number of CPUs in the node but does not exceed 100%. The value is computed from the ResUsageSvpr table data, where x represents the number\nof CPUs on a node:\nFor AMP vprocs:\n(CPUUExecPart11) / (x * SampleSec)\nFor TVS vprocs:\n(CPUUExecPart31) / (x * SampleSec)\nThis value is NULL if certain conditions apply, see usage notes.\nDiskUse\n% of disk usage per AMP. This value is computed from the ResUsageSvdsk table data:\nOutReqTime / SampleSec\nDiskUse does not take into account overlapping of operations among multiple storage controllers, but does allow for the possibility of multiple requests for the same controller.\nThis value is NULL if certain conditions apply, see usage notes.\nDiskReads\nTotal number of physical disk reads per AMP during the collection period.\nThis value is computed from the ResUsageSvpr table data as:\nFilePCiAcqReads + FilePDbAcqReads + FileSciAcqReads + FileSDbAcqReads + FileTjtAcqReads + FileAPtAcqReads\nThis value is NULL if certain conditions apply, see usage notes.\nThis ﬁeld is not applicable to TVS and PE vprocs.\nDiskWrites\nTotal number of physical disk writes per AMP during the collection period.\nFor PE and AMP-level displays, this value is computed from ResUsageSvpr table data as:\nFilePCiFWrites + FilePDbFWrites + FileSCiFWrites + FilesDbFWrites + FileTjtFWrites + FileAPtFWrites + FilePCiDyaWrites + FilePDbDyaWrites + FileSciDyaWrites +\nFilesDbDyaWrites + FileTjtDyaWrites + FileAptDyaWrites\nFor TVS vproc displays, this value is computed from ResUsageSvpr table data as:\nAllocatorMapIOsDone\nThis value is NULL if certain conditions apply, see usage notes.\nDiskOutReqAvg\nAverage number of outstanding disk requests.\nFor AMP-level displays, this value is computed from ResUsageSvdsk table data, assuming n is the number of storage devices used by this vproc:\n(ReadRespTot 1 + WriteRespTot 1 + ... + ReadRespTot n + WriteRespTot n) / CentiSecs\nThis ﬁeld is not applicable to PE vprocs.\nFor TVS vproc-level displays, this value is computed from ResUsageSvpr table data as:\nAllocatorMapIOsStarted - AllocatorMapIOsDone\nThis value is NULL if certain conditions apply, see usage notes.\nPctParser\nThis ﬁeld is deprecated and returns zero or NULL.\nPctDispatcher\n% of CPU resources spent in PE Dispatcher processing.\nThis value depends on the number of CPUs in the node, but does not exceed 100%. This value is computed from the ResUsageSvpr table data, where x represents the number\nof CPUs on a node:\n(CPUUExecPart13 + CPUUServPart13) / (x * SampleSec)\nThe PercntParser CPU time is included in the PercntDispatcher value.\nThis value is NULL if certain conditions apply, see usage notes.\nThis ﬁeld is not applicable to AMP and TVS vprocs.\nHstBlkRds\nNumber of message blocks (one or more messages sent in one physical group) received from all clients.\nThis value corresponds to the column totals in the ResUsageShst table supplying HostBlockReads for this vproc.\nThis value is NULL if certain conditions apply, see usage notes.\nThis ﬁeld is not applicable to AMP and TVS vprocs.\nLake - Monitor Resources and Performance\nPage 246 of 420HstBlkWrts\nNumber of message blocks (that is, one or more messages sent in one physical group) sent to all hosts.\nThis value corresponds to the column totals in the HstBlkWrts column of the ResUsageShst table.\nThis value is NULL if certain conditions apply, see usage notes.\nThis ﬁeld is not applicable to AMP and TVS vprocs.\nNetReads\nNumber of Reads from the BYNET to the vproc.\nThe value is computed from the ResUsageSvpr table data as:\nNetBrdReads + NetPtPReads\nThis value is NULL if certain conditions apply, see usage notes.\nNetWrites\nNumber of messages written from the AMP, PE, or vproc to the BYNET during the collection period.\nThe value is computed from the ResUsageSvpr table data as:\nNetBrdWrites + NetPtPWrites\nThis value is NULL if certain conditions apply, see usage notes.\nNVMemAllocSegs\nValue is computed from ResUsageSvpr table data using the IoRespMax ﬁeld. The IoRespMax is the maximum I/O response time in milliseconds. That is, the number of\noperations for each AMP vproc on that node.\nThis ﬁeld is not applicable to AMP and TVS vprocs.\nThis value is NULL if certain conditions apply, see usage notes.\nThe NVMemAllocSegs ﬁeld of the MonitorVirtualResource function corresponds to the MaxIOResp ﬁeld of the MONITOR VIRTUAL RESOURCE request.\nMonitorVirtualResource Usage Notes\nThe MonitorVirtualResource function provides similar functionality to the PMPC MONITOR VIRTUAL RESOURCE request. For information about this interface, see MONITOR VIRTUAL\nRESOURCE.\nMonitorVirtualResource Example\nSELECT VprocNo, VprocType, Status, PRocId, ClusterNo FROM\nTABLE (MonitorVirtualResource()) AS t2;\n *** Query completed. 8 rows found. 5 columns returned.\n *** Total elapsed time was 1 second.\nVprocNo  VprocType  Status  ProcId  ClusterNo\n-------  ---------  ------  ------  ---------\n      0  AMP        U        10001          0\n      1  AMP        U        10001          1\n      2  AMP        U        10001          0\n      3  AMP        U        10001          1\n  28670  TVS        U        10001          0\n  28671  TVS        U        10001          0\n  30718  PE         U        10001       1025\n  30719  PE         U        10001       1025\nMonitorV irtualSummary\nCollects global summary information on system usage.\nMonitorVirtualSummary Syntax\nMonitorVirtualSummary Syntax Elements\nMonitorVirtualSummary Usage Notes\nMonitorVirtualSummary Example\nMonitorVirtualSummary Syntax\nREPLACE FUNCTION SYSLIB.MonitorVirtualSummary (\n) RETURNS TABLE (\n    AMPAvgCPU FLOAT,\n    AMPAvgDisk FLOAT, \n    AMPAvgDiskIO FLOAT, \n    HiCPUAMPUse FLOAT, \n    HiDiskAMP FLOAT,\n    HiDiskAMPIO FLOAT, \n    HiCPUAMPNo SMALLINT, \n    HiDiskAMPNo SMALLINT, \n    HiDiskAMPIONo SMALLINT, \n    HiCPUAMPProc INTEGER, \n    HiDiskAMPProc INTEGER, \n    HiDiskAMPIOProc INTEGER,\n    LoCPUAMPUse FLOAT,\n    LoDiskAMP FLOAT,\nLake - Monitor Resources and Performance\nPage 247 of 420    LoDiskAMPIO FLOAT, \n    LoCPUAMPNo SMALLINT, \n    LoDiskAMPNo SMALLINT,\n    LoDiskAMPIONo SMALLINT,\n    LoCPUAMPProc INTEGER, \n    LoDiskAMPProc INTEGER,\n    LoDiskAMPIOProc INTEGER,\n    PEAvgCPU FLOAT, \n    HiCPUPEUse FLOAT, \n    LoCPUPEUse FLOAT, \n    HiCPUPENo SMALLINT, \n    LoCPUPENo SMALLINT, \n    HiCPUPEProc INTEGER,\n    LoCPUPEProc INTEGER, \n    SessionCnt FLOAT, \n    SesMonitorSys SMALLINT, \n    SesMonitorLoc SMALLINT, \n    ResLogging SMALLINT, \n    ResMonitor SMALLINT, \n    ReleaseNum CHAR(30) CHARACTER SET LATIN, \n    Version CHAR(32) CHARACTER SET LATIN\n  )\n  ...\n;\nMonitorVirtualSummary Syntax Elements\nAMPAvgCPU\nAverage % CPU usage (CPUUse) of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgCPU is computed from CPUUse data as:\n(CPUUse 1+ ... + CPUUse n) / n\nThis value is NULL if certain conditions apply, see usage notes.\nAMPAvgDisk\nAverage physical disk usage (DiskUse) of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDisk is computed from DiskUse data as:\n(DiskUse 1+ ... + DiskUse n) / n\nThis value is NULL if certain conditions apply, see usage notes.\nAMPAvgDiskIO\nAverage physical disk DiskReads and DiskWrites of all online AMPs in the conﬁguration.\nAssuming n is the number of online AMPs in the conﬁguration, AMPAvgDiskIO is computed from DiskReads and DiskWrites data as:\n(DiskReads 1+ DiskWrites 1+ ... + DiskReads 1+ DiskWrites n) / n\nThis value is NULL if certain conditions apply, see usage notes.\nHiCPUAMPUse\nHighest CPUUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nHiDiskAMP\nHighest DiskUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nHiDiskAMPIO\nHighest DiskReads and DiskWrites value associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nHiCPUAMPNo\nVproc number (VprocNo) of an AMP with CPUUse equal to the value reported as HiCPUAMPUse.\nThis value is NULL if certain conditions apply, see usage notes.\nHiDiskAMPNo\nNumber of an AMP with DiskUse equal to the value reported as HiDiskAMP.\nThis value is NULL if certain conditions apply, see usage notes.\nHiDiskAMPIONo\nNumber of an AMP with the highest DiskReads and DiskWrites equal to the value reported as HiDiskAMPIO.\nThis value is NULL if certain conditions apply, see usage notes.\nHiCPUAMPProc\nID of the node responsible for managing the AMP reported as HiCPUAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nHiDiskAMPProc\nID of the node responsible for managing the AMP reported in HiDiskAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL when HiDiskAMPNo is NULL.\nHiDiskAMPIOProc\nID of the node responsible for managing the AMP reported in HiDiskAMPIONo.\nLake - Monitor Resources and Performance\nPage 248 of 420This value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL when HiDiskAMPIONo is NULL.\nLoCPUAMPUse\nLowest CPUUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nLoDiskAMP\nLowest DiskUse percentage associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nLoDiskAMPIO\nLowest DiskReads and DiskWrites number associated with any online AMP.\nThis value is NULL if certain conditions apply, see usage notes.\nLoCPUAMPNo\nVproc number (VprocNo) of an AMP with CPUUse equal to the value reported as LoCPUAMPUse.\nThis value is NULL if certain conditions apply, see usage notes.\nLoDiskAMPNo\nNumber of an AMP with DiskUse equal to the value reported as LoDiskAMP.\nThis value is NULL if certain conditions apply, see usage notes.\nLoDiskAMPIONo\nID of an AMP with lowest DiskReads and DiskWrites equal to the value reported as LoDiskAMPIO.\nThis value is NULL if certain conditions apply, see usage notes.\nLoCPUAMPProc\nID of the node responsible for managing the AMP reported as LoCPUAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nLoDiskAMPProc\nID of the node responsible for managing the AMP reported as LoDiskAMPNo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL when LoDiskAMPNo is NULL.\nLoDiskAMPIOProc\nID of the node responsible for managing the AMP reported as LoDiskAMPIONo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL when LoDiskAMPIONo is NULL.\nPEAvgCPU\nAverage CPUUse for all online PEs in the conﬁguration.\nThis value is NULL if certain conditions apply, see usage notes.\nHiCPUPEUse\nHighest CPUUse percentage associated with any online PE.\nThis value is NULL if certain conditions apply, see usage notes.\nLoCPUPEUse\nLowest CPUUse percentage associated with any online PE.\nThis value is NULL when LoCPUPEUse is NULL.\nHiCPUPENo\nVproc number (VProcNo) of a PE with CPUUse equal to the value reported as HiCPUPEUse.\nThis value is NULL if certain conditions apply, see usage notes.\nLoCPUPENo\nVproc number (VProcNo) of a PE with CPUUse equal to the value reported as LoCPUPEUse.\nThis value is NULL if certain conditions apply, see usage notes.\nHiCPUPEProc\nID of the node responsible for managing the PE reported in HiCPUPENo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL when HiCPUPENo is NULL.\nLoCPUPEProc\nID of the node responsible for managing the PE reported as LoCPUPENo.\nThis value is computed as the module number within a cabinet plus the cabinet number times 10000. For example, a node #123 on cabinet #4 returns an INTEGER value of\n40123.\nThis value is NULL if certain conditions apply, see usage notes.\nSessionCnt\nTotal number of sessions logged onto the system, typically equal to the sum of the SessLogCount values for all PEs.\nThis value is NULL if certain conditions apply, see usage notes.\nSesMonitorSys\nSets the maximum acceptable age of collected session-level data in memory to the PM/API application or end user.\nThe global rate is the default collection rate for all MONITOR sessions. If the value is set to zero, the collection capability is disabled.\nSesMonitorLoc\nSets the maximum acceptable age of collected session-level data in memory for an individual Monitor partition session that submits a MONITOR SESSION request.\nThis rate is initiated within a MONITOR session and may update session-level data within the system. If the value is zero, this allows SesMonitorSys to override the current local\nrate for that session.\nResLogging\nLake - Monitor Resources and Performance\nPage 249 of 420Interval in seconds at which resource usage data is written to one or more active resource usage database tables.\nResMonitor\nInterval in seconds at which all resource usage data is collected in memory for reporting using the PM/API.\nReleaseNum\nRelease number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nVersion\nVersion number of the running database software (for example, 15.00.00.00).\nThis value is supplied by the database.\nMonitorVirtualSummary Usage Notes\nThe MonitorVirtualSummary function provides similar functionality to the PMPC MONITOR VIRTUAL SUMMARY request. For information about this interface, see MONITOR VIRTUAL\nSUMMARY.\nMonitorVirtualSummary Example\nselect * from table (monitorvirtualsummary()) as t1;\n *** Query completed. One row found. 35 columns returned.\n *** Total elapsed time was 2 seconds.\n      AMPAvgCPU   2.47375437427095E 001\n     AMPAvgDisk   8.77770371604733E 000\n   AMPAvgDiskIO   1.25500000000000E 003\n    HiCPUAMPUse   2.48291951341443E 001\n      HiDiskAMP   9.28178636893851E 000\n    HiDiskAMPIO   1.27000000000000E 003\n     HiCPUAMPNo       1\n    HiDiskAMPNo       1\n  HiDiskAMPIONo       1\n   HiCPUAMPProc        10001\n  HiDiskAMPProc        10001\nHiDiskAMPIOProc        10001\n    LoCPUAMPUse   2.46625562406266E 001\n      LoDiskAMP   8.34860856523913E 000\n    LoDiskAMPIO   1.22300000000000E 003\n     LoCPUAMPNo       3\n    LoDiskAMPNo       3\n  LoDiskAMPIONo       0\n   LoCPUAMPProc        10001\n  LoDiskAMPProc        10001\nLoDiskAMPIOProc        10001\n       PEAvgCPU   0.00000000000000E 000\n     HiCPUPEUse   0.00000000000000E 000\n     LoCPUPEUse   0.00000000000000E 000\n      HiCPUPENo   30719\n      LoCPUPENo   30719\n    HiCPUPEProc        10001\n    LoCPUPEProc        10001\n     SessionCnt   1.00000000000000E 000\n  SesMonitorSys       1\n  SesMonitorLoc       0\n   VprocLogging      60\n   VprocMonitor      60\n     ReleaseNum  16u.00.00.41\n        Version  16u.00.00.41_dr182707n\nMonitorWD\nReturns the data in the second statement of the MONITOR WD response through an SQL interface consisting of UDFs.\nMonitorWD Syntax\nMonitorWD Syntax Elements\nMonitorWD Usage Notes\nMonitorWD Example\nMonitorWD Syntax\nREPLACE FUNCTION SYSLIB.MonitorWD (\n) RETURNS TABLE (\n    WDId INTEGER,\n    PPId SMALLINT,\nLake - Monitor Resources and Performance\nPage 250 of 420    PGId SMALLINT,\n    AGId SMALLINT,\n    RelWgt SMALLINT,\n    NumProcs INTEGER,\n    VprType VARCHAR(4) CHARACTER SET LATIN,\n    QWaitTime FLOAT,\n    QWaitTimeMax FLOAT,\n    CpuUserPct FLOAT,\n    WorkMsgMaxDelay FLOAT,\n    WorkTypeInuseMax INTEGER,\n    WorkTimeInuseAvg FLOAT,\n    IODelay FLOAT,\n    IODelayTime FLOAT,\n    PhysicalRead FLOAT,\n    PhysicalReadKB FLOAT,\n    PhysicalWrite FLOAT,\n    PhysicalWriteKB FLOAT,\n    LogicalRead FLOAT,\n    LogicalReadKB FLOAT,\n    LogicalWrite FLOAT,\n    LogicalWriteKB FLOAT,\n    ExtraField1 FLOAT,\n    ExtraField2 FLOAT,\n    ExtraField3 FLOAT,\n    ExtraField4 FLOAT\n    VPId SMALLINT,\n    VPId SMALLINT,\n    WaitIO FLOAT,\n    WaitOther FLOAT,\n    CPURunDelay FLOAT,\n    IOCntSubmitted FLOAT,\n    IOKBSubmitted FLOAT,\n    IOCntCompleted FLOAT,\n    IOKBCompleted FLOAT,\n    IOCntCriticalSubmitted FLOAT,\n    IOKBCriticalSubmitted  FLOAT,\n    DecayLevel1IO FLOAT,\n    DecayLevel2IO FLOAT,\n    DecayLevel1CPU FLOAT,\n    DecayLevel2CPU FLOAT,\n    TacticalExceptionIO FLOAT,\n    TacticalExceptionCPU FLOAT\n   )\n  ...\n;\nMonitorWD Syntax Elements\nPPId\nThis ﬁeld is deprecated and returns a value of zero.\nPGId\nThis ﬁeld returns the pWDid value.\nVprType\nType of vproc:\nAMP\nPE\nMISC\nWDId\nWD ID. On SLES 11 or later systems, TASM Workloads rule is enabled. On SUSE Linux Enterprise Server 11 or later systems, TASM Workloads rule is enabled.\nAGId\nThis ﬁeld is deprecated and returns a value of zero.\nRelWgt\nThis ﬁeld is deprecated and returns a value of zero.\nNumProcs\nAverage number of tasks of online nodes.\nThe ﬁeld is the result of:\nNumProcs = SUM of (NumTasks-i) / N\nwhere:\nNumTasks-i is the number of tasks assigned to the WD at the end of the reporting period.\ni varies from 1 to N, where N is the number of online nodes.\nThe NumProcs ﬁeld is the NumTasks ﬁeld in the PM/API MONITOR WD request.\nQWaitTime\nLake - Monitor Resources and Performance\nPage 251 of 420Total wait time in milliseconds that work requests waited on an input queue before being serviced.\nQWaitTimeMax\nMaximum time in milliseconds that work requests waited on an input queue before being serviced.\nThe ﬁeld is the result of:\nQWaitTimeMax = MAX (QWaitTimeMax-i)\nwhere:\nQWaitTimeMax-i is QWaitTimeMax in each online node.\ni varies from 1 to N, where N is the number of online nodes.\nCPUUserPct\nWeighted average of CpuUserPct of each node.\nThe ﬁeld is the result of:\nCpuUserPct = Sum of (CpuUserPct-i* ScalingFactor-i) / Sum of (ScalingFactor-i)\nwhere:\nCpuUserPct-i is calculated as:\n(CPUUServAwt + CPUUServDisp + CPUUServMisc + CPUUExecAwt + CPUUExecDisp + CPUUExecMisc) * 100 /(NCPUs*Centisecs*10)\nNCPUs is the number of CPUs in the node.\ni varies from 1 to N, where N is the number of online nodes.\nScalingFactor-i is the node CPU normalization factor in each node.\nThe CPU times are in milliseconds.\nThe Parser CPU times are included in the Dispatcher CPU times.\nWorkMsgMaxDelay\nGeneral indicator only. This ﬁeld is result of the following calculation:\nWorkMsgMaxDelay = MAX (WorkMsgMaxDelay-i)\nwhere:\nWorkMsgMaxDelay-i is calculated in each online node as:\nWorkMsgsendDelayMax + WorkMsgReceiveDelayMax\ni varies from 1 to N, where N is the number of online nodes.\nWorkMsgMaxDelay does not represent the subtotal of the same message on the send and receive side.\nWorkTypeInuseMax\nTotal of the AMP Worker Task (AWT) columns:\nWorkTypeInuseMax = MAX (WorkTypeInuseMax-i)\nwhere:\nWorkTypeInuseMax-i is the sum of WorkTypeMax00 through WorkTypeMax15 in each node.\ni varies from 1 to N, where N is the number of online nodes.\nWorkTimeInuseAvg\nAverage number of AWTs used. This ﬁeld is result of:\nWorkTimeInuseAvg = SUM of (WorkTimeInuse-i) / N\nwhere:\nWorkTimeInuse-i is calculated in each online node as:\nWorkTimeInuse/(Centisecs * 10 * NCPUs)\nNCPUs is the number of CPUs in the node.\ni varies from 1 to N, where N is the number of online nodes.\nThis value is available in the ResSpsView view as AwtUsedAvg.\nIODelay\nNumber of I/Os that are delayed. This ﬁeld is result of:\nProcBlksFsgRead + ProcBlksFsgWrite + ProcBlksFsgNIOs\nIODelayTime\nTotal time the I/O is delayed for. This ﬁeld is the result of:\nProcWaitFsgRead + ProcWaitFsgWrite + ProcWaitFsgNIOs\nPhysicalRead\nNumber of physical reads performed for this period. This ﬁeld is the result of:\nFilePDbAcqReads + FilePDbPreReads + FilePCiAcqReads + FileSDbAcqReads + FileSCiAcqReads + FileTJtAcqReads + FileAPtAcqReads + FilePCiPreReads +\nFileSDbPreReads + FileSCiPreReads + FileTJtPreReads + FileAPtPreReads\nPhysicalReadKB\nNumber of physical reads in KB performed for this period. This ﬁeld is result of:\nFilePDbAcqReadKB + FilePDbPreReadKB + FilePCiAcqReadKB + FileSDbAcqReadKB + FileSCiAcqReadKB + FileTJtAcqReadKB + FileAPtAcqReadKB + FilePCiPreReadKB\n+ FileSDbPreReadKB + FileSCiPreReadKB + FileTJtPreReadKB + FileAPtPreReadKB\nPhysicalWrite\nNumber of physical writes performed for this period. This ﬁeld is result of:\nFilePDbFWrites + FilePCiFWrites + FileSDbFWrites + FileSCiFWrites + FileTJtFWrites + FileAPtFWrites\nPhysicalWriteKB\nNumber of physical writers in KB performed for this period. This ﬁeld is result of:\nFilePDbFWriteKB + FilePCiFWriteKB + FileSDbFWriteKB + FileSCiFWriteKB + FileTJtFWriteKB + FileAPtFWriteKB\nLogicalRead\nNumber of logical reads performed for this period. This ﬁeld is result of:\nFilePDbAcqs + FilePDbPres + FilePCiAcqs + FileSDbAcqs + FileSCiAcqs + FileTJtAcqs + FileAPtAcqs + FilePCiPres + FileSDbPres + FileSCiPres + FileTJtPres + FileAPtPres\nLake - Monitor Resources and Performance\nPage 252 of 420LogicalReadKB\nNumber of logical reads in KB performed for this period. This ﬁeld is result of:\nFilePDbAcqKB + FilePDbPresKB + FilePCiAcqKB + FileSDbAcqKB + FileSCiAcqKB + FileTJtAcqKB + FileAPtAcqKB + FilePCiPresKB + FileSDbPresKB + FileSCiPresKB +\nFileTJtPresKB + FileAPtPresKB\nLogicalWrite\nNumber of logical writes performed for this period. This ﬁeld is result of:\nFilePDbDyRRels + FilePCiDyRRels + FileSDbDyRRels + FileSCiDyRRels + FileTJtDyRRels + FileAPtDyRRels\nLogicalWriteKB\nNumber of logical writes in KB performed for this period. This ﬁeld is result of:\nFilePDbDyRRelKB + FilePCiDyRRelKB + FileSDbDyRRelKB + FileSCiDyRRelKB + FileTJtDyRRelKB + FileAPtDyRRelKB\nExtraField1\nExtraField2\nExtraField3\nExtraField4\nThis ﬁeld is not used.\nVPId\nVirtual partition ID.\nWaitIO\nNumber of milliseconds tasks in WD waited for I/O over the reporting period.\nWaitIO is updated when the wait for I/O is completed.\nWaitOther\nNumber of milliseconds tasks in WD waited for reasons other than I/O over the reporting period (for example, a task waiting for a message).\nWaitOther is updated when wait is completed.\nCPURunDelay\nNumber of milliseconds tasks in the WD sat in the CPU runqueue waiting to run over the reporting period.\nThis data can be used in determining demand for the virtual partition and Workload Share Percent. The Workload Share Percent* is a workload management method. If the CPU\nand I/O percentages for a virtual partition or WD are below their relative share values and the CPURunDelay values are low, there was insufﬁcient demand to meet the share\npercentage. If the CPURunDelay values are high, higher tier SQL requests were allocated more resources so that there were insufﬁcient resources remaining to allocate to SQL\nrequests in this WD to meet its relative share.\nA virtual partition divides a system so that a percentage of resources are allocated to a collection of workloads. A virtual partition can consist of WDs from all management\nmethods.\nIOSubmitted\nNumber of I/Os submitted on behalf of this WD.\nIOSubmittedKB\nKB of I/O submitted on behalf of this WD.\nIOCompleted\nNumber of AgeOut Now data blocks not to keep in memory (fsgcache) and to be written to disk.\nIOCompletedKB\nKB of AgeOut Now data blocks not to keep in memory (fsgcache) and to be written to disk.\nIOCriticalSubmitted\nNumber of I/Os submitted with critical status. These I/Os run at top priority instead of being based on the I/O priority of the SQL request.\nIOCriticalSubmittedKB\nKB of I/O submitted with critical status. These I/Os run at top priority instead of being based on the I/O priority of the SQL request.\nDecayLevel1IO\nNumber of times SQL requests in the WD reached decay level 1 due to I/O.\nDecayLevel1IO is used for Timeshare WDs** only.\nDecayLevel2IO\nNumber of times SQL requests in the WD reached decay level 2 due to I/O.\nDecayLevel1IO is used for Timeshare WDs** only.\nDecayLevel1CPU\nNumber of times SQL requests in the WD reached decay level 1 due to CPU.\nDecayLevel1IO is used for Timeshare WDs** only.\nDecayLevel2CPU\nNumber of times SQL requests in the WD reached decay level 2 due to CPU.\nDecayLevel1IO is used for Timeshare WDs** only.\nTacticalExceptionIO\nNumber of times SQL requests in the WD reached a tactical per-node exception due to I/O.\nAn exception, used only for Tactical WDs, is created for each Tactical WD***.\nTacticalExceptionCPU\nNumber of times SQL requests in the WD reached a tactical per-node exception due to CPU.\nTacticalExceptionCPU is used for Tactical WDs*** only.\n* The Workload Share Percent Management Method workload is assigned a proportion of the resources that are available after allocations have been made for tactical workloads. The\npercentage of resources is divided equally between all requests running in the WD. For example, if the Workload Share Percent is 5% and there are ﬁve SQL requests, each SQL\nrequest gets 1% of the share resources.\n** The Timeshare Workload Management Method workload can be assigned to one of four stepped access levels, Top, High, Medium, or Low. The higher access levels are given\nlarger access rates than the lower levels. For example, an SQL request assigned to a Timeshare WD with a Top access level, which has an access rate of 8, gets eight times the\namount of resources than an SQL request assigned to a Low access level.\nTimeshare workloads are assigned resources remaining after all allocations have been made for tactical and Workload Share Percent workloads.\nLake - Monitor Resources and Performance\nPage 253 of 420*** The Tactical Workload Management Method workload yields the fastest available response time and runs at the highest tier, preempting all resource needs of other tiers. This\nmethod is well suited for critical, short-running queries that require fast response times.\nMonitorWD Usage Notes\nThe MonitorWD function provides similar functionality to the PMPC MONITOR WD request. For information about this interface, see MONITOR WD.\nFor information on the resource usage tables and columns described in the following ﬁeld calculations, see Monitor Resource Usage.\nMonitorWD Example\nSELECT * FROM TABLE (MonitorWd()) AS t2 where vpid=102 and vprtype='amp';\n *** Query completed. One row found. 43 columns returned.\n *** Total elapsed time was 1 second.\n                 WDId            0\n                 PPId       0\n                 PGId     254\n                 AGId       0\n               RelWgt       0\n             NumProcs          454\n              VprType  AMP\n            QWaitTime   0.00000000000000E 000\n         QWaitTimeMax   0.00000000000000E 000\n           CpuUserPct   0.00000000000000E 000\n      WorkMsgMaxDelay   0.00000000000000E 000\n     WorkTypeInUseMax            0\n     WorkTimeInUseAvg   0.00000000000000E 000\n              IODelay   1.60000000000000E 001\n          IODelayTime   1.19968000000000E 005\n         PhysicalRead   0.00000000000000E 000\n       PhysicalReadKB   0.00000000000000E 000\n        PhysicalWrite   1.60000000000000E 001\n      PhysicalWriteKB   6.56000000000000E 002\n          LogicalRead   8.00000000000000E 000\n        LogicalReadKB   2.56000000000000E 002\n         LogicalWrite   8.00000000000000E 000\n       LogicalWriteKB   2.56000000000000E 002\n          ExtraField1   0.00000000000000E 000\n          ExtraField2   0.00000000000000E 000\n          ExtraField3   0.00000000000000E 000\n          ExtraField4   0.00000000000000E 000\n                 VPId     102\n               WaitIO   5.80000000000000E 001\n            WaitOther   7.78500000000000E 005\n          CPURunDelay   2.98000000000000E 002\n          IOSubmitted   1.60000000000000E 001\n        IOSubmittedKB   1.48000000000000E 002\n          IOCompleted   1.60000000000000E 001\n        IOCompletedKB   1.48000000000000E 002\n  IOCriticalSubmitted   0.00000000000000E 000\nIOCriticalSubmittedKB   0.00000000000000E 000\n        DecayLevel1IO   0.00000000000000E 000\n        DecayLevel2IO   0.00000000000000E 000\n       DecayLevel1CPU   0.00000000000000E 000\n       DecayLevel2CPU   0.00000000000000E 000\n  TacticalExceptionIO   0.00000000000000E 000\n TacticalExceptionCPU   0.00000000000000E 000\nMonitorWDRate\nReturns the collection rate, number of nodes with at least one online AMP, and number of nodes with at least one online PE.\nMonitorWDRate Syntax\nMonitorWDRate Example\nMonitorWDRate Syntax\nREPLACE FUNCTION SYSLIB.MonitorWDRate (\n) RETURNS TABLE (\n    SampleRate SMALLINT,\n    AMPNodes SMALLINT,\n    PENodes SMALLINT\n  )\nLake - Monitor Resources and Performance\nPage 254 of 420  ...\n;\nSyntax Elements\nSampleRate\nNumber of seconds of the collection period.\nAMPNodes\nNumber of nodes with at least one online AMP.\nPENodes\nNumber of nodes with at least one online PE.\nMonitorWDRate Example\nSELECT * FROM TABLE (MonitorWDRate()) AS t2;\n *** Query completed. One row found. 3 columns returned.\n *** Total elapsed time was 1 second.\nSampleRate     600  AMPNodes       1  PENodes       1\nSetResourceRate\nSets either the ResMonitor or ResLogging rate.\nThis function returns the previous collection rate value in seconds.\nSetResourceRate Syntax\nSetResourceRate Usage Notes\nSetResourceRate Example\nSetResourceRate Syntax\nREPLACE FUNCTION SYSLIB.SetResourceRate (\n  SampleRate  INTEGER,\n  LogChange  VARCHAR(1),\n  VprocChange  VARCHAR(1)\n) RETURNS INTEGER\n  ...\n;\nSyntax Elements\nSampleRate\nValue of the collection rate. This ﬁeld is used either to collect resource data or to log resource data to the resource usage tables.\nYou can specify one of the following:\nThe ResMonitor rate value if you want to change the resource monitoring rate.\nThe ResLogging rate value if you want to change the resource logging rate.\nThe value must be an integral divisor of 3600.\nZero to turn off the resource collection or logging.\nLogChange\nIndicator of whether this rate applies to the ResLogging or ResMonitor rate:\nY or y = ResLogging rate\nN, n, NULL, or blank = ResMonitor rate\nVprocChange\nThis ﬁeld is deprecated.\nSetResourceRate Usage Notes\nThe SetResourceRate function provides similar functionality to the PMPC SET RESOURCE RATE request. For information about this interface and the ResMonitor and ResLogging rates,\nsee SET RESOURCE RATE.\nSetResourceRate Example\nThis example uses SetResourceRate to set the ResMonitor rate.\nSELECT SetResourceRate(60, 'N', 'N');\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 5 seconds.\nSetResourceRate(60,'N','N')\n---------------------------\n                        600 \nSetSessionAccount\nLake - Monitor Resources and Performance\nPage 255 of 420Changes the account string for the session or for the request.\nThis function returns the old account string.\nSetSessionAccount Syntax\nSetSessionAccount Usage Notes\nSetSessionAccount Example\nSetSessionAccount Syntax\nREPLACE FUNCTION SetSessionAccount (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  NewAcctString  TD_ANYTYPE,\n  EntireSession  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS VARCHAR(128) CHARACTER SET UNICODE\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nSessionNoIn\nNumber of the speciﬁed session.\nNewAcctString\nAccount string for the session or request.\nEntireSession\nIndicator of how the new account or priority affects requests for a speciﬁed session.\nIf you specify Y or y, the change applies to all current and future requests for a speciﬁed session. If no requests or steps are running, the new account or priority takes effect at\nthe next request, and the DBC.SessionTbl table reﬂects the new account or priority for the current session.\nIf you specify NULL, blank, N, or n, the change applies only to the current request for the speciﬁed session. If no request is running, the next request for the speciﬁed session\nhas the old account/priority.\nSetSessionAccount Usage Notes\nThe SetSessionAccount function provides similar functionality to the PMPC SET SESSION ACCOUNT request. For information about this interface, see SET SESSION ACCOUNT.\nSetSessionAccount Example\nUsing SetSessionAccount with MonitorSession\nBTEQ -- Enter your DBC/SQL request or BTEQ command:\nSELECT SetSessionAccount(Hostid, sessionno, 'Accountx','Y')\nFROM TABLE (MonitorSession(1,'twmuser3',0)) AS t1;\nSELECT SetSessionAccount(Hostid, sessionno, 'Accountx','Y')\nFROM TABLE (MonitorSession(1,'twmuser3',0)) AS t1;\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nSetSessionAccount(HostId,SessionNo,'Accountx','Y')\n--------------------------------------------------\nACCOUNT3 \nUsing SetSessionAccount\nBTEQ -- Enter your DBC/SQL request or BTEQ command:\nSELECT SetSessionAccount(1, 4461, 'Account3','y');\nSELECT SetSessionAccount(1, 4461, 'Account3','y');\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nSetSessionAccount(1,4461,'Account3','y')\n----------------------------------------\nACCOUNTX\nSetSessionRate\nSets the global rates for updating session-level statistics in memory.\nThis function returns the previous collection rate value in seconds.\nSetSessionRate Syntax\nSetSessionRate Usage Notes\nSetSessionRate Example\nLake - Monitor Resources and Performance\nPage 256 of 420SetSessionRate Syntax\nREPLACE FUNCTION SetSessionRate (\n  SampleRate  INTEGER\n) RETURNS INTEGER\n  ...\n;\nSyntax Elements\nSampleRate\nSets the global rate. The value ranges from 1 to 3600 seconds. If the rate is set to zero, an error is reported.\nThe collection rate applies to global queries.\nSetSessionRate Usage Notes\nThere is no option equivalent to the PMPC SET SESSION RATE request Local_Change = Y option, because when using the SetSessionRate function, there is no local MONITOR\nPARTITION in which to apply the rate to.\nYou can set the SetSessionRate function to a global (SesMonitorSys) rate. That is, a collection rate at which session-level statistics are collected in memory. This rate is returned in the\nSesMonitorSys data value by the MonitorVirtualSummary function.\nThe SetSessionRate function provides similar functionality to the PMPC SET SESSION RATE request. For information about this interface, see SET SESSION RATE.\nSetSessionRate Example\nSELECT SetSessionRate(600);\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nSetSessionRate(600)\n-----------------------\n                     60\nWorkload Management: Single Operational View APIs\nSingle Operational View APIs support two modes, an aggregate view that combines the numbers across the operational groups (primary clusters and compute clusters) and a detailed\nview that provides additional columns to identify the group.\nMonitorAMPLoadSV\nMonitorPhysicalConﬁgSV\nMonitorPhysicalResourceSV\nMonitorSessionSV\nMonitorSQLCurrentStepSV\nMonitorSQLStepsSV\nMonitorSQLTextSV\nMonitorAMPLoadSV\nThis single operational view API aggregates AMP load data across VantageCloud Lake clusters.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorAMPLoadSV (\n) RETURNS TABLE (\n    VprocNo SMALLINT,\n    AvailableAWTs INTEGER,\n    InUseAWTs INTEGER,\n    MsgCount INTEGER,\n    DQMsgCount INTEGER\n    AvailableAWTsForAll INTEGER,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\n    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nVprocNo\nAMP vproc number.\nThis value is incremented by 10000 for each compute cluster for the single view. For example, the ﬁrst AMP of the primary cluster starts at 1, the ﬁrst AMP of the ﬁrst online\ncompute cluster starts at 10001, and the ﬁrst AMP of the second online compute cluster starts with 20001, and so on.\nLake - Monitor Resources and Performance\nPage 257 of 420AvailableAWTs\nNumber of AMP worker tasks in each AMP available to support new work.\nInUseAWTs\nNumber of active AMP worker tasks in each AMP.\nMsgCount\nNumber of messages queued for delivery to each AMP.\nDQMsgCount\nNumber of messages processed by each AMP.\nAvailableAWTsForAll\nThe number of available AMP worker tasks in the unreserved pool in each AMP.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nExamples: Using MonitorAMPLoadSV\nExample: Using MonitorAMPLoadSV with Default Query\nSELECT * from MonitorAMPLoadSV() AS dt;\nThe output is similar to this. The output shown is abbreviated.\n            VprocNo       0\n      AvailableAWTs           48\n          InUseAWTs            3\n           MsgCount            0\n         DQMsgCount        26745\nAvailableAWTsForAll           55\n            VprocNo       1\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount        27138\nAvailableAWTsForAll           56\n            VprocNo       2\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount        25527\nAvailableAWTsForAll           56\n            VprocNo       3\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount        25948\nAvailableAWTsForAll           56\n            VprocNo       4\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount        26847\nAvailableAWTsForAll           56\n            VprocNo       5\n      AvailableAWTs           49\n          InUseAWTs            1\n           MsgCount            0\n         DQMsgCount        27019\n.\n.\n.\n            VprocNo   10023\n      AvailableAWTs           50\n          InUseAWTs            0\n           MsgCount            0\nLake - Monitor Resources and Performance\nPage 258 of 420         DQMsgCount        12363\nAvailableAWTsForAll           56\nExample: Using MonitorAMPLoadSV with Detailed V iew Query\nThe detailed view adds the Type, Id, Name, and Group columns to identify the source of these metrics.\nSELECT * from MonitorAMPLoadSV(\n    USING\n    details('1')\n) \nAS dt;\nThe output is similar to this. The output shown here is abbreviated.\n            VprocNo      0\n      AvailableAWTs          48\n          InUseAWTs           3\n           MsgCount           0\n         DQMsgCount       26745\nAvailableAWTsForAll          55\n               Type primary cluster\n                 Id pog-784f2c715b\n               Name 1\n              Group ?\n            VprocNo      1\n      AvailableAWTs          49\n          InUseAWTs           1\n           MsgCount           0\n         DQMsgCount       27138\nAvailableAWTsForAll          56\n               Type primary cluster\n                 Id pog-784f2c715b\n               Name 1\n              Group ?\n            VprocNo      2\n      AvailableAWTs          49\n          InUseAWTs           1\n           MsgCount           0\n         DQMsgCount       25527\nAvailableAWTsForAll          56\n               Type primary cluster\n                 Id pog-784f2c715b\n               Name 1\n              Group ?\n            VprocNo      3\n      AvailableAWTs          49\n          InUseAWTs           1\n           MsgCount           0\n         DQMsgCount       25948\nAvailableAWTsForAll          56\n               Type primary cluster\n                 Id pog-784f2c715b\n               Name 1\n              Group ?\n            VprocNo      4\n      AvailableAWTs          49\n          InUseAWTs           1\n           MsgCount           0\n         DQMsgCount       26847\nAvailableAWTsForAll          56\n               Type primary cluster\n                 Id pog-784f2c715b\n               Name 1\n              Group ?\n            VprocNo      5\n      AvailableAWTs          49\n          InUseAWTs           1\n           MsgCount           0\n         DQMsgCount       27019\nAvailableAWTsForAll          56\n               Type primary cluster\n                 Id pog-784f2c715b\nLake - Monitor Resources and Performance\nPage 259 of 420               Name 1\n              Group ?\n.\n.\n.\n            VprocNo  10023\n      AvailableAWTs          50\n          InUseAWTs           0\n           MsgCount           0\n         DQMsgCount       12446\nAvailableAWTsForAll          56\n               Type compute cluster\n                 Id sys-784f2c8afd_pog_784f2c715b_group_1_cog_1_setwlc\n              Name 1-setwlc\n              Group pog_784f2c715b_group_1\nMonitorPhysicalConfigSV\nThis single operational view API aggregates node availability data across VantageCloud Lake clusters.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorPhysicalConfigSV (\n) RETURNS TABLE (\n    ProcId INTEGER,\n    Status CHAR CHARACTER SET LATIN,\n    CPUType VARCHAR(7) CHARACTER SET LATIN,\n    CPUCount SMALLINT,\n    SystemType VARCHAR(7) CHARACTER SET LATIN,\n    CliqueNo SMALLINT,\n    NetAUp CHAR(1) CHARACTER SET LATIN,\n    NetBUp CHAR(1) CHARACTER SET LATIN,\n    PhyMemory INTEGER,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\n    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nProcId\nID associated with a node.\nThis value is incremented by 10000 for each group for the single view. The ﬁrst node of the primary cluster starts at 10001, the ﬁrst node of the ﬁrst online compute cluster starts\nat 20001, and the ﬁrst node of the second online compute cluster starts with 30001, and so on.\nStatus\nStatus of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nS = Standby\nA node is up (U) when the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nStandby (S) indicates the node is ready to join the conﬁguration in place if another node goes down. When the node status is Standby, the SystemType, NetAUp, and NetBUp\nﬁelds are not available and NULL or spaces are returned.\nCPUType\nType of CPU installed in this node, for example: 'Pentium', 'PentPro', or 'Unknown'.\nCPUCount\nNumber of CPUs in this node.\nSystemType\nType of system running the database software, such as 5650, 6700, or 'Other'.\nIf all the nodes in the system are the same type, this ﬁeld returns the type of the system.\nIf any of the nodes are of a different type, this ﬁeld returns 'Mixed'.\nCliqueNo\nClique number of the node.\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nLake - Monitor Resources and Performance\nPage 260 of 420U = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nPhyMemory\nSize of the physical memory of the node in MBs.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nExamples: Using MonitorPhysicalConﬁgSV\nExample: Using MonitorPhysicalConﬁgSV with Default Query\nSELECT * from MonitorPhysicalConfigSV() AS dt;\nThe output is similar to this.\n    ProcId        10001\n    Status  U\n   CPUType  Xeon\n  CPUCount      16\nSystemType  6700V\n  CliqueNo       0\n    NetAUp\n    NetBUp\nPhyMemory        63141\n    ProcId        20001\n    Status  U\n   CPUType  Xeon\n  CPUCount      48\nSystemType  6700V\n  CliqueNo       0\n    NetAUp\n    NetBUp\nPhyMemory       190818\nExample: Using MonitorPhysicalConﬁgSV with Detailed V iew Query\nThe detailed view adds the Type, Id, Name, and Group columns to identify the source of these metrics.\nSELECT * from MonitorPhysicalConfigSV(\n    USING\n    details('1')\n) \nAS dt;\nThe output is similar to this.\n    ProcId       10001\n    Status U\n   CPUType Xeon\n  CPUCount     16\nSystemType 6700V\n  CliqueNo      0\n    NetAUp\n    NetBUp\nPhyMemory       63141\n      Type primary cluster\n        Id pog-784f2c715b\n      Name 1\n     Group ?\n    ProcId       20001\n    Status U\n   CPUType Xeon\n  CPUCount     48\nSystemType 6700V\n  CliqueNo      0\n    NetAUp\nLake - Monitor Resources and Performance\nPage 261 of 420    NetBUp\nPhyMemory      190818\n      Type compute cluster\n        Id sys-784f2c8afd_pog_784f2c715b_group_1_cog_1_setwlc\n      Name 1-setwlc\n     Group pog_784f2c715b_group_1\nMonitorPhysicalResourceSV\nThis single operational view API aggregates node-speciﬁc RSS data across VantageCloud Lake clusters.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorPhysicalResourceSV (\n) RETURNS TABLE (\n    ProcId INTEGER,\n    Status CHAR CHARACTER SET LATIN,\n    AmpCount SMALLINT,\n    PECount SMALLINT,\n    CPUUse FLOAT,\n    PrcntKernel FLOAT,\n    PrcntService FLOAT,\n    PrcntUser FLOAT,\n    DiskUse FLOAT,\n    DiskReads FLOAT,\n    DiskWrites FLOAT,\n    DiskOutReqAvg FLOAT,\n    NetAUse FLOAT,\n    NetReads FLOAT,\n    NetWrites FLOAT,\n    HstBlkRd FLOAT,\n    HstBlkWrts FLOAT,\n    MemAllocates FLOAT,\n    MemAllocateKB FLOAT,\n    MemFailures FLOAT,\n    MemAgings FLOAT,\n    NetAUp CHAR(1) CHARACTER SET LATIN,\n    NetBUp CHAR(1) CHARACTER SET LATIN,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\n    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nProcId\nID associated with a node.\nThis value is incremented by 10000 for each group for the single view. For example, the ﬁrst node of the primary cluster starts at 10001, the ﬁrst node of the ﬁrst online compute\ncluster starts at 20001, and the ﬁrst node of the second online compute cluster starts with 30001, and so on.\nStatus\nStatus of the node associated with this record:\nU = Up/online\nD = Down/ofﬂine\nA node is up (U) when the following are true:\nThe node is conﬁgured into the system.\nThe node is online.\nThe node can perform tasks associated with normal database activity.\nDown (D) represents all other potential states.\nAmpCount\nNumber of AMPs executing on the associated node.\nPECount\nNumber of active PEs on the associated node.\nCPUUse\n% of CPU usage not spent being idle. The node-level display is computed from ResUsageSpma table data as PercntUser + PercntService. For information on ResUsageSpma\ntable, see resusagespmaV.\nThis value is NULL if certain conditions apply.\nPrcntKernel\n% of CPU resources in idle and waiting for I/O completion. This value is computed from ResUsageSpma data as follows, where NCPUs is the number of CPUs:\n((CPUIOWAIT/100) / (NCPUs * SampleSec)) * 100\nLake - Monitor Resources and Performance\nPage 262 of 420This value is NULL if certain conditions apply.\nFor information on ResUsageSpma table, see resusagespmaV.\nPrcntService\n% of CPU resources spent in PDE user service processing. The value is computed from the ResUsageSpma table data, where x represents the number of CPUs:\nCPUUServ / (x * SampleSec)\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma table, see resusagespmaV.\nPrcntUser\n% of CPU resources spent in non-service user code processing. This value is computed from the ResUsageSpma table data, where x represents the number of CPUs:\nCPUUExec / (x * SampleSec)\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma, see resusagespmaV.\nDiskUse\n% of disk usage per node.\nThis value is computed from ResUsageSldv table data as follows, assuming n is the number of vdisks used by this AMP:\n(LdvOutReqTime 1 + ... + LdvOutReqTime n) / (n*SampleSec)\nThe DiskUse ﬁeld does not consider the overlapping of operations among multiple storage devices, but does allow for the possibility of multiple requests for the same device.\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSldv, see resusagesldvV.\nDiskReads\nTotal number of physical disk reads per node during the collection period. This value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv\ndevices used by this node:\nLdvReads 1 + ... + LdvReads n\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSldv, see resusagesldvV.\nDiskWrites\nTotal number of physical disk writes per node during the collection period. This value is computed from ResUsageSldv table data as:\nLdvWrites 1 + ... + LdvWrites n\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSldv, see resusagesldvV.\nDiskOutReqAvg\nAverage number of outstanding disk requests.\nThe value is computed from ResUsageSldv table data as follows, assuming n is the number of ldv controllers used by this node:\n((LdvOutReqSum 1 / NULLIFZERO(LdvOutReqDiv 1)) + … + (LdvOutReqSum n / NULLIFZERO(LdvOutReqDiv n))) / n\nThe range of the value is typically 0 to 25.\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSldv, see resusagesldvV.\nNetAUse\n% of BYNET A usage (actual BYNET receiver usage). (The BYNET transmitter usage is maintained in resource usage separately and is typically lower than the receiver usage.\nThis is caused by multicasts, where one transmitter sends a message to multiple receivers.) This value is computed from the ResUsageSpma table data as:\n((NetSamples - NetTxIdle) / NetSamples) * 100\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma, see resusagespmaV.\nNetReads\nNumber of Reads from the BYNET to the node. This value is computed from the ResUsageSpma table data as:\nNetRxCircBrd + NetRxCircPtP\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma, see resusagespmaV.\nNetWrites\nNumber of messages written from the node to the BYNET during the collection period.\nThe value is computed from the ResUsageSpma table data as NetTxCircBrd + NetTxCircPtP.\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma, see resusagespmaV.\nHstBlkRds\nNumber of message blocks (one or more messages sent in one physical group) received from all clients.\nThis value is computed from ResUsageShst data, assuming n is the number of host channel and network connections on this node:\nHostBlockReads 1 + ... + HostBlockReads n\nThis value is NULL if certain conditions apply.\nFor information on ResUsageShst, see resusageshstV.\nHstBlkWrts\nNumber of message blocks (that is, one or more messages sent in one physical group) sent to all hosts.\nThis value is computed from ResUsageShst data, assuming n is the number of host channel and network connections on this node:\nHostBlockWrites 1 + ... + HostBlockWrites n\nThis value is NULL if certain conditions apply.\nFor information on ResUsageShst, see resusageshstV.\nMemAllocates\nThis column is deprecated and returns zero or NULL.\nMemAllocateKB\nValue represents the change in node-level memory. MemAllocateKB represents a delta from the previous reporting period, reporting negative values as less memory is used.\nThis value is calculated from the ResUsageSpma column MemVprAllocKB.\nThis value is NULL if certain conditions apply.\nFor information on ResUsageSpma, see resusagespmaV.\nLake - Monitor Resources and Performance\nPage 263 of 420MemFailures\nThis column is deprecated and returns zero or NULL.\nMemAgings\nThis column is deprecated and returns zero or NULL.\nNetAUp\nNetBUp\nStatus of the BYNETs (if there are more than two, the ﬁrst two) on a system-wide basis:\nU = All node BYNETs are up/online.\nD = One or more node BYNETs is down/ofﬂine.\n\"\" = A temporary condition where the BYNET data is not available.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Identiﬁes the id of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nUsage Notes\nMonitorPhysicalResourceSV returns the detailed resource usage information for each node. Because the function reports on each node, you can isolate performance concerns by\nnode.\nExamples: Using MonitorPhysicalResourceSV\nExample: T racking Resource Usage While a Query is Running\nSELECT ProcId, CPUUse, Id, \"Type\" from SYSLIB.MonitorPhysicalResourceSV(\n    USING\n    details('1')\n) \nAS dt;\nThe output for a single compute system is similar to this:\n|ProcId|CPUUse      |Id                                                 |Type           |\n|------|------------|---------------------------------------------------|---------------|\n|10,001|0.3871875   |pog-64ccdd083c                                     |primary cluster|\n|20,001|0.1932591218|sys-64ccddbd6c_computegroup1_computeprofile1_tv5cug|compute cluster|\nExample: Displaying Basic Conﬁguration Details\nThis query displays basic conﬁguration details for each compute cluster in a system.\nSELECT \"TYPE\"               AS COMPONENT_TYPE\n      ,ID                   AS COMPONENT_ID\n      ,COUNT(*)             AS NODE_CNT\n      ,SUM(AMPCOUNT)        AS AMP_CNT\n      ,SUM(PECOUNT)         AS PE_CNT\n  FROM MonitorPhysicalResourceSV(\n       USING DETAILS('1')\n       ) AS DT\nGROUP BY 1,2\nORDER BY 1,2\n; \nIdentifying the Status of All Nodes by Compute Cluster\nThis query identiﬁes the status of all nodes by compute cluster and reports on the current status (online, ofﬂine) of the nodes in each compute cluster.\nSELECT \"TYPE\"               AS COMPONENT_TYPE\n      ,ID                   AS COMPONENT_ID\n      ,SUM(CASE WHEN STATUS = 'U' THEN 1 ELSE 0 END) AS NODES_ONLINE\n      ,SUM(CASE WHEN STATUS = 'D' THEN 1 ELSE 0 END) AS NODES_OFFLINE\n  FROM MonitorPhysicalResourceSV(\nUSING DETAILS('1')\n       ) AS DT\nGROUP BY 1,2\nORDER BY 1,2;\nLake - Monitor Resources and Performance\nPage 264 of 420MonitorSessionSV\nThis single operational view API can return session information across VantageCloud Lake clusters. The API can also be used to trace query sessions to a compute node.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorSessionSV (\n  HostIdIn  SMALLINT,\n  UserNameIn  TD_ANYTYPE,\n  SessionNoIn  INTEGER\n ) RETURNS TABLE (\n     HostId SMALLINT,\n     SessionNo INTEGER,\n     LogonPENo SMALLINT,\n     RunVprocNo SMALLINT,\n     PartName VARCHAR(16) CHARACTER SET LATIN,\n     PEstate VARCHAR(18) CHARACTER SET LATIN,\n     LogonTime VARCHAR(22) CHARACTER SET LATIN,\n     UserId INTEGER,\n     LSN INTEGER,\n     UserName VARCHAR(128) CHARACTER SET UNICODE, \n     UserAccount VARCHAR(128) CHARACTER SET UNICODE, \n     PECPUsec FLOAT,\n     XActCount FLOAT,\n     ReqCount FLOAT,\n     ReqCacheHits FLOAT,\n     AMPState VARCHAR(18) CHARACTER SET LATIN,\n     AMPCPUSec FLOAT,\n     AMPIO FLOAT,\n     ReqSpool FLOAT, \n     Blk1HostId SMALLINT,\n     Blk1SessNo INTEGER,\n     Blk1UserId INTEGER,\n     Blk1Lmode CHAR(1) CHARACTER SET LATIN,\n     Blk1Otype CHAR(2) CHARACTER SET LATIN,\n     Blk1ObjDBID INTEGER,\n     Blk1ObjTID INTEGER,\n     Blk1Status CHAR(1) CHARACTER SET LATIN,\n     Blk2HostId SMALLINT,\n     Blk2SessNo INTEGER,\n     Blk2UserId INTEGER,\n     Blk2Lmode CHAR(1) CHARACTER SET LATIN,\n     Blk2Otype CHAR(2) CHARACTER SET LATIN,\n     Blk2ObjDBID INTEGER,\n     Blk2ObjTID INTEGER,\n     Blk2Status CHAR(1) CHARACTER SET LATIN,\n     Blk3HostId SMALLINT,\n     Blk3SessNo INTEGER,\n     Blk3UserId INTEGER,\n     Blk3Lmode CHAR(1) CHARACTER SET LATIN,\n     Blk3Otype CHAR(2) CHARACTER SET LATIN,\n     Blk3ObjDBID INTEGER,\n     Blk3ObjTID INTEGER,\n     Blk3Status CHAR(1) CHARACTER SET LATIN,\n     MoreBlockers CHAR(1) CHARACTER SET LATIN,\n     LogonSource VARCHAR(128),\n     HotAmp1CPU FLOAT,\n     HotAmp2CPU FLOAT,\n     HotAmp3CPU FLOAT,\n     HotAmp1CPUId FLOAT,\n     HotAmp2CPUId FLOAT,\n     HotAmp3CPUId FLOAT,\n     HotAmp1IO FLOAT,\n     HotAmp2IO FLOAT,\n     HotAmp3IO FLOAT,\n     HotAmp1IOId INTEGER,\n     HotAmp2IOId INTEGER,\n     HotAmp3IOId INTEGER,\n     LowAmp1CPU FLOAT,\n     LowAmp2CPU FLOAT,\n     LowAmp3CPU FLOAT,\n     LowAmp1CPUId INTEGER,\nLake - Monitor Resources and Performance\nPage 265 of 420     LowAmp2CPUId INTEGER,\n     LowAmp3CPUId INTEGER,\n     LowAmp1IO FLOAT,\n     LowAmp2IO FLOAT,\n     LowAmp3IO FLOAT,\n     LowAmp1IOId INTEGER,\n     LowAmp2IOId INTEGER,\n     LowAmp3IOId INTEGER,\n     AvgAmpCPUSec FLOAT,\n     AvgAmpIOCnt FLOAT,\n     AmpCount SMALLINT,\n     TempSpaceUsg FLOAT,\n     ReqStartTime VARCHAR(22) CHARACTER SET LATIN,\n     ReqCPU FLOAT,\n     ReqIO FLOAT,\n     ReqNo INTEGER,\n     WlcId INTEGER,\n     DontReclassifyFlag SMALLINT,\n     ProxyUser VARCHAR (128)CHARACTER SET UNICODE,\n     CPUDecayLevel SMALLINT,\n     IODecayLevel SMALLINT,\n     TacticalCPUException INTEGER,\n     TacticalIOException INTEGER,\n     ReqIOKB FLOAT,\n     ReqPhysIO FLOAT\n     ReqPhysIOKB FLOAT\n     ReqStepsCompletedCnt INTEGER,\n     RedriveProtection CHAR (2) CHARACTER SET LATIN,\n     CurrentRedriveParticipation CHAR (1) CHARACTER SET LATIN,\n     ReqRedriveSpoolSpace FLOAT,\n     BlockerSessionCnt SMALLINT,\n     ReqTblOpBytesIn FLOAT,\n     ReqTblOpBytesOut FLOAT,\n     ProxyUserId INTEGER,\n     ZoneId INTEGER,\n     ReqHotAmpCPU FLOAT,\n     ReqHotAmpCPUId SMALLINT,\n     ReqHotAmpIO FLOAT,\n     ReqHotAmpIOId SMALLINT,\n     ReqInvolvedAMPCnt SMALLINT,\n     ReqFirstRespTime VARCHAR(22) CHARACTER SET LATIN,\n     ReqLocalQueryStatus SMALLINT,\n     ReqRemoteHostId SMALLINT,\n     ReqRemoteSessionId INTEGER,\n     ReqRemoteRequestId INTEGER,\n     ReqRemoteQueryId FLOAT)\n     ReqHotAmpSpool FLOAT,           \n     ReqHotAmpSpoolId SMALLINT, \n     ReqMapNo SMALLINT, \n     ReqMaxNumMapAMPs INTEGER, \n     ReqMinNumMapAMPs INTEGER, \n     ReqSysDefNumMapAMPs INTEGER,\n     ReqRemoteHostIp VARCHAR(128) CHARACTER SET UNICODE,\n     ReqServerName VARCHAR(128) CHARACTER SET UNICODE,\n     ReqFlexReleased SMALLINT,\n     ReqAdmissionTime VARCHAR(22) CHARACTER SET LATIN,\n     ParentSessionNo INTEGER,\n     Type VARCHAR,\n     Id VARCHAR,\n     Name VARCHAR,\n     Group VARCHAR\n   )\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nA value of -1 indicates all hosts.\nUserNameIn\nLake - Monitor Resources and Performance\nPage 266 of 420User name of the session.\nAn asterisk (*) indicates all users.\nSessionNoIn\nNumber of the session.\nA value of zero indicates all sessions.\nHostId\nThis value is incremented by 10000 for each compute cluster for the single view. For example, the ﬁrst node of the primary cluster starts at 1, the ﬁrst node of the ﬁrst online\ncompute cluster starts at 10001, and the ﬁrst node of the second online compute cluster starts with 20001, and so on.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nLogonPENo\nVproc number of the PE the session is logged on to, which identiﬁes the PE that has control responsibility for the session. Typically, this is the PE that processed the logon\nrequest, but if that PE goes ofﬂine, this is the PE to which the session was switched.\nRunVprocNo\nVproc number of the AMP or PE assigned to process the session requests.\nFor sessions in Teradata SQL partitions, this value is identical to the LogonPENo. For sessions in FastLoad or MultiLoad partitions, this is the AMP that initially processes the\ndata being loaded.\nIf a RunVprocNo value of -1 in record mode or NULL in indicator mode is returned by MonitorSession for FastLoad, MultiLoad, or FastExport sessions, this indicates that the\nsession is in the process of starting up.\nPartName\nName of the session partition associated with this session. Following a successful logon request by a session or as part of a connect request, the session identiﬁes the partition\nwith which the user wants the session to be associated. FASTLOAD, Teradata SQL, MONITOR, INTERNAL are examples of valid partition names.\nPEstate\nCurrent state of the session within the PE. For a list of the PEState values, see MONITOR SESSION.\nLogonTime\nDate and time portion of the information recorded by Session Control when a session logs on, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the\nyear, month, day, hours: minutes: seconds.\nUserId\nUser or internal ID of a user for this session. Within the database, UserId is equivalent to Database ID. Typically, UserId is used when the associated record is known to be a\nuser name, and Database ID is used when the associated record is known to be a database. However, UserId can identify either a given user or database name.\nLSN\nLogon Sequence Number (LSN) that is associated with a session when the session logs on, which identiﬁes a collection of sessions performing a related activity. For example,\nin a FastLoad job, a user is logged on as a Teradata SQL session and n FastLoad sessions with the same user name. Therefore, n+1 sessions (1 Teradata SQL and n FastLoad)\nwith the same LSN are all associated with the given FastLoad job. To see how the FastLoad job is doing, the user can pick out all sessions reported with the same LSN number.\nThis information supplies the parent-child relationship for sessions involved with FastLoad and MultiLoad jobs.\nUserName\nUser name of the session.\nUserAccount\nCurrent account for the session.\nPECPUsec\nCPU time, in seconds, used in a PE by the associated session for parsing and dispatching requests. Accurate to the second.\nThis value is valid only when associated with Teradata SQL and MONITOR partition sessions.\nXActCount\nNumber of explicit and implicit transactions run by the session.\nThis value is valid only when returned for Teradata SQL sessions, and is NULL for all other partition sessions. For this value, you must make a request for data before completion\nof the ﬁrst collection period that follows either a system outage or a change in the ResMonitor rate.\nReqCount\nNumber of requests (Tequel Start Request (TSR) messages) initiated by the session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or change in the ResMonitor rate.\nReqCacheHits\nNumber of times that this session processed a request using information from the Teradata SQL Parser request cache, speciﬁcally, number of times there was a request cache\nhit.\nThis value is valid only for Teradata SQL sessions, and is NULL for all other partition sessions. This value is also NULL when a request for data is made before completion of the\nﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPState\nCurrent state of the associated session in AMP vprocs in decreasing priority:\nState Description\nABORTING Transaction being rolled back; session aborting.\nBLOCKED Background activity in progress; last request on hold until background activity is\ncompleted.\nACTIVE Normal, on-going activity.\nIDLE No work in progress on any AMP.\nUNKNOWN No recorded activity since monitoring began.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or\nSesMonitorSys rate.\nAMPCPUSec\nCurrent elapsed CPU time, in seconds, used on all AMPs by the associated session for executing requests. For example, for Teradata SQL requests, this is the time spent by\nthe database actively working or rolling back an aborted transaction. This does not include any PDE CPU time spent handling database requests.\nLake - Monitor Resources and Performance\nPage 267 of 420This value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nAMPIO\nCurrent number of logical Reads and Writes issued across all AMPs by the associated session.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nReqSpool\nCurrent spool used by current request across all AMPs, expressed in bytes.\nThis value is NULL when a request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the ResMonitor rate.\nBlk1HostId\nBlk2HostId\nBlk3HostId\nLogical host ID of a session causing a block. This value is derived from equating the transactions causing a database lock conﬂict to the sessions that issued those\ntransactions. The Blk_x_H ostId, in combination with Blk_x_S essNo , uniquely identiﬁes the session that is causing a block.\nThis value is NULL if:\nThe host ID is not available.\nThe session does not have an AMPState of BLOCKED.\nBlk1SessNo\nBlk2SessNo\nBlk3SessNo\nNumber of the session causing a block. This value is derived from associating the transactions causing a lock conﬂict to the sessions that issued those transactions. The\nBlk_x_S essNo in combination with Blk_x_H ostId uniquely identiﬁes the session causing a block.\nThis value is NULL if:\nSessNo is not available.\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1UserId\nBlk2UserId\nBlk3UserId\nID of the user or host utility job preventing the session from being granted a lock. The user ID is the only information available about who placed the lock.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1Lmode\nBlk2Lmode\nBlk3Lmode\nMode (severity) of the lock involved in causing a block:\nE = Exclusive\nW = Write\nR = Read\nA = Access\nLocks are reported in decreasing order of severity because removing the most severe lock conﬂict may eliminate the source of the lock conﬂict.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA session may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock in the queue and is in conﬂict with the lock requested by this blocked\nsession. For information on whether the lock is granted, see ﬁelds Blk1Status, Blk2Status, and Blk3Status.\nBlk1Otype\nBlk2Otype\nBlk3Otype\nType of object whose lock is causing the session described by the associated row to be blocked:\nD = Database\nT= Table\nR = Row hash\nTP = Table Partition range\nRP = RowHash in Partition range\nRK = RowHash in one partition\nRN = RowKey range\nHowever, this object is not necessarily the type of object the blocked session is trying to access. For example, if the session is requesting a row hash lock, the blocking object\nmay be a database, table, or row hash.\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nFor a Table T, User A can block User B with a table level lock on Table T on AMP_1 and with a Row Hash Level lock on that same Table T on AMP_2. When that occurs, the only\nlock conﬂict reported is that User B is blocked by User A on a table.\nBlk1ObjDBID\nBlk2ObjDBID\nBlk3ObjDBID\nUnique ID of the database object over which a lock conﬂict is preventing the session from being granted a lock.\nWithin the database system, Database ID is equivalent to User ID. Typically, User ID is used when the associated record is known to be a user name, and Database ID is used\nwhen the associated record is known to be a database. However, Database ID can identify either a user or database name.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLake - Monitor Resources and Performance\nPage 268 of 420Blk1ObjTID\nBlk2ObjTID\nBlk3ObjTID\nUnique ID of the table object over which a lock conﬂict is preventing the session from being granted a lock.\nThis value is NULL if:\nThe session does not have an AMPState of BLOCKED.\nThe Blk_x_OT ype is D.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nBlk1Status\nBlk2Status\nBlk3Status\nStatus of lock causing a block:\nW= Waiting\nG = Granted\nThis value is NULL if:\nSession does not have an AMPState of BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nA lock request may be blocked by either a granted lock or an ungranted lock that precedes the blocked lock request in the queue and is in conﬂict with it.\nA status of Waiting has a higher priority than that of Granted when there is more than one lock involved. For example, for a given object and a given session, a session that is\nblocked by a Waiting lock on one AMP and a Granted lock on another AMP has Waiting reported as its status.\nMoreBlockers\nIndicator of more lock conﬂicts:\nBlank = Blk x information is a complete list of sessions blocking the session described.\nAsterisk (*) = Additional sessions are blocking the session described.\nThis value is NULL if:\nThe state of the session is not BLOCKED.\nA request for data is made before completion of the ﬁrst collection period following either a system outage or a change in the SesMonitorLoc or SesMonitorSys rate.\nLogonSource\nLogon source information. At logon time, this information is optionally supplied by the Teradata Director Program or the Gateway to further identify the physical or logical location\nof the session, the logon user name, and the interface under which the session was initiated. (For example, the data string may include DBC as the user ID and BTEQ as the\ninterface.)\nA two-byte value precedes the LogonSource data to indicate the length of the string. The length value is zero if LogonSource is NULL.\nHotAmpnCPU\nWhere n in [1, 3]: CPU time of the nth highest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth highest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIO\nWhere n in [1, 3]: I/O count of the nth highest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nHotAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth highest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPU\nWhere n in [1, 3]: CPU time of the nth lowest CPU used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnCPUId\nWhere n in [1, 3]: Vproc ID of the nth lowest CPU used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIO\nWhere n in [1, 3]: I/O count of the nth lowest I/O used AMP during the collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nLowAmpnIOId\nWhere n in [1, 3]: Vproc ID of the nth lowest I/O used AMP for the last session collection interval.\nWhere n in [1, 2]: This value is NULL if the request is made before the collection period expires.\nWhere n = 3: This value is NULL if the request is made before the collection period expires, and if there are only two AMPs on the system.\nAvgAmpCPUSec\nAverage AMP CPU usage for the last session collection interval. The average is calculated as the sum of CPU usage for all amps participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nAvgAmpIOCnt\nAverage AMP I/O usage for the last session collection interval. The average is calculated as the sum of I/O usage for all AMPs participating divided by the number of online\nAMPs.\nThis value is NULL if the request is made before the collection period expires.\nLake - Monitor Resources and Performance\nPage 269 of 420AmpCount\nCurrent number of AMPs executing on the associated node.\nTempSpaceUsg\nTotal amount, in bytes, of temporary space used by the session.\nThis value is NULL if the session did not materialize any temporary tables.\nReqStartTime\nDate and time of the current request on the session started, typically formatted for display as yyyy/mm/dd 99:99:99.99, which represents the year, month, day hours: minutes:\nseconds.\nReqCPU\nTotal CPU usage by the current SQL request on the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL requests only.\nIgnore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nReqIO\nTotal number of accesses by the current SQL request for the session on all AMPs. This value contains proper request-level statistics for DBC/SQL sessions running SQL\nrequests only. Ignore the value returned in this ﬁeld for other types of sessions, such as DBC/SQL sessions linked to a utility job.\nReqNo\nActive request number.\nIf no request is running, a value of zero or NULL is displayed in indicator mode.\nIn the early phase of a request in parsing state, when PEState = PARSING, the request number may not be available and returned as zero or NULL. The active request number\nis available on the next collection.\nWlcId\nWorkload ID associated with the speciﬁed request.\nDontReclassifyFlag\nFlag indicating that the next request on the session is not classiﬁed, but uses the workload ID (WlcId) already assigned to the session. This occurs if this is a utility session or a\nWlcId was assigned to the session using the TDWMAssignWD function or the TDWM WD ASSIGNMENT request. For more information on these APIs, see TDWMAssignWD and\nTDWM WD ASSIGNMENT.\nProxyUser\nName of the proxy user in a trusted session.\nCPUDecayLevel\nCurrent most severe decay level as reached due to CPU usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nIODecayLevel\nCurrent most severe decay level as reached due to I/O usage.\nNodes can be at different levels of decay (for example, 0, 1, or 2).\nTacticalCPUException\nNumber of nodes that encountered a CPU exception.\nTacticalIOException\nNumber of nodes that encountered an I/O exception.\nReqIOKB\nTotal logical I/O usage in KB.\nReqPhysIO\nNumber of physical I/Os.\nReqPhysIOKB\nPhysical I/O usage in KB.\nReqStepsCompletedCnt\nCount of completed steps for the current request. If there is no change in ReqStepsCompletedCnt from the previous Monitor Session collection, this indicates that there are no\nnew steps completed.\nRedriveProtection\nRedrive protection type:\n' ' = No Redrive protection. This indicates that the session does not participate in Redrive and database restarts are not transparent to applications and users.\nMN = Memory-based Redrive protection, no fallback spools\nCurrentRedriveParticipation\nT = Redrive functionality is enabled (database restarts are transparent to applications and users)\nF = Redrive functionality is disabled (database restarts are not transparent to applications and users)\nReqRedriveSpoolSpace\nPersistent spool space for the current request.\nBlockerSessionCnt\nTotal number of blocker sessions for the session. This ﬁeld returns only the ﬁrst three blocker sessions in the record parcel. There are no additional blocker sessions if there are\nmore than three blocker sessions.\nReqTblOpBytesIn\nThe total number of bytes transferred into the database from a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesIn output parameter shows bytes transferred across all invocations within the request.\nReqTblOpBytesOut\nThe total number of bytes transferred out of the database and into a foreign server for the current request through one or more table operators.\nThe request may involve one or multiple table operator executions. The ReqTblOpBytesOut output parameter shows bytes transferred across all invocations within the request.\nProxyUserId\nThe UserID charged for SPOOL and TEMP space if being charged to the proxy user.\nZoneId\nThe unique identiﬁer of the zone.\nReqHotAmpCPU\nThe CPU time of the highest CPU used AMP during the life of the current request on the session.\nReqHotAmpCPUId\nVproc ID of the highest CPU used AMP for the current request.\nLake - Monitor Resources and Performance\nPage 270 of 420ReqHotAmpIO\nI/O count of the highest I/O used AMP during the life of the current request on the session.\nReqHotAmpIOId\nVproc ID of the highest I/O used AMP for the current request.\nReqInvolvedAMPCnt\nThe number of AMPs involved in processing the current request.\nReqFirstRespTime\nDate and time that the ﬁrst response of the current request on the session is ready. The response may be held to meet the TASM Minimum Response Time.\nReqLocalQueryStatus\nThe current state of the Uniﬁed Data Architecture (UDA) query.\nReqRemoteHostId\nHost ID of the remote system.\nReqRemoteSessionId\nSession ID of the executing remote query.\nReqRemoteRequestId\nRequest ID of the executing remote query.\nReqRemoteQueryId\nQuery ID of the executing remote query.\nReqHotAmpSpool\nSpool value of the highest spool used AMP during the life of the current request on the session.\nThis value is NULL if no request is running on the session.\nReqHotAmpSpoolId\nVproc ID of the highest spool used AMP for the current request.\nThis value is NULL if no request is running on the session.\nReqMapNo\nMap number for the largest map the request is using.\nReqMaxNumMapAMPs\nNumber of AMPs in the largest contiguous map used by the request.\nReqMinNumMapAMPs\nNumber of AMPs in the smallest contiguous map used by the request.\nReqSysDefNumMapAMPs\nNumber of AMPs in the system-default map used by the request.\nReqRemoteHostIp\nHost IP address of the remote system.\nReqServerName\nName of the foreign server.\nReqFlexReleased\nThe TDWM Flex Throttle feature detects available system resources, overrides existing workload throttle limits, and automatically releases queries from the delay queue. This\nminimizes the DBA manually managing the TASM delay queue. Only Workload throttles are overridden; all System level throttles are still honored.\nReturn values:\n0: Indicates that the request was not released by TDWM Flex Throttles.\n1: Indicates that the request was released by TDWM Flex Throttles.\nReqAdmissionTime\nReturns the date and time when a request is admitted into the system by TDWM.\nParentSessionNo\nOnly available in the detailed view and for compute clusters. This is an integer that links the query running from the primary cluster to the compute cluster. The Parent Session is\nthe session from the primary cluster that correlates to this SessionNo from the compute cluster.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nExamples: Using MonitorSessionSV\nExample: Identifying All Connected Sessions\nThis query identiﬁes all sessions that are currently connected to the system.\nSELECT *\n  FROM MONITORSESSIONSV(   \n USING HOSTID('-1')\n       USERNAME('*')\n       SESSIONID('0')\n       ) AS DT\n;\nExample: Determining Number of Sessions in Each State\nLake - Monitor Resources and Performance\nPage 271 of 420This query determines the number sessions in each state (Idle, Active, Blocked, Aborting, or Unknown).\nSELECT AMPSTATE\n      ,COUNT(*)\n \n  FROM MONITORSESSIONSV(   \n USING HOSTID('-1')\n       USERNAME('*')\n       SESSIONID('0')\n       )               AS DT\nGROUP BY AMPSTATE\nORDER BY AMPSTATE\n;\nExample: Identifying Sessions That are Blocked\nThis query identiﬁes sessions that are blocked by other sessions, along with the nature of the block.\nSELECT USERNAME\n      ,SESSIONNO           AS BLKD_SESS_NO\n      ,USERNAME\n      ,BLK1SESSNO          AS FIRST_BLKG_SESS_NO\n      ,BLK1USERID          AS FIRST_BLKG_USER_ID\n      ,BLK1LMODE           AS FIRST_BLKG_LOCK_TYPE\n      ,BLK2SESSNO          AS SECOND_BLKG_SESS_NO\n      ,BLK2USERID          AS SECOND_BLKG_USER_ID\n      ,BLK2LMODE           AS SECOND_BLKG_LOCK_TYPE\n      ,BLK3SESSNO          AS THIRD_BLKG_SESS_NO\n      ,BLK3USERID          AS THIRD_BLKG_USER_ID\n      ,BLK3LMODE           AS THIRD_BLKG_LOCK_TYPE\n  FROM MONITORSESSIONSV(   \n USING HOSTID('-1')\n       USERNAME('*')\n       SESSIONID('0')\n       )               AS DT\nWHERE AMPSTATE = 'BLOCKED'\nORDER BY USERNAME\n;\nExample: Using ComputeW orkerInUse\nSELECT SESSIONNO, USERNAME\nFROM TABLE (MonitorSession(-1, '*')) AS t1\nWHERE ComputeWorkerInUse = 'T';\nMonitorSQLCurrentStepSV\nUse this single operational view API for the SQL step being run on the currently running request across VantageCloud Lake clusters. You can then use this function to get additional\ndetails on that session to monitor the current SQL step for the SQL run, if that session that is running a query.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorSQLCurrentStepSV (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER,\n    DynamicPlan  SMALLINT\n    PartialSteps SMALLINT,\n    NumOfSteps SMALLINT,\n    CurLvl1StepNo SMALLINT,\n    CurLvl2StepNo SMALLINT\n    ZoneID INTEGER,\n    SPName VARCHAR(128) CHARACTER SET UNICODE,\n    SPDBName VARCHAR(128) CHARACTER SET UNICODE,\n    DefaultDBName VARCHAR(128) CHARACTER SET UNICODE,\n    ParentSessionNo INTEGER,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\nLake - Monitor Resources and Performance\nPage 272 of 420    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nA value of -1 indicates all hosts.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nThis value is incremented by 10000 for each compute cluster for the single view. For example, the ﬁrst node of the primary cluster starts at 1, the ﬁrst node of the ﬁrst online\ncompute cluster starts at 10001, and the ﬁrst node of the second online compute cluster starts with 20001, and so on.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nDynamicPlan\nPlan type:\n0 = Static plan\n1 = Dynamic plan\nPartialSteps\nPossible values:\n0 = All steps are returned\n1 = Partial plan or no plan is returned\nIf a partial plan is returned, this indicates the steps for the ﬁnal plan fragment of the dynamic explanation of the request has not yet been generated.\nIf no plan is returned, this indicates the request has been throttled and is in the delay queue.\nA value 1 cannot occur for a static plan.\nNumOfSteps\nNumber of steps in the description text in the third statement of the response.\nPlan DynamicPlan Field V alue PartialSteps Field V alue NumOfSteps\nStatic 0   Number of steps for plan.\nComplete dynamic 1 0 Number of steps for plan.\nPartial dynamic 1 1 Number of steps generated.\nIf a request with a partial dynamic plan has been throttled and is in the delay queue (that is, no rows are returned in response to the third statement), NumOfSteps is zero.\nFor more information, see DynamicPlan and PartialSteps ﬁelds in MONITOR SQL.\nCurLvl1StepNo\nNumber of the running level 1 step. If parallel steps are running, this is the number of the lowest running step.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for example, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are\nPartialSteps ﬁeld values are 1), the CurLvl1StepNo ﬁeld value is zero.\nCurLvl2StepNo\nNumber of the running step. If parallel steps are running, this is the number of the highest running step. If only one step is running, CurLvl1StepNo and CurLvl2StepNo are\nidentical.\nIf this is a request with a dynamic plan that has been throttled and is in the delay queue (for example, when the NumOfSteps ﬁeld value is zero and both the DynamicPlan are\nPartialSteps ﬁeld values are 1), the CurLvl2StepNo ﬁeld value is 1.\nIf only one step is executing, CurLvl1StepNo and CurLvl2StepNo are identical.\nZoneId\nThe unique identiﬁer of the zone.\nSPName\nThe outer stored procedure name, if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nSPDName\nThis is the owner database name of the outer stored procedure if a stored procedure is running.\nNULL is returned in indicator mode if no stored procedure is running.\nDefaultDBName\nThis ﬁeld returns the default database name of the session at the start of the non-stored procedure request. For stored procedures, this ﬁeld returns the default database name\nof the session when the stored procedure was compiled.\nParentSessionNo\nOnly available in the detailed view and for compute clusters. This integer links the query running from the primary cluster to the compute cluster. The Parent Session is the\nsession from the primary cluster that correlates to this SessionNo from the compute cluster.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nLake - Monitor Resources and Performance\nPage 273 of 420Only available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nUsage Notes\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned.\nFor information on MONITOR SQL, see MONITOR SQL.\nExamples: Using MonitorSQLCurrentStepSV\nExample: Using MonitorSQLCurrentStepSV with Default Query\nThis query requests the current SQL step for this session from the speciﬁed host.\nSELECT * from MonitorSQLCurrentStepSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1007')\n    RunVProcNo('30719')\n) AS dt;\nThe output looks similar to this.\n       HostId        10001\n    SessionNo         1007\n  DynamicPlan       0\nPartialSteps       0\n   NumOfSteps       3\nCurLvl1StepNo       1\nCurLvl2StepNo       1\n       ZoneId            0\n       SPName\n     SPDBName\nDefaultDBName tdaas_cloudfabric1\nExample: Using MonitorSQLCurrentStepSV with Detailed V iew Query\nThe detailed view adds Type, Id, Name, and Group columns to identify the source of these metrics.\nSELECT * from MonitorSQLCurrentStepSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1007')\n    RunVProcNo('30719')\n    details('1')       \n) AS dt;\nThe output looks similar to this.\n       HostId        10001\n    SessionNo         1007\n  DynamicPlan       0\nPartialSteps       0\n   NumOfSteps       3\nCurLvl1StepNo       1\nCurLvl2StepNo       1\n       ZoneId            0\n       SPName\n     SPDBName\nDefaultDBName  tdaas_cloudfabric1\nParentSessionNo 2016\n         Type  compute cluster\n           Id  sys-784f2c302a_pog_784f2c1087_group_1_cog_1_0b1osq\n         Name  1-0b1osq\n        Group  pog_784f2c1087_group_1\nMonitorSQLStepsSV\nLake - Monitor Resources and Performance\nPage 274 of 420Use this single operational view API for SQL steps being run across VantageCloud Lake clusters. Then use this function to get additional details on that session to monitor the current\nSQL step for the SQL run, provided that session is running a query.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorSQLStepsSV (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER,\n    DynamicPlan SMALLINT,\n    PartialSteps SMALLINT \n    StepNum INTEGER,\n    Confidence SMALLINT,\n    EstRowCount FLOAT,\n    ActRowCount FLOAT,\n    EstRowCountSkew FLOAT,\n    ActRowCountSkew FLOAT,\n    EstRowCountSkewMatch FLOAT,\n    ActRowCountSkewMatch FLOAT,\n    EstElapsedTime FLOAT,\n    ActElapsedTime FLOAT,\n    SQLStep  VARCHAR(2048)CHARACTER SET UNICODE,\n    ParentSessionNo INTEGER,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\n    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nThis value is incremented by 10000 for each compute cluster for the single view. For example, the ﬁrst node of the primary cluster starts at 1, the ﬁrst node of the ﬁrst online\ncompute cluster starts at 10001, and the ﬁrst node of the second online compute cluster starts with 20001, and so on.\nSessionNo\nNumber of the current session. With a given host ID, a session number uniquely identiﬁes a session on the database system. This value is assigned by the host (or client) at\nlogon time.\nDynamicPlan\nPlan type:\n0 = Static plan\n1 = Dynamic plan\nPartialSteps\nPossible values:\n0 = All steps are returned\n1 = Partial plan or no plan is returned\nIf a partial plan is returned, this indicates the steps for the ﬁnal plan fragment of the dynamic explanation of the request has not yet been generated.\nIf no plan is returned, this indicates the request has been throttled and is in the delay queue.\nA value 1 cannot occur for a static plan.\nStepNum\nUnique number identifying the EXPLAIN step.\nConﬁdence\nConﬁdence level as determined by the optimizer:\n0 = None\n1= Foreign Key\n2 = Low\n3 = High\nEstRowCount\nEstimated row count generated from the Optimizer plan for this step.\nLake - Monitor Resources and Performance\nPage 275 of 420For a PRPD plan, the EstRowCount ﬁeld for the split step (that is, a RETRIEVE or JOIN step with “split into” appearing in the EXPLAIN when target spools are generated) is the\nestimated row counts for ALL split spools.\nFor more information on PRPD, see Join Strategies and Methods.\nActRowCount\nActual row count returned from the AMP for this step.\nFor a PRPD plan, this value includes rows from all split spools for a split step.\nSee Join Strategies and Methods.\nEstRowCountSkew\nEstimated row count for the skew split spool in PRPD, which contains the rows with skewed values of this spool.\nSee Join Strategies and Methods.\nActRowCountSkew\nActual number of rows for the skew split spool in PRPD.\nSee Join Strategies and Methods.\nEstRowCountSkewMatch\nEstimated row count for the skew match split spool in PRPD, which contains the rows with skewed values of the other relation to be joined with this relation.\nSee Join Strategies and Methods.\nActRowCountSkewMatch\nActual number of rows for the skew match split spool in PRPD.\nSee Join Strategies and Methods.\nEstElapsedTime\nEstimated time for the query as generated from the Optimizer plan.\nActElapsedTime\nActual elapsed time calculated by the dispatcher.\nSQLStep\nGenerated text for the step.\nParentSessionNo\nOnly available in the detailed view and for compute clusters. This integer links the query running from the primary cluster to the compute cluster. The Parent Session is the\nsession from the primary cluster that correlates to this SessionNo from the compute cluster.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nUsage Notes\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned.\nFor information on MONITOR SQL, see MONITOR SQL.\nExamples: Using MonitorSQLStepsSV\nExample: Mapping a Session to a Compute Cluster\nThis query tracks the compute cluster on which your query ran. The query runs using the MonitorSessionSV API.\nSELECT HostId, UserName, SessionNo, LogonPENo, ParentSessionNo, Id from MonitorSessionSV(\n  USING\n    details('1')\n) AS dt;\nThe output is similar to this (dispayed vertically for readability):\nHostId 1\nUserName TDAAS_TDBCMGMT1\nSessionNo 1,025\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,009\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nLake - Monitor Resources and Performance\nPage 276 of 420HostId 1\nUsername VIM\nSessionNo 2,011\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,013\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,015\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername TDAAS_CLOUDMONITOR1\nSessionNo 2,016\nLogonPENo 30,718\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername TDAAS_TDBCMGMT1\nSessionNo 1,022\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername TDAAS_TDBCMGMT1\nSessionNo 1,024\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername CLOUDFEDERATOR11\nSessionNo 1,973\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,010\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,012\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 1\nUsername VIM\nSessionNo 2,014\nLogonPENo 30,719\nParentSessionNo 0\nId pog-64ccddff53\nHostId 10,001\nUsername TDAAS_TDBCMGMT1\nLake - Monitor Resources and Performance\nPage 277 of 420SessionNo 1,003\nLogonPENo 30,716\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_CLOUDFEDERATOR\nSessionNo 1,822\nLogonPENo 30,716\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_TDBCMGMT1\nSessionNo 1,002\nLogonPENo 30,717\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_CLOUDFABRIC1\nSessionNo 1,316\nLogonPENo 30,717\nParentSessionNo 2,013\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_TDBCMGMT1\nSessionNo 1,001\nLogonPENo 30,718\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_CLOUDROUTERMANAGED1\nSessionNo 1,048\nLogonPENo 30,716\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nHostId 10,001\nUsername TDAAS_CLOUDFEDERATOR\nSessionNo 1,821\nLogonPENo 30,716\nParentSessionNo 0\nId sys-64ccdd3a19_computegroup1_computeprofile1_zioqep\nThis output shows that the primary cluster session of 2013, run by user vim, is being run by the service account TDAAS_CLOUDFABRIC1 in the compute instance sys-\n64ccdd3a19_computegroup1_computeproﬁle1_zioqep with session number 1,316.\nYou can use the MonitorSQLStepSV API to get additional details on this compute session.\nSELECT *  from MonitorSQLStepsSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1316')\n    RunVProcNo('30717')\n    details('1')   \n) AS dt;\nThe output shown is truncated for readability, but is similar to this:\n|HostId|SessionNo|StepNum|EstRowCount    |SqlSteps                                             |\n|------|---------|-------|---------------|-----------------------------------------------------|\n|10,001|1,316    |1      |0              |First, [Step text undefined].                        |\n|10,001|1,316    |2      |1              |Next, we do a Single-AMP RETRIEVE step from Spool ...|\n|10,001|1,316    |3      |1,632          |We do an All-AMPs RETRIEVE step from Spool 2013 ...  |\n|10,001|1,316    |3      |1              |We do a Single-AMP RETRIEVE step from Spool 2013 ... |\n|10,001|1,316    |4      |1              |We do a Single-AMP RETRIEVE step from Spool 2013 ... |\n|10,001|1,316    |5      |20,000,000,016 |We do a MERGE into Spool 2013 from Spool 2013.       |\n|10,001|1,316    |6      |0              |We do an All-AMPs RETRIEVE step from Spool 336 ...   |\n|10,001|1,316    |7      |0              |We do a MERGE into Spool 2013 from Spool 337.        |\n|10,001|1,316    |8      |0              |We do an All-AMPs RETRIEVE step from Spool 333 ...   |\nLake - Monitor Resources and Performance\nPage 278 of 420|10,001|1,316    |9      |0              |We do a MERGE into Spool 2013 from Spool 339.        |\n|10,001|1,316    |9      |0              |We do an All-AMPs RETRIEVE step from Spool 335 ...   |\n|10,001|1,316    |10     |0              |We do an All-AMPs RETRIEVE step from Spool 341 ...   |\n|10,001|1,316    |11     |0              |We do a MERGE into Spool 2013 from Spool 340.        |\n|10,001|1,316    |12     |0              |We send out an END TRANSACTION step to all AMPs ...  |\nYou can also view the current step being run in the compute instance:\nSELECT * from MonitorSQLCurrentStepSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1316')\n    RunVProcNo('30717')\n    details('1')   \n) AS dt;\nThe output shown is truncated for readability, but is similar to this:\n|HostId|SessionNo|CurrLvl1|CurrLvl2|\n|------|---------|----- --|--------|\n|10,001|1,316    |6       |6       |\nThis query shows the SQLText associated with the current step being run in the compute instance:\nSELECT * from MonitorSQLTextSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1316')\n    RunVProcNo('30717')\n    details('1')   \n) AS dt;\nThe SQLTxt column shown is truncated for readability, but is similar to this:\n|HostId|SessionNo|SeqNum|SQLTxt                                           |\n|------|---------|------|-------------------------------------------------|\n|10,001|1,316    |1     |SELECT * FROM TD_SYSFNLIB.QGRemoteExport ...     |\nMonitorSQLTextSV\nUse this single operational view for the SQL text value for the current SQL step being run across VantageCloud Lake clusters. You can get additional details on that session to monitor\nthe SQL text for the current step, provided that session is running a query.\nSyntax\nREPLACE FUNCTION SYSLIB.MonitorSQLTextSV (\n  HostIdIn  SMALLINT,\n  SessionNoIn  INTEGER,\n  RunVprocNo  SMALLINT\n) RETURNS TABLE (\n    HostId SMALLINT,\n    SessionNo INTEGER, \n    SeqNum SMALLINT,\n    SQLTxt VARCHAR(31000) CHARACTER SET UNICODE,\n    ParentSessionNo INTEGER,\n    Type VARCHAR,\n    Id VARCHAR,\n    Name VARCHAR,\n    Group VARCHAR\n  )\n  ...\n;\nSyntax Elements\nHostIdIn\nLogical ID of a host (or client) with sessions logged on.\nSessionNoIn\nSession number of the SQL to monitor.\nRunVprocNo\nPE vproc number where the session runs.\nHostId\nThis value is incremented by 10000 for each compute cluster. For example, the ﬁrst node of the primary cluster starts at 1, the ﬁrst node of the ﬁrst online compute cluster starts\nat 10001, and the ﬁrst node of the second online compute cluster starts with 20001, and so on.\nSessionNo\nLake - Monitor Resources and Performance\nPage 279 of 420Session number of the SQLtext.\nSeqNum\nSequence number of the row. For example, if the SQL text exceeds 31,000 bytes, the system returns multiple rows.\nSQLTxt\nSQL text of the running request.\nParentSessionNo\nOnly available in the detailed view and for compute clusters. This integer links the query running from the primary cluster to the compute cluster. The Parent Session is the\nsession from the primary cluster that correlates to this SessionNo from the compute cluster.\nType\nOnly available in the detailed view. Identiﬁes the group type (compute cluster or primary cluster).\nId\nOnly available in the detailed view. Provides the TOS identiﬁer the of the group (useful to identify compute clusters).\nName\nOnly available in the detailed view. Provides the name of the compute cluster.\nGroup\nOnly available in the detailed view. Provides the name of the compute group.\nUsage Notes\nIf MONITOR SQL processing is not completed within the timeout interval, then an error is returned to the client application. When a MONITOR SQL request is timed out, the processing\ncontinues internally to its completion. If the client application submits a new MONITOR SQL request for the same timed out target session while the previous timed out one is still being\nprocessed, then an error is returned.\nFor information on MONITOR SQL, see MONITOR SQL.\nExamples: Using MonitorSQL TextSV\nExample: Using MonitorSQL TextSV with Default Query\nThis query requests the SQL text of the current SQL step for this session from the speciﬁed host.\nSELECT * from MonitorSQLTextSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1007')\n    RunVProcNo('30719')\n) AS dt;\nThe output is similar to this.\n   HostId       10001\nSessionNo        1007\n   SeqNum      1\n   SQLTxt SELECT t2.* from table (MonitorSQLText(1, 1007, 30719)) as t2;\nExample: Using MonitorSQL TextSV with Detailed V iew Query\nThe detailed view adds Type, Id, Name, and Group columns to identify the source of these metrics.\nSELECT * from MonitorSQLTextSV(\n  USING\n    HostIdIn('10001')\n    SessionNoIn('1007')\n    RunVProcNo('30719')\n    details('1')\n) AS dt;\nThe output is similar to this.\n         HostId       10001\n      SessionNo        1007\n         SeqNum      1\n         SQLTxt SELECT t2.* from table (MonitorSQLText(1, 1007, 30719)) as t2;\n  ParentSessionNo 2016\n         Type compute cluster\n         Id sys-784f2c302a_pog_784f2c1087_group_1_cog_1_0b1osq\n         Name 1-0b1osq\n         Group pog_784f2c1087_group_1\nTeradata Dynamic Workload Management APIs: PM/APIs\nThe following discusses how to manage TASM operations through two types of interfaces:\nTeradata Dynamic Workload Management PM/APIs\nLake - Monitor Resources and Performance\nPage 280 of 420Teradata Dynamic Workload Management Open APIs (SQL Interfaces)\nBefore using the Teradata Dynamic Workload Management APIs, you may want to familiarize yourself with the following topics:\nTeradata Dynamic Workload Management API Features\nExamples: Using Open APIs\nTeradata Dynamic Workload Management PM/APIs\nThis section describes the Teradata Dynamic Workload Management interfaces that use CLIv2 or the Teradata JDBC Driver. These interfaces are called PM/API requests.\nFor details on using the Teradata JDBC Driver requests, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nBefore using the Teradata Dynamic Workload Management PM/APIs, read the following topic on the impact of object name length on PM/APIs requests.\nImpact of Object Name Length on PM/API Requests\nObject names contain 128 Unicode characters; however, to use object names of 128 characters, applications must use monitor software version 10 or later.\nMonitor Software V ersion Object Field in Input Area\n8 or earlier CHAR(30). A ﬁxed parcel ﬁeld size of 30 bytes. The names must be padded with spaces.\nSee previous releases of Workload Management API: PM/API and Open API.\n9 VARCHAR(120). A parcel ﬁeld size of up to 120 bytes in variable length.\n10 or later VARCHAR(512). A parcel ﬁeld size of up to 512 bytes in variable length in host character set\nformat.\nDepending on the version of your custom application, PM/API request output ﬁelds for object names may be truncated. For example, if the output ﬁeld is an object name of 100 bytes\nin length when converted to host character set format, and you are using a PM/API request with monitor software version 8 or earlier, the database name is truncated to ﬁt the ﬁxed\nparcel ﬁeld size of 30 bytes.\nEVENT STATUS\nPERFGROUPS\nTDWM DELAY REQUEST CHANGE\nTDWM EXCEPTIONS\nTDWM LIST WD\nTDWM STATISTICS\nTDWM SUMMARY\nTDWM WD ASSIGNMENT\nUSER EVENT CONTROL\nEVENT ST ATUS\nReturns information about the current status of all event-related constructs, such as events through states, and information related to the current state.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT, NOT NULL MONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nRequest Type SMALLINT, NOT NULL 1 = ALL. This option returns the status of all events, expressions, and SysCo ns.\n2 = CURRENT. This option includes the status of those events and expressions that are related to the enforced\nhealth condition (SysCon) and planned environment (OpEnv).\nID Mapping SMALLINT Mapping information returned in the output, such as the names and IDs deﬁned within the current rule set.\nIf a value of 1 is returned, mapping record types are included. Otherwise, no mapping information is returned.\nMonitor Privileges\nLake - Monitor Resources and Performance\nPage 281 of 420To use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nCLIv2 Response Parcels\nThe following table lists information about the parcels.\nParcel Sequence Number Field Length Comments and Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo =1\nActivityCount = Not applicable\nActivityType = 170 (PCLEVENTSTATUSSTMT)\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on the request (Data or IndicData) data is returned in record\nor indicator mode. This is the only record returned.\nThis record contains an indicator for each category, indicating its status\nafter processing this request (0=active, 1=inactive)\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe EVENT STATUS request returns the status of all items that make up either the CURRENT or ALL states deﬁned in the current rule set.\nThe output is divided into three statements:\nThe ﬁrst statement provides conﬁguration overview information.\nThe second statement provides a series of records that represent the status of events, expressions, and states in the system. Only events that are referenced in Expressions\nthat have an action are included in this statement. To optimize the interface, this information is provided using the internal ID of the events, expressions, and states.\nThe third statement, which is optional, provides the mapping of internal IDs to names.\nStatement 1\nThe ﬁrst statement returns information about the current conﬁguration.\nField/Column Name Data T ype Description\nConﬁg ID INTEGER\nNOT NULLConﬁguration ID of the current rule set.\nConﬁg Name VARCHAR (30) Name of the current rule set, blank ﬁlled.\nDate DATE Date when this conﬁguration was ﬁrst activated.\nTime FLOAT Time when this conﬁguration was ﬁrst activated.\nUse this ﬁrst statement to determine if a new conﬁguration is in effect. If so, request the mapping record type to provide the mapping of object IDs to object names.\nStatement 2\nThe second statement returns a series of records that provide the status of events, expressions, SysCons and OpEnvs in the system. The information returned shows the relationship\nbetween an Event, the Expression that references that Event, and the SysCo n or OpEnv that is affected by that Expression.\nThere is one record returned for every Event that is referenced in the associated Expression. When CURRENT is requested only a single Expression for the CURRENT SysCon and\nOpEnv that caused that SysCon or OpEnv to be deﬁned as enforced is returned. When ALL is requested, ALL expressions for each SysCo n or OpEnv are returned. In addition, the ALL\ninterface returns those expressions which do not have an action related to a SysCon or OpEnv. These are called Notify Only Expressions.\nThe expression and owning SysCon or OpEnv ID ﬁelds are repeated until all events are included. If events are repeated within multiple expressions, those events are reported within\neach of those expressions. For the case of the ALWAYS OpEnv and the NORMAL SysCo n, there is no expression associated. Statements for these two items have a value of zero for\nthe Event and Expression ID ﬁelds.\nLake - Monitor Resources and Performance\nPage 282 of 420Field/Column Name Data T ype Description\nEventId INTEGER\nNOT NULLInternal ID of the Event. A value of zero indicates there is no event for this record entry.\nThere are no expressions for the Normal SysCon, Always OpEnv, and a State.\nEvents are reported in order of appearance in the associated expression. Only events in\nthe associated expression are included.\nEventStatus SMALLINT Status of the event:\n0 = Inactive\n1 = Active\nEventActiveDate DATE Date when EventStatus was last changed. This is the date when EventStatus was set to\nInactive or Active.\nEvent Active Time FLOAT Time when EventStatus was last changed. This is the time when EventStatus was set to\nInactive or Active.\nExpressionId INTEGER\nNOT NULLInternal ID of the Expression.\nA value of zero indicates there is no expression for this record entry. There are no\nexpressions for the Normal SysCon, Always OpEnv, and a State.\nFor the CURRENT state request, the ﬁrst TRUE expression for the associated State is\nincluded. When there are multiple true expressions for a state only the ﬁrst one processed\nis reported. The order of processing is consistent within a rule set and, therefore, the same\nTrue expression is reported on every request.\nExpression Status SMALLINT Current status of the Expression:\n0 = Inactive\n1 = Active\nExpression Active Date DATE Date when Expression Status was last changed. This is the date when Expression Status\nwas set Active or Inactive.\nExpression Active Time FLOAT Time Expression Status was last changed. This is the time when Expression Status was set\nActive or Inactive.\nRecord Type SMALLINT Type of information contained in this record:\n0 = SysCon\n1 = OpEnv\n2 = Notify Only Expression. This option indicates the remaining ﬁelds are not\napplicable as only the Event or Expression relationship is reported in this statement.\n3 = State. This option indicates the current active State. This is the result of the\ncurrent SysCon and OpEnv. For this Record Type, the Event and Expression ﬁelds\nare not valid.\nFor both the CURRENT and ALL requests, the order in which State information is returned is\nas follows:\nSysCon\nOpEnv\nState (Returns only the Enforced State)\nNotify Only Expression is only returned for the ALL request.\nId INTEGER\nNOT NULLInternal ID of either a SysCon or an OpEnv depending on the Record Type speciﬁed.\nThe value is zero for Notify Only Expression record types. Notify Only Expression records\nrepresent Expressions that do not have an action to activate a Syscon or OpEnv. These\nExpressions are not associated with a State.\nStatus SMALLINT Current status of the Syscon or OpEnv:\n0 = Inactive\n1 = Active\n2 = Active and Enforced\nDue To Duration INTEGER Indicator that the corresponding SysCon is being considered as TRUE or is TRUE:\n1 = SysCon is Active if the corresponding SysCon is being considered as TRUE due\nto minimum duration (MinDuration) value being in affect.\n0 = SysCon is Inactive if the Syscon is TRUE based on the deﬁned expressions.\nThis ﬁeld is valid only when SysCon is the Record Type speciﬁed.\nLake - Monitor Resources and Performance\nPage 283 of 420Field/Column Name Data T ype Description\nActive Date DATE Date when the status of the Record Type was last changed. This is the date when the\nSysCon or OpEnv Status was set Active or Inactive.\nActive Time FLOAT Time representing when the status of the Record Type was last changed. This is the time\nwhen the SysCon or OpEnv Status was set Active or Inactive.\nThe date or time for each item (for example, Event, Expression, or State) shows when the status that is represented occurred.\nThe State column in the following examples refers to the Expression Status ﬁeld.\nEvtID Status Date/Time      ExpID State    Date/Time         RecType   Id   Status\n110    1     8:00AM 1/2/06  220     1      8:00AM 1/2/06      0       300   1\n120    0     8:15AM 1/2/06  220     1      8:15AM 1/2/06      0       300   1\n130    1     8:00AM 1/2/06  320     1      8:00AM 1/2/06      1       400   1\n140    1     8:15AM 1/2/06  320     1      8:15AM 1/2/06      1       400   1\nThis statement shows two records representing a Single expression (220) that is deﬁned with two Events (110 and 120). In this example, 110 is true and 120 is false. The original\nexpression must be referenced by the user to determine why these event values resulted in the Expression being true. That is, these events are part of a logical expression whose\nstructure is not being reported here. Another expression (320) is shown that is made up of two events (130 and 140). This expression is responsible for the OpEnv of 400 being in\nenforced.\nEvtID   Status  Date/Time     ExpID  State  Date/Time       RecType  Id   Status\n0        0      8:00AM 1/2/06   0      0    8:00AM 1/2/06      0     100   1\n0        0      8:15AM 1/2/06   0      0    8:15AM 1/2/06      1     200   1\nThis record has both event and expression IDs of zero. This is the case for both the NORMAL SysCon and the ALWAYS OpEnv, which have no associated expressions. The Date/Time\nﬁelds are not valid because they are not associated with an Event or Expression, but are only shown as placeholders.\nFor the CURRENT request, the ﬁrst Active expression for a SysCon/OpEnv is returned. Within this Active (true) expression, all events, both Active and Inactive, are reported. The\ninterface reports the events in a consistent order for a given expression.\nFor the ALL request, the order of reporting is that all SysCo ns are returned, followed by all OpEnvs, then all Expressions not associated with a SysCo n or OpEnv State. These are called\nNotify Only Expressions. Within a SysCon or OpEnv, all expressions for that State are reported before reporting the next SysCo n or OpEnv. There is no order deﬁned for the expressions\nreported under a SysCon/OpEnv, but the interface makes sure that expressions are returned in a consistent order.\nThe following example shows the reporting of three SysCons (300, 310, and 400), three OpEnvs (500, 530, and 540), and one Notify Only Expression (329) made up of one event\n(199). This Notify Only Expression does not have an ID for the Record Type (2). Although not shown in the example, only one SysCo n and one OpEnv reported have the enforced value\nreturned (a Status of 2). You must independently use the TDWM database State table to make the association to a State using the returned SysCon and OpEnv.\nThe State column in the following example refers to the Expression Status ﬁeld.\nEvtID   Status  Date/Time     ExpID   State    Date/Time       RecType    Id   Status\n110      1    8:00AM 1/2/06  220      0      8:00AM 1/2/06      0       300    0\n120      0    8:15AM 1/2/06  220      1      8:15AM 1/2/06      0       310    1\n130      1    8:00AM 1/2/06  223      1      8:00AM 1/2/06      0       400    1\n140      1    8:15AM 1/2/06  223      1      8:15AM 1/2/06      0       400    1\n150      1    8:00AM 1/2/06  244      0      8:00AM 1/2/06      1       500    1\n160      0    8:15AM 1/2/06  220      1      8:15AM 1/2/06      1       500    1\n170      1    8:00AM 1/2/06  320      1      8:00AM 1/2/06      1       540    1\n180      1    8:15AM 1/2/06  320      1      8:15AM 1/2/06      1       530    1\n199      1    8:15AM 1/2/06  329      1      8:15AM 1/2/06      2        0     0\nStatement 3\nThe third statement, if requested, provides a fully enumerated list of objects that make up the system state. These objects may not be represented in any expressions in the state\ndeﬁnition. There are no duplications of objects in this statement and there is no correlation made between objects.\nBecause this information does not change frequently, this mapping information must be requested only when a new conﬁguration is made active by the administrator.\nField/Column Name Data T ype Description\nObject Type SMALLINT Type of object:\n0 = Event\n1 = Expression\n2 = SysCon\n3 = OpEnv\n4 = State\nObject Id INTEGER, NOT NULL Internal object ID for the object type.\nObject Name VARCHAR (30) Name of the object.\nObject Status SMALLINT Current status of the object:\n0 = Inactive\nLake - Monitor Resources and Performance\nPage 284 of 420Field/Column Name Data T ype Description\n1 = Active\nPrecedence/Severity INTEGER Indicator of the Precedence or Severity of the SysCon or OpEnv object types only:\nSysCon = Indicates the Severity of the SysCon.\nOpEnv = Indicates the Precedence of the OpEnv.\nThis ﬁeld does not apply if this is an Event.\nDate DATE Date of the current object status (see Object Status).\nTime FLOAT Time of the current object status (see Object Status).\nEventKind INTEGER Indicator of the speciﬁc event:\n1 = User Deﬁned SysCon. The user-deﬁned system condition.\n2 = User Deﬁned OpEnv. The user-deﬁned operating environment.\n3 = Time Period. The time range.\n4= Fatal AMPs. The number of AMPs with the status of FATAL.\n5 = Fatal PEs. The number of PEs with the status of FATAL.\n6 = Fatal GTWs. The number of Gateways with the status of FATAL.\n7 = Nodes Down. The % of nodes down within a clique.\n8 = Minimum available AWTs. The number of in-use AMP AWTs.\n9 = AMPs In Flow Control. The number of AMPs in ﬂow control.\n10 = Average System CPU. This value is calculated by the CPU usage columns in the\nresusagespmaV and resusagespsV tables and compared to the threshold deﬁned by the user in\nthis event.\n11 = System CPU Skew. This value is calculated by the CPU usage columns in the resusagespmaV\nand resusagespsV tables.\n12 = WD CPU %. This value is calculated by the CPU usage columns in the resusagespmaV and\nresusagespsV tables.\n13 = WD SLG Response Time. The % of request in this WD that have met the deﬁned Response\nTime SLG.\n14 = WD SLG Throughput. The % of request in this WD that have met the deﬁned Throughput SLG.\n15 = WD Arrivals. The number of new requests for this WD.\n16 = WD Active Request. The number of active requests in this WD.\n17 = WD Delay Queue Depth. The number of requests on the Delay Queue for this WD.\n18 = WD Delay Query Time. The max time a request has been delayed in this WD.\n19 = WD AWT Wait Time. The max time a request from this WD was on an AMP mailbox waiting for\nan AWT.\n20 = TwmFlexAvailableAWTsEvent. The number of AWTs that are available for work.\n21 = TwmFlexAvgCpuEvent.\nThis value is calculated by the CPU usage columns in the resusagespmaV and resusagespsV\ntables and compared to the threshold deﬁned by the user in this event.\nEventClass INTEGER This ﬁeld is only valid for Object Type of Event and Expression. The values are:\n1 = OpEnv\n2 = SysCon\n3 = FlexThrtl\nThe following example shows the relationship between the Event Id (110) in statement 2 and the Object Name (AMPDownEvent) in statement 3.\nThe data returned looks similar to this:\nObject type = 0\nObject Id    = 110\nObject name =  AMPDownEvent\nObject status = 0\nPrecedence/Severity=\nDate = 04/04/07\nTime = 02:30:06\nEventKind = 9\nThe following is the order of objects returned for statement 3:\n1. All the rows for the Events\n2. A row for a SysCon and all Expressions that are part of that Syscon\n3. A row for the next SysCon and its subordinate Expressions until all SysCo ns are reported\n4. A row for a OpEnv and all Expressions that are part of that OpEnv\n5. A row for the next OpEnv and its subordinate Expressions until all OpEnvs are reported\n6. All the rows for the States\n7. All the rows for the Notify Only Expressions\nLake - Monitor Resources and Performance\nPage 285 of 420PERFGROUPS\nReturns information about the Resource Partitions (RPs) and Performance Groups (PGs) active in the system GDO ﬁle.\nImportant: On database systems running SLES 11 or later, this function is deprecated and returns an error.\nTDWM DELA Y REQUEST CHANGE\nReleases or aborts a speciﬁc request or session on the Teradata dynamic workload management software defer or delay queue.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nRequest Flag SMALLINT Indicator that the request or session was aborted or released:\n0 = Request is aborted\n1 = Request is released\n2 = Session is aborted\n3 = Session is released\nHost ID SMALLINT ID of the host number on which the session containing the delayed request was established.\nReserved SMALLINT Mod-4 alignment padding.\nSession Number INTEGER Number of the session in which the delayed request was submitted. A unique session number is\nassigned by the host (or client) at logon.\nRequest Number INTEGER Active request number.\nThis ﬁeld is not used if Request Flag is either 2 or 3.\nWorkload Class Id INTEGER Workload ID for the delayed request.\nIf the request is from the context delay queue (where there is no workload ID), the ﬁeld value is\nzero.\nThis ﬁeld is not used if Request Flag is either 2 or 3.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nThe TDWM DELAY REQUEST CHANGE request allows requests or sessions to be processed out of the normal ﬁrst-in-ﬁrst-out (FIFO) order.\nBefore you submit a TDWM DELAY REQUEST CHANGE request, you need to run a TDWM STATISTICS or MONITOR SESSION request to get information about the deferred or delayed\nquery that requires change. Use the output of the request to identify the Host Id, Session Number, Request Number, and Workload Class Id parameters required as part of the TDWM\nDELAY REQUEST CHANGE input.\nIf the identiﬁed request or session is not found in the Teradata dynamic workload management software delay queue, an error is returned. This condition is expected because requests\nor sessions are typically released from the delay queue, whereas the information in the TDWM STATISTICS request can be outdated.\nCLIv2 Response Parcels\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo=1\nLake - Monitor Resources and Performance\nPage 286 of 420Parcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nActivityCount=0\nActivityType= 155 (PCLTWMDELRQSTCHGSTMT)\nEndStatement 11 6 StatementNo = 2-byte integer=1\nEndRequest 12 4 None\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a TDWM DELAY REQUEST CHANGE request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 16 Request TDWM DELAY REQUEST CHANGE\n0003 Data 24 MonVerID\nRequest Flag\nHost Id\nRequest Number\nSession Number\nWorkload Class Id7\n0\n1\n5\n1000\n10\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe TDWM DELAY REQUEST CHANGE request returns values approximately, as follows, when TASM Workloads are enabled and the following input data is speciﬁed:\nRequest Flag = 0\nHost Id =1\nRequest Number = 5\nSession Number = 1000\nWorkload Class Id = 10\nThe TDWM DELAY REQUEST CHANGE request commonly returns values in text character format. Your application program may return the values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 155 FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nEndStatement.\nEndRequest.\nTDWM EXCEPTIONS\nCollects Teradata dynamic workload management software exception data from the database.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nLake - Monitor Resources and Performance\nPage 287 of 420Element Data T ype Description\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This must be version 8 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nThis request allows an application to receive the Teradata dynamic workload management software exception information from the database. There is one record per exception.\nCLIv2 Response Parcels\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = PCLTWMEXPSTMT 199\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record mode)\n6 to 64100(indicator mode)Depending on the request (Data or IndicData) data is returned in\nrecord or indicator mode. This is the only record returned\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 Statement 2\nActivityCount = number of record parcels returned\nActivityType = PCLTDWMEXPSTMT 199\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n8 to 64100 (indicator mode)Depending on the request (Data or IndicData) data is returned in\nrecord or indicator mode. There is one Exception record returned\nfor each Exceptions.\nEndStatement 11 6 StatementNo = 2-byte integer\nEnd Request 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe ﬁrst statement is a Record parcel format containing the collection duration data that is generated once for the whole system. The following table describes this Record format.\nField/Column Name Data T ype Description\nSampleSec SMALLINT Duration of the collection period, in seconds. This value represents the collection rate.\nStatement 2\nThe second statement is a Record parcel format containing exception information for queries collected (and stored in a buffer) for the last collection period. There is one record for\neach exception. The following table describes this Record format.\nLake - Monitor Resources and Performance\nPage 288 of 420Field/Column Name Data T ype Description\nVprocID SMALLINT Vproc the request with the exception was running on.\nQuery ID BIGINT Query ID for the query that encountered an exception.\nUserName VARCHAR (128) CHARACTER SET\nUNICODEUser name used in the query with the exception.\nSessionID INTEGER Logical host ID of the query with the exception\nRequestNum SMALLINT Request number of the query with the exception\nLogicalHostID SMALLINT Logical host ID of the query with the exception.\nAcctString VARCHAR (128) CHARACTER SET\nUNICODEAccount string of the query with the exception.\nWDID INTEGER WD ID the query with the exception was running in.\nOpEnvID INTEGER Planned environment ID in force when the query encountered the exception.\nSysConID INTEGER Health condition ID in force when the query encountered the exception.\nClassiﬁcationTime FLOAT Time the query with the exception was classiﬁed.\nClassiﬁcationDate INTEGER Date the query with the exception was classiﬁed.\nExceptionTime FLOAT Time the query encountered the exception.\nExceptionDate INTEGER Date the query encountered the exception.\nExceptionValue INTEGER Type of exception that occurred:\n0x00000001 - Exception time limit exceeded.\n0x00000002 - CPU time (AMP and PE) limit exceeded.\n0x00000004 - Blocked time limit exceeded.\n0x00000008 - Disk to CPU ratio exceeded.\n0x00000010 - AMP CPU skew limit exceeded.\n0x00000020 - AMP I/O count limit exceeded.\n0x00000040 - AMP I/O skew limit exceeded.\n0x00000080 - Max row count (for a step) exceeded.\n0x00000100 - Max row count (for a query) exceeded.\n0x00000200 - Spool space limit exceeded.\n0x00000400 - Number of AMPs used in query exceeded.\n0x00000800 - Disk CPU ratio value exceeded\n0x00001000 - I/O space value exceeded.\nA conversion to hex is used to extract the bit values. For example, a value of 1024 converted\nto hex is 400.\nExceptionAction VARCHAR (10) CHARACTER SET\nLATINException action taken by the exception handler:\nA = Abort\nC = Change WD\nNewWDId contains the new WD.\nL = Log.\nE = Execute (run) Program\nExProgram contains the program name.\nT = Alert\nExAlert contains the alert name.\nN = No action\nThis option disables exception detection and cannot be combined with other actions.\nS = Abort if the statement is a SELECT and no update has been done in the current\ntransaction\nQ = Insert a row to DBC.SystemQTbl\nFor example, CE stands for change WD and run program.\nNewWDID INTEGER WD the query was moved into if the ExceptionAction was change WD.\nExceptionCode INTEGER Database exception code.\nExceptionSubCode INTEGER Code for additional information.\nThis ﬁeld is not used.\nLake - Monitor Resources and Performance\nPage 289 of 420Field/Column Name Data T ype Description\nErrorText VARCHAR (255) CHARACTER SET\nUNICODEError text generated for the exception.\nExtraInfo VARCHAR (200) CHARACTER SET\nUNICODEException values noted at the time of the exception.\nRuleID INTEGER Teradata dynamic workload management software rule ID of the rule with the exception\nhandling directive.\nWarningOnly VARCHAR (1) CHARACTER SET\nLATINIndicator that this is a warning only.\nRejectionCat SMALLINT Teradata dynamic workload management software category this query was rejected from.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a TDWM EXCEPTIONS request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 20 Request TDWM EXCEPTIONS\n0003 Data 6 MonVerID 8\n0004 Resp 6 Buffer Size 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nSubmitting request TDWM EXCEPTIONS;\nTDWM EXCEPTION successful.\n        Sample Seconds: 60\nTDWM Exceptions - # items: 3\nUser Name Req  Cat WDID  ExcptDate   ExcptTime     Code   NewWD    QueryID              ErrorText\n--------- ---- --- ----  ---------   ----------    ----   -----    ------------------   ---------------\nLUMBER     2    0  11    2009/09/28  11:05:43.00   3156            163837185173601208   CPUTime: 687ms.\nLUMBER     2    0  11    2009/09/28  11:05:57.00   3156            163837185173601276   CPUTime: 1501ms.\nLUMBER     2    0  11    2009/09/28  11:05:57.00   3156            163837185173601276   I/O: 1720.\nTDWM LIST WD\nReturns the names of the workloads.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nenabled_only SMALLINT Enabled workload names.\nThe values, 0 and 1, return enabled workload names only.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nLake - Monitor Resources and Performance\nPage 290 of 420For more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nThe TDWM LIST WD request returns the WD information from the internal cache being used by the Teradata dynamic workload management software. WDs are returned in the order\ndeﬁned for evaluation.\nParcels\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1 record for each WD being used at the time. There can a maximum of\n246.\nActivityType = 161 (PCLTWMLISTWDSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100(indicator\nmode)Depending on the request (Data or IndicData), data is returned in record or indicator\nmode. There is one WD Information record returned for each WD satisfying the\nrequest. The format of this record follows.\nEndStatement 11 6 StatementNo = 1\nEndRequest 12 4 None\nResponse\nThe following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each ﬁeld corresponds to a ResultSet column returned by the Teradata JDBC Driver.\nSee Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe following table describes the format of the WD Information Record parcel.\nField/Column Name Data T ype Description\nConﬁguration ID SMALLINT Conﬁguration ID of the current rule set.\nEnabled Flag SMALLINT Indicator that the workload is enabled.\nWLC ID INTEGER WD ID for the speciﬁed request.\nWLC Name VARCHAR (30)WD name.\nCharacters after the name length are not initialized.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a TDWM LIST WD request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name BytesField Value\n0001 Req 16 Request TDWM LIST WD\n0003 Data 4 MonVerID\nenabled_only7\n1\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nLake - Monitor Resources and Performance\nPage 291 of 420With an enabled_only value of 1, this example shows only the enabled WDs on the current system in character text format for the LIST WD request when TASM Workloads are enabled.\nYour application program may return these values in a different format.\nSubmitting request TDWM LIST WD;\nTDWM LIST WD successful.\n   \n         Config ID   : 1\n         Enable Flag : 1\n         WLC ID      : 3\n         Name Len    : 11\n         WLC Name    : WD-ConsoleH\n         Config ID   : 1\n         Enable Flag : 1\n         WLC ID      : 5\n         Name Len    : 11\n         WLC Name    : WD-ConsoleL\n         Config ID   : 1\n         Enable Flag : 1\n         WLC ID      : 4\n         Name Len    : 11\n         WLC Name    : WD-ConsoleM\n         Config ID   : 1\n         Enable Flag : 1\n         WLC ID      : 2\n         Name Len    : 11\n         WLC Name    : WD-ConsoleR\n         Config ID   : 1\n         Enable Flag : 1\n         WLC ID      : 1\n         Name Len    : 10\n         WLC Name    : WD-Default\nTDWM ST ATISTICS\nReturns statistics from the Teradata dynamic workload management software.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nRequest Flag SMALLINT Type of statistics returned:\n0 = System query counts\n1 = System session counts\n2 = System delayed queries\n3 = Workload query counts\n4 = Workload delayed queries\nThis request includes requests that are delayed due to WD throttle limits but no longer returns system\ndelay queue information.\n5= (Load and archive) utility counts\n6 = Delayed utility session information\n7 = All delay statistics\nIf you are using monitor version 13 or earlier, Request Flag requests 2, 4, and 6 are returned.\nIf you are using monitor version 14 or later, Request Flag requests 2, 4, 6, and 16 are returned.\n8 = All information\nIf you are using monitor software version 9 or earlier, Request Flag requests 1 through 7 are returned.\nLake - Monitor Resources and Performance\nPage 292 of 420Element Data T ype Description\nIf you are using monitor software version 10 through 13, Request Flag requests 1 through 7 and 9 are\nreturned.\nIf you are using monitor version 14 or later, Request Flag requests 1 through 7, 9, and 15 through 17 are\nreturned.\n9 = All active requests\n15 = Return current arrival rates. If you are using monitor version 14 or later, current rates of enabled\narrival rate meters are returned.\n16 = Arrival rate meter deferred requests\nIf you are using monitor version 14 or later, requests that are deferred due to one or more arrival rate\nmeters are returned.\n17 = Return detail current arrival rates\nIf you are using monitor version 14 or later, details about current rates of enabled arrival rate meters are\nreturned. For every ARM, the time unit is divided into 6 intervals and the numbers of arriving requests for\neach interval are returned in Statement 5 records.\nRequest Flag:\n7 is valid for monitor version software ID 8 or later.\n8 is valid for monitor version software ID 9 or later.\n9 is valid for monitor version software ID 10 or later.\n15 through 17 are valid for monitor version software ID 14 or later.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nBefore using this request, see Impact of Object Name Length on PM/API Requests.\nThe Workload Query Manager (WQM) enforces TASM rules on the number of active system sessions, system queries, workloads, workload groups, and load or archive utilities for\nspeciﬁed conditions.\nThe TDWM STATISTICS request returns information in the record formats depending on the Request_Flag supplied as described in the following table.\nThe Request_Flag in the input record determines the format of the data in the response records, and may determine the type of information contained within each statement (for\nexample, a query or session).\nThe following table speciﬁes which format types are returned.\nThese formats are deﬁned later in this section.\nRequest FlagFormat 1 Records Are\nReturnedFormat 2 Records Are\nReturnedFormat 3 Records Are\nReturnedFormat 4 Records Are\nReturnedFormat 5 Records Are\nReturned\n0 = System query counts X        \n1 = System session counts X        \n2 = System delayed requests   X      \n3 = Workload query counts X        \n4 = Workload delayed requests   X      \n5 = Utility counts     X    \n6 = Utility delayed sessions   X      \n7 = All delay information   X      \n8 = All information\nIf you are using monitor software version 9 or\nearlier, Request Flag requests 1 through 7 are\nreturned. If you are using monitor software\nversion 10 or later,Request Flag requests 1\nthrough 7 and 9 are returned. If you are using\nmonitor version 14 or later, Request FlagX X X X X\nLake - Monitor Resources and Performance\nPage 293 of 420Request FlagFormat 1 Records Are\nReturnedFormat 2 Records Are\nReturnedFormat 3 Records Are\nReturnedFormat 4 Records Are\nReturnedFormat 5 Records Are\nReturned\nrequests 1 through 7, 9, and 15 through 17 are\nreturned.\n9 = All active requests       X  \n15 = Arrival rate meter counts X        \n16 = Arrival rate meter deferred requests   X      \n17 = Detail arrival rate meter counts         X\nCLIv2 Response Parcels\nThe following is the Parcel Sequence returned if Request Flag 0 through 7 is requested. Only one parcel is returned.\nStatement 1, Statement 2, Statement 3, or Statement 4 is returned depending on the Request Flag. Because a system query, system session, or utility throttle can be affected by\nmultiple rules, multiple rows can be returned for requests 2, 4, 6, 7, 8, and 9.\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1, 2, or 3\nActivityCount = Not applicable\nActivityType = 132 (PCLTWMSTATSSTMT)\nDataInfo 71 6 to 64100 Optional; this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n6 to 64100 (indicator\nmode)Depending on the request (Data or IndicData), data is returned in record or indicator mode.\nThis record contains information in StatementNo-1, StatementNo-2, or StatementNo-3 data\nformat, depending on the Request Flag in the input data. There is one Record parcel for\neach item being tracked by the WQM. If there are no qualifying records, no Record parcel\nis sent.\nEndStatement 11 6 StatementNo = 2-byte integer=1, 2, or 3\nEndRequest 12 4 None\nThe following Parcel Sequence is returned if Request Flag is 8 or 9 and the monitor version software ID is 10 or greater.\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = number of queries with applicable statistics\nActivityType = 132 = PCLTWMSTATSSTMT\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n7 to 64100 (indicator\nmode)Depending on the request (Data or IndicData) data is returned in record or indicator mode.\nThis record contains information in StatementNo-1. There is one record parcel for each item\nbeing tracked by the WQM. If there are no qualifying records, no record parcel is sent.\nEndStatement 11 6 StatementNo = 2-byte integer = 1\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = number of queries with applicable statistics\nActivityType = 132 = PCLTWMSTATSSTMT\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record\nmode)\n7 to 64100 (indicator\nmode)Depending on the request (Data or IndicData) data is returned in record or indicator mode.\nThis record contains information in StatementNo 2. There is one record parcel for each item\nbeing tracked by the WQM. If there are no qualifying records, no record parcel is sent.\nEndStatement 11 6 StatementNo = 2-byte integer = 2\nSuccess 8 18 to 273 StatementNo = 3\nActivityCount = number of queries with applicable statistics\nLake - Monitor Resources and Performance\nPage 294 of 420Parcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nActivityType = 132 = PCLTWMSTATSSTMT\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record\nmode)\n7 to 64100 (indicator\nmode)Depending on the request (Data or IndicData) data is returned in record or indicator mode.\nThis record contains information in StatementNo 3. There is one record parcel for each item\nbeing tracked by the WQM. If there are no qualifying records, no record parcel is sent.\nEndStatement 11 6 StatementNo = 2-byte integer = 3\nSuccess 8 18 to 273 StatementNo = 4-byte\nActivityCount = number of queries with applicable statistics\nActivityType = 132 = PCLTWMSTATSSTMT\nRecord 10\n5 to 64100 (record\nmode)\n7 to 64100 (indicator\nmode)Depending on the request (Data or IndicData) data is returned in record or indicator mode.\nThis record contains information in StatementNo 4. There is one record parcel for each item\nbeing tracked by the WQM. If there are no qualifying records, no record parcel is sent.\nEndStatement 11 6 StatementNo = 2-byte integer = 4\nEndRequest 12 4 None\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe ﬁrst statement is a Record parcel format containing statistical information for one system query, system session, or workload item. There is one record for each item that is being\ntracked by the Teradata dynamic workload management software. The following table describes this Record format.\nField/Column Name Data T ype Description\nRecord Type SMALLINT Type of information contained in this record:\n1 = User\n2 = Account String\n4 = Account String\n5 = Proﬁle\n6 = Client ID\n7 = Network Address\n8 = Application\n9 = Collective Rule\n10 = Database\n11 = Table\n12 = WD\n13 = Utility\n14 = Macro\n15 = Stored Procedure\n16 = View\n17 = QueryBand\n18 = Function\n19 = Method\n20 = Virtual partition\n21 = Reserved\n22 = Server\n23 = AWT Resource Limit\n24 = Arrival Rate Meter\n25 = Memory Resource Limit\nLake - Monitor Resources and Performance\nPage 295 of 420Field/Column Name Data T ype Description\nRule ID INTEGER Rule ID for the system query, system session, or workload for this statistic.\nIf Request Flag is 0 or 1, Rule ID returns the ID of the system query or system session throttle rule.\nIf the Request Flag is 3, Rule ID returns the ID of the workload.\nIf Record Type is 24, Rule ID returns the ID of the arrival rate meter.\nObject Name VARCHAR (128) CHARACTER SET\nUNICODEFor Request Flags 0 and 1, this is the name of the system query or system session throttle rule\nbased on its Record Type. When Record Type is set to 11, 14, 15, 16, 18, or 19, this ﬁeld is the\nqualifying database name for the Table Name ﬁeld.\nFor Request ﬂag 3, this ﬁeld is empty.\nQualiﬁed Name VARCHAR (128) CHARACTER SET\nUNICODEFor Request Flags 0 and 1, this is the name of the table, macro, stored procedure, function or\nmethod object when Record Type is set to 11, 14, 15, 16, 18, or 19.\nFor Request Flag 3, this ﬁeld is empty.\nActive INTEGER Number of requests active. This is the number of active queries or sessions depending on the\ninformation requested in the input record.\nIf Record Type is 24, Active returns the current arrival rate for the time unit speciﬁed in the TimeUnit\nﬁeld.\nIf Record Type is 25, this value is the current total memory usage, in megabytes, of active requests\nthat qualify for this memory resource limit.\nLimit INTEGER Current minimum limit on this item. This is the limit on the number of queries or sessions depending\non the information requested in the input record.\nIf Record Type is 24, Limit returns the current arrival rate limit for the time unit speciﬁed in the\nTimeUnit ﬁeld. A value of 1 indicates that no limit is deﬁned.\nIf Record Type is 25, this value is the memory limit, in megabytes, for requests that qualify for this\nmemory resource limit rule.\nDelayed INTEGER Number of requests delayed (queued) for this item.\nThis ﬁeld is not applicable if Request Flag is 1.\nIf Record Type is 24, Delayed returns the number of requests in the Defer queue for this arrival rate\nmeter. This value is not meaningful when Limit is -1.\nRule Name VARCHAR (30) CHARACTER SET\nUNICODERule name for the system query or system session throttle rule, or workload for this statistic.\nIf Request Flag is 0 or 1, Rule Name returns the name of the system query or system session throttle\nrule is returned.\nIf the Request Flag is 3, Rule Name returns the name of the workload.\nIf Record Type is 24, RuleName returns the name of the arrival rate meter.\nStatistic Type INTEGER Type of statistics returned:\n0 = Query data\n1 = Logon data\n2 = Workloads\nThis ﬁeld is only valid on monitor version software ID 8 or later.\nFlexEligible SMALLINT The delayed request that is in a workload and is tagged as eligible for the Flex Throttle feature.\nFlagged requests must meet all requirements for Flex Throttles before being released, such as\nsystem throttle restrictions.\n0 = Flex eligible\n1 = Not Flex eligible\nTimeUnit SMALLINT If Record Type is 24, this ﬁeld is the time unit of this arrival rate meter:\n1 = second\n2 = minute\n3 = hour\nIf Record Type is not 24, this ﬁeld is not meaningful.\nLake - Monitor Resources and Performance\nPage 296 of 420Field/Column Name Data T ype Description\nRequired Qualiﬁcation Time INTEGER If Record Type is 24, Required Qualiﬁcation Time returns the number of seconds in which the\ncurrent arrival rate must continuously remain at the limit before new requests are held in the Defer\nqueue. Zero means the limit is enforced when reached.\nIf Record Type is not 24, this ﬁeld is not meaningful.\nCurrent Qualiﬁcation Time INTEGER If Record Type is 24, Current Qualiﬁcation Time returns the number of seconds in which the current\narrival rate has continuously remained at the limit. A value of zero indicates the limit has not been\nreached.\nIf Record Type is not 24, this ﬁeld is not meaningful.\nSample Output - Statement 1: Using TDWM ST ATISTICS with Request Flag Set to 0\nIf a Request Flag of zero (system query counts) is requested, the following is an example of the records that are returned as part of the ﬁrst statement.\nRecordType   Rule ID  Obj Name    Qual Name  Active  Limit  Delayed\n----------   -------  --------    ---------  ------  -----  -------\n1          0       Ken                4      5     0\n1          0       Dina               2      4     0\n2          0       Sales              3      10    0\n2          0       PreSales           2      10    0\n2          0       Training           3      3     10\nThis example shows the following important information:\nTwo users running (Record Type 1) also have rules deﬁned on the number of queries they are allowed to have running simultaneously (Limit).\nThree accounts running (Record Type 2) and also have rules deﬁned on the number of queries they are allowed to have running simultaneously (Limit).\nBecause the input requested query information (a Request_Flag of zero), the numbers shown reﬂect the number of active queries for each user and account. If logon information is\nrequested (a Request_Flag of 1) in the input, the records look the same. However, the numbers shown reﬂect the number of active sessions within the restricted area.\nItems that are restricted, but are not active on the system, or are bypassed, are not returned.\nSample Output - Statement 1: Using TDWM ST ATISTICS with T ables Restricted (RecordT ype 1 1)\nIf Tables are restricted, the following records are returned:\nRecordType Rule ID  Obj Name    Qual Name    Active Name   Limit  Delayed\n---------  -------  --------    ---------    -----------   -----  -------\n11         0        Employee    PayrollDB    2             10     0\n11         0        Leads       MaketingDB   1             1      1\nSample Output - Statement 1: Using TDWM ST ATISTICS with Request Flag Set to 3\nIf WDs (Request Flag 3) are requested, the following records are returned:\nRecordType  Rule ID  Obj Name    Qual Name    Active Name   Limit  Delayed\n----------  -------  --------    ---------    -----------   -----  -------\n12          03       TacticalWD               4             100    0\n12          05       StrategicWD              2             2      1\n12          05       AdHocWD                  0            -1      0\n-1 limit means that there is no limit.\nSample Output - Statement 1: Using TDWM ST ATISTICS with Request Flag Set to 8\nIf Request Flag 8 is requested, the following records are returned:\nRecordType  Rule ID  Obj Name    Qual Name    Active   Limit  Delayed  Rule Name    Stat Type\n----------  -------  --------    ---------    ------   -----  -------  ---------    --------\n0           0        Ken                      4        5      0\n0           0        Dina                     2        4      0\n1           0        Sales                    3        10     0\n1           0        Presales                 2        10     0\n1           0        Training                 3        3      10      LimitTraining\n2           0        H                        6        6      2\n2           0        H2                       1        1      0\n11          0        Employee    PayrollDB    2        10     0\n11          0        Leads       MaketingDB   1        1      1\n12          3        TacticalWD               44       100    0\n12          5        StrategicWD              2        2      1\nLake - Monitor Resources and Performance\nPage 297 of 42012          5        AdHocWD                  0        -1     0\n24        117                                10        10     5       ARM_1\nSample Output - Statement 1: Using TDWM ST ATISTICS with Record T ype Set to 25\nRecordType Rule ID Obj Name Qual Name Active Name Limit  Delayed Rule Name\n---------- ------- -------- --------- ------ ---- -----  ------- -------------------\n        25      38                            972  1067        7 TD_UnderEstMemLimit\nStatement 2\nThe second statement is a Record parcel format containing information about queries or sessions being delayed by the Teradata dynamic workload management software due to a\nsystem query, system session, workload or utility throttle limit. If Request Flag 7 is requested, one record for each request or session that is being delayed is returned with one Rule ID.\nMultiple rows are returned if the request has more than one rule causing its delay.\nIf Request Flag 16 is requested, the record parcel reports similar information about queries being deferred due to one or more arrival rate meters. If a request is deferred due to\nmultiple arrival rate meters, one row is returned for each rule causing its deferral.\nThe following table describes this Record format.\nField/Column Name Data T ype Description\nUser name VARCHAR (128) CHARACTER SET\nUNICODELogon user name of session.\nHostId SMALLINT Host ID of the session number for the delayed request or session.\nSession Number INTEGER Number for the held request or session.\nRequest Number INTEGER Request number for the delayed request or session.\nThis ﬁeld is zero if Request Flag is 6.\nRule Name VARCHAR (30) CHARACTER SET\nUNICODERule name for the system query or session throttle rule, workload, or arrival rate meter rule for this\nstatistic.\nIf Request Flag is 2 or 6, Rule Name is the name of the system query or system session throttle rule.\nIf Request Flag is 4, Rule Name returns the name of the workload.\nIf Request Flag is 9, Rule Name and all remaining ﬁelds are empty, except for Rule Type.\nIf Request Flag is 16, Rule Name is the name of the arrival rate meter rule.\nRule ID INTEGER Rule ID for the system query or system session throttle, workload, or arrival rate meter for this statistic.\nIf Request Flag is 2 or 6, Rule ID returns the ID of the system query or system session throttle rule.\nIf Request Flag is 4, Rule ID returns the ID of the workload.\nThis Rule ID must be supplied in the Abort/Release interface (when used). If the Request Flag is 6, Rule\nID is zero.\nIf Request Flag is 16, Rule ID returns the ID of the arrival rate meter rule.\nTotal Time Held INTEGER Total number of wall clock seconds that this request or session has been held by the WQM.\nIf Rule Type is 6, returns the total number of wall clock seconds that this request has been held in the\nDefer queue due to one or more arrival rate meters.\nOverridable Boolean Indicator that the database administrator is allowed to stop or release the request.\nThe queue table requests are controlled internally by the database and cannot be altered by the\nadministrator.\nIf Request Flag is 6, this ﬁeld indicates if the delayed session can be released. A session cannot be\nreleased if it exceeds the internal AMP worker task limit or an internal utility limit.\nA delayed session can be aborted.\nBlocking Count INTEGER Number of consecutive times that this session has been identiﬁed as blocking at least one other\nsession.\nIf Request Flag is 6, Blocking Count is zero.\nIFP ID SMALLINT ID of the PE vproc that initiated this request.\nWD Delayed INTEGER\n1 = Query is delayed for a workload throttle rule.\nLake - Monitor Resources and Performance\nPage 298 of 420Field/Column Name Data T ype Description\n0 = Query is not delayed for a workload throttle rule.\nThis ﬁeld is only valid on monitor version software ID 8 or later.\nSystem Delayed INTEGER\n1 = Query is delayed for a system query or system session throttle rule.\n0 = Query is not delayed for a system query or system session throttle rule.\nThis ﬁeld is only valid on monitor version software ID 8 or later.\nUtility Delayed INTEGER\n1 = Query is delayed for a utility throttle rule.\n0 = Query is not delayed for a utility throttle rule.\nThis ﬁeld is only valid on monitor version software ID 8 or later.\nRule Type INTEGER Rule type for the request:\n0 = Workload\n1 = System\n2 = Utility\n3 = Workload Group *\n4 = Virtual Partition *\n5 = Resource Limit (AWT or Memory)** ****\n6 = Arrival Rate Meter ***\nThe Rule Type ﬁeld is only valid on monitor version software ID 8 or later.\n* Workload Group 3 and Virtual Partition 4 are returned in Monitor Version 11 and later.\n** Resource Limit (AWT) is returned in Monitor Version 12 and later.\n**** Resource Limit (Memory) is returned in Monitor Version 14 and later.\n*** Arrival Rate Meter is returned in monitor version 14 and later.\nGroup Delayed INTEGER\n1= Query is delayed for a workload group throttle.\n0= Query is not delayed for a workload group throttle.\nThis ﬁeld is only valid on monitor version software ID 10 or later.\nFlexEligible SMALLINT The delayed request that is in a workload and is tagged as eligible for the Flex Throttle feature. Flagged\nrequests must meet all requirements for Flex Throttles before being released, such as system throttle\nrestrictions.\n0 = Flex eligible\n1 = Not Flex eligible\nArrival Rate Meter Deferred INTEGER\n1 = Query is deferred due to an arrival rate meter rule.\n0 = Query is not deferred due to an arrival rate meter rule.\nSample Output - Statement 2: Using TDWM ST ATISTICS with Request Flag Set to 6\nIf a Request Flag of 6 is requested, the following Records are returned as part of the second statement:\nUser Name  Host ID  Sess  Req Nbr  Rule Name  Rule ID  Total TimeHeld  Over  Block\n---------  -------  ----  -------  ---------  -------  --------------  ----  -----\nKen        01       1012  0                   0        45              True  0\nDina       01       1088  0                   0        110             True  0\nThis report indicates that 2 sessions are being delayed due to a system query or system session throttle limits.\nSample Output - Statement 2: Using TDWM ST ATISTICS with Request Flag Set to 7\nIf a Request Flag of 7 is requested, the following Records are returned as part of the second statement:\nUser Name  Host ID  Sess  Req Nbr  Rule Name  Rule ID  Total TimeHeld  Over  Block\n---------  -------  ----  -------  ---------  -------  --------------  ----  -----\nKen        01       1013  1                   4        15              True  0\nKen        01       1013  1                   5        15              True  0\nDina       01       1089  0                   4        110             True  0\nThis report indicates that 2 requests are being delayed, but the ﬁrst request has two rules that are causing its delay.\nSample Output - Statement 2: Using TDWM ST ATISTICS with Request Flag Set to 16\nLake - Monitor Resources and Performance\nPage 299 of 420User Name Host ID Sess Req Nbr Rule Name Rule ID Total TimeHeld Over Block \n--------- ------- ---- ------- --------- ------- -------------- ---- ----- \nUSER1     1       4734 2       ARM_1     117     17             True 0\nSample Output - Statement 2: Using TDWM ST ATISTICS with Rule T ype Set to 5\nIn this example, rule type values of 5 are translated to 'Res' (Resource Limit).\nUser Name      Host Sess   Req Nbr Rule Name      Rule ID TimeHeld Type\n-------------- ---- ------ ------- -------------- ------- -------- ----\nIMHJ_CP_FANOUT    1 278632      11 TD_UnderEstMem      38       42 Res\nIMHJ_CP_FANOUT    1 279398      10 TD_UnderEstMem      38       42 Res\nStatement 3\nThe third statement is a Record parcel format containing information on the load utilities that are active in the system. There is one record for every load utility type.\nThis statement is only returned when utility statistics are requested. The following table describes this record format.\nField/Column Name Data T ype Description\nUtility Type SMALLINT Type of utility information contained in this record:\n0 = MultiLoad + FastLoad\n1 = MultiLoad\n2 = FastLoad\n3 = FastExport\n4 = ARC\n5 = Standalone Mload\n6 = Standalone FastLoad\n7 = Standalone FastExport\n8 = TPT update Op: MultiLoad\n9 = TPT load Op: Fastload\n10 = TPT export Op: FastExport\n11 = JDBC MultiLoad\n12 = JDBC FastLoad\n13 = JDBC FastExport\n14 = CSP Save Dump (FastLoad)\n15 = DSA\n16 = DSA Backup\n17 = DSA Restore\n18 = MLOADX\nCount SMALLINT Number of utilities of this utility type that are active.\nLimit SMALLINT Current limit on the number of utilities of this type.\nA value of -1 indicates there is no limit deﬁned.\nSample Output - Statement 3: Using TDWM ST ATISTICS\nThe following is an example of the records that are returned as part of third statement:\n TYPE  COUNT  LIMIT\n ----  -----  -----\n    0      0     30\n    1      0     30\n    2      0     30\n    3      0     60\n    4      0    350\n    5      0     30\n    6      0     30\n    7      0     60\n    8      0     30\n    9      0     30\n   10      0     60\n   11      0     30\n   12      0     30\n   13      0     60\n   14      0     30\nBecause a row is returned for each utility type, the Limit value can be either the system default value for the utility or a TASM rule Throttle value.\nAn active TASM rule Throttle value overrides the default limit.\nLake - Monitor Resources and Performance\nPage 300 of 420Statement 4\nThe fourth statement is a Record parcel format containing information about queries, sessions, and so on being counted as active by the Teradata dynamic workload management\nsoftware due to a system query, system session, workload, workload group, or utility throttle rule.\nMultiple rows in this statement are returned if the request has more than one rule counted as active.\nThis statement is not a count of all active queries in the system.\nField/Column Name Data T ype Description\nUser name VARCHAR (128) CHARACTER SET\nUNICODELogon user name of session.\nHostId SMALLINT Session number ID for the active request.\nSession Number INTEGER Session number for the active request.\nRequest Number INTEGER Request number for the active request.\nInternal Request Number INTEGER Internal AMP request number for the active request.\nRule Name VARCHAR(30) CHARACTER SET\nUNICODERule name for the active request.\nRule Id INTEGER Rule ID for the active request.\nRule Type INTEGER Rule type for the request:\n0 = Workload class\n1 = System query\n2 = System session\n3 = Utility throttle\n4 = Workload group\n5 = Virtual Partition *\n6 = Resource Limit (AWT or Memory) ** ***\n* Virtual Partition 5 is returned in Monitor Version 11 and later.\n** Resource Limit (AWT) is returned in Monitor Version 12 and later.\n*** Resource Limit (Memory) is returned in Monitor Version 14 and later.\nStatement Type INTEGER Type of active request:\n0 = Session\n1 = Query\n2 = Call\n3 = Unit of work\nTime Active INTEGER Total number of wall clock seconds that this request has been active.\nActiveThrottleBypassed SMALLINT Whether an active request is active solely due to the ThrottleBypass ruleset\nattribute. This attribute overrides the throttle limits if the session owning the\nrequest has an object lock higher than the Access level. Possible values include:\n0 = This value indicates one of the following:\nThe ThrottleBypass ruleset attribute is not active.\nThe throttle limit is lower than the Access level.\nThe throttle limit is not speciﬁed.\n1 = The ThottleBypass ruleset attribute is active.\nFlexReleased SMALLINT An active request running due to the Flex Throttle feature.\n0 = not Flex released\n1 = Flex released\nSample Output - Statement 4: Using TDWM ST ATISTICS with Active Query Requests\nThe following example shows two active query requests. One of the active query requests is due to a TASM Workload rule and one is due to a TASM Utility throttle rule.\nTDWM Stats - Active items: 2\nUSERNAME HOST SESSION REQ INTREQ  RULEID / NAME TYPE    STMTTYPE ACTIVETIME\n-------- ---- ------- --- ------- ------------- -----   -------- ----------\nLake - Monitor Resources and Performance\nPage 301 of 420TEST1    1025  1000    6     6     (15)WD-ALT   WD        1       7\nTEST1    1025  1000    6     6     (13)WD-GRP1  Util/Ses  1       7\nSample Output - Statement 4: Using TDWM ST ATISTICS with Flex Throttle Query Requests\nThe following example shows active query requests, including requests released to run by the Flex Throttle feature.\nActive Requests: \nHOST  SESSION INT REQ  TYP DEP  USER NAME  RULE TYPE (ID) NAME  ACTIVE ... FLEXRELD\n/QUERYID \n----  ------- -------  --- ---  ---------  -------------------  ------ --- --------\n  1     22638       2  QRY   1  KEN9          WLC( 99)WD-9         349                   \n307193492630017729 \n  1     22643       2  QRY   1  KEN8          WLC( 98)WD-8         346                   \n307183492630017055 \n  1     22648       2  QRY   1  KEN7          WLC( 97)WD-7         345                   \n307193492630017748 \n  1     22655       2  QRY   1  KEN5          WLC( 95)WD-5         340                   \n307183492630017095 \n  1     22655       2  QRY   1  KEN5          WLG( 90)WD-GRP45     340                   \n307183492630017095 \n  1     22663       2  QRY   1  KEN3          WLC( 93)WD-3         337                   \n307183492630017124 \n  1     22664       2  QRY   1  KEN3          WLC( 93)WD-3         321        YES\n307193492630017784 \n  1     22647       2  QRY   1  KEN7          WLC( 97)WD-7         261        YES\n307183492630017065 \n  1     22642       2  QRY   1  KEN8          WLC( 98)WD-8         201        YES\n307193492630017738 \n  1     22644       2  QRY   1  KEN8          WLC( 98)WD-8         141        YES\n307193492630017739 \n  1     22637       2  QRY   1  KEN9          WLC( 99)WD-9          81        YES\n307183492630017034 \nSample Output - Statement 4: Using TDWM ST ATISTICS with Rule T ype Set to 6\nIn this example, rule type values of 6 are translated to 'Res' (Resource Limit).\nUSERNAME       HOST SESSION REQ INTREQ RULEID / NAME      TYPE     STMTTYPE ACTIVETIME\n-------------- ---- ------- --- ------ ------------------ -------- -------- ----------\nIMHJ_CP_FANOUT 1025  262036 19      19 (36)Throttle_ALL    Obj/Qry        1          5\nIMHJ_CP_FANOUT 1025  262036 19      19 (38)TD_UnderEstMem  Res            1          5\nStatement 5\nStatement 5 record format returns detailed information about each arrival rate meter. An arrival rate is represented as a request count per time unit. Each time unit is divided into six\nﬁxed intervals. Each row and record contains information for one interval. Therefore, there are six rows for each arrival rate meter.\nField Name Data T ype Description\nRule Type INTEGER Rule type for the request:\n0 = Arrival Rate Meter\nRule Id INTEGER ID of the arrival rate meter.\nRule Name VARCHAR (30) CHARSET UNICODE Name of the arrival rate meter.\nInterval Number INTEGER Interval number.\nInterval Start Date INTEGER Start date of this interval.\nInterval Start Time FLOAT Start time of this interval.\nRequest Count INTEGER Number of requests admitted in this interval.\nHost ID SMALLINT HOST ID of the ﬁrst request in this interval.\nSession Number INTEGER Session number of the ﬁrst request in this interval.\nRequest Number INTEGER Request number of the ﬁrst request in this interval.\nInternal Request Number INTEGER Internal request number of the ﬁrst request in this interval.\nSample Output - Statement 5\nLake - Monitor Resources and Performance\nPage 302 of 420TDWM Stats - ARM detail count items: 12\nTYPE RULE (ID) NAME     ITVL START DATE  START TIME  COUNT HOST SESSION REQ    INTREQ\n---- ------------------ ---- ----------  ----------- ----- ---- ------- ------ ------\nARM  (118)ARM_2            1 2018/08/03  16:10:00.00     0    0       0      0      0\nARM  (118)ARM_2            2 2018/08/03  16:30:00.00     2    1    5909      4      4\nARM  (118)ARM_2            3 2018/08/03  16:40:00.00     8    1    6184      3      3\nARM  (118)ARM_2            4 2018/08/03  16:50:00.00     8    1    6676      3      3\nARM  (118)ARM_2            5 2018/08/03  17:00:00.00     6    1    7138      3      3\nARM  (118)ARM_2            6 2018/08/03  17:10:00.00     2    1    7366      3      3\nARM  (117)ARM_1            1 2018/08/03  17:10:30.00    40    1    7334      4      4\nARM  (117)ARM_1            2 2018/08/03  17:10:40.00    17    1    7355      3      3\nARM  (117)ARM_1            3 2018/08/03  17:10:50.00     0    0       0      0      0\nARM  (117)ARM_1            4 2018/08/03  17:11:00.00     0    0       0      0      0\nARM  (117)ARM_1            5 2018/08/03  17:11:10.00     0    0       0      0      0\nARM  (117)ARM_1            6 2018/08/03  17:11:20.00    33    1    7362      4      4\nTDWM SUMMAR Y\nReturns the Teradata dynamic workload management software WD summary data ﬁelds.\nInput Data\nField Name Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nThere is one record per WD active in the system. The record contains counts of the number of queries that were classiﬁed into the WD in the collection period and the number of\nqueries that completed in the collection period with query statistics.\nThe TDWM Summary request returns information for all queries completed in the dashboard interval for the WDs.\nIf TASM Workloads are not enabled, only the ﬁrst statement is returned.\nCLIv2 Response Parcels\nThe TDWM SUMMARY request is treated internally as a two statement request, with each statement generating a response. The two statement response returned from the database\ncontains the following sequence of parcel types:\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 156 (PCLTWMSUMMARYSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record mode)\n6 to 64100 (indicator mode)Depending on the request (Data or IndicData), data is returned in record or indicator\nmode.\nThis is the only record returned.\nLake - Monitor Resources and Performance\nPage 303 of 420Parcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nEndStatement 11 6 StatementNo = 2-byte integer\nSuccess 8 18 to 273 StatementNo = 2\nActivityCount = number of record parcels returned\nActivityType = 134 (PCLTDWMSUMSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on the request (Data or IndicData), data is returned in record or indicator\nmode. There is one Summary Data record returned for each active WD. The format of\nthis record follows.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nEach of the following statement types corresponds to a ResultSet returned by the Teradata JDBC Driver, and each statement type ﬁeld corresponds to a ResultSet column. For more\ninformation on ResultSets, see Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nStatement 1\nThe response to the ﬁrst statement returns a Record parcel containing the SampleSec ﬁeld.\nField/Column Name Data T ype Description\nSampleSec SMALLINT Duration of the collection period, in seconds. This value represents the collection rate.\nStatement 2\nThe response to the second statement returns a Record parcel that consists of summary information for an active WD in the system collected in the last collection period. There is one\nrecord for each WD.\nIf TASM Workloads are not enabled, this statement is not returned.\nThe following table describes the format of the Summary Data Record parcel.\nField/Column Name Data T ype Description\nWD ID INTEGER WD ID.\nArrivals INTEGER Number of queries that were classiﬁed into this WD by the Teradata dynamic workload\nmanagement software.\nCompletions INTEGER Number of queries that completed in this WD in this dashboard or logging interval with:\nNo error code or an error code of 3158\nNo abort ﬂag\nEither an AMP count of > 0 or a Parser CPU > 0\nMinimum Response Time FLOAT Minimum response time in centiseconds of any query.\nMaximum Response Time FLOAT Maximum response time in centiseconds for any query.\nAverage Response Time FLOAT Average response time in centiseconds for this workload based on the total response\ntime of all completions divided by number of completions.\nMinimum CPU Time FLOAT Minimum CPU in milliseconds of all the queries that completed in this workload in this\ndashboard or logging interval, where CPU is the minimum CPU used by any one AMP of\nthe query plus the Parser CPU time used by that same query.\nMaximum CPU Time FLOAT Maximum CPU in milliseconds of all the queries that completed in this workload in this\ndashboard or logging interval, where CPU is the maximum CPU used by any one AMP of\nthe query plus the Parser CPU time used by that same query.\nAverage CPU Time FLOAT Running total in milliseconds of Parser CPU time plus the total AMP CPU of each query\nthat completed in this workload divided by the number of completions of queries in this\nworkload in this dashboard or logging interval.\nDelayed Count INTEGER Number of queries that are delayed in this WD.\nAverage Delay Time FLOAT Average delay time in centiseconds for all queries assigned to this WD.\nException Count INTEGER Number of queries with exceptions in this WD.\nLake - Monitor Resources and Performance\nPage 304 of 420Field/Column Name Data T ype Description\nMet SLG Count INTEGER Number of queries that met WD Response Time SLG requirements.\nIf the WD does not have Response Time SLG requirement, the query is still counted as\nmet.\nActive Query Count INTEGER Number of active queries assigned to this WD.\nActive Delayed Count INTEGER Number of delayed queries in this WD.\nError Count INTEGER Number of queries that ﬁnished in this WD in this dashboard or logging interval with an\nerror code > 0 but not 3158 or 3156.\nAbort Count INTEGER Number of queries that ﬁnished in this WD in this dashboard or logging interval with an\nerror code of 0 or 3156 and an abort ﬂag.\nOther Count INTEGER Number of queries that ﬁnished in this WD in this dashboard or logging interval with no:\nError code\nAbort ﬂag\nAMP count\nParser CPU\nCollectionDate DATE Date of the collection of summary information as pulled from the StartCollectTime ﬁeld on\nthe control vproc.\nCollectionTime FLOAT Time of the collection of summary information as pulled from the StartCollectTime ﬁeld on\nthe control vproc.\nExceptionAbCnt INTEGER Number of queries that aborted due to a TDWM exception.\nExceptionMvCnt INTEGER Number of queries that were moved into this WD due to an exception.\nExceptionCoCnt INTEGER Number of queries that raised an exception but continued in this WD.\nIntervalDelayCnt INTEGER Number of queries that were delayed in this WD during this interval.\nRejectedCount INTEGER Number of queries that were rejected by TDWM due to a ﬁlter or throttle rule violation.\nMovedInCount INTEGER Number of queries that were moved into this WD either due to an exception action or\nmanual move using PMPC.\nVirtualPartNum INTEGER Virtual Partition number of the WD.\nAvgIOWaitTime FLOAT Average duration of sleeps in milliseconds due to the I/O rate handling over the life of all\nrequests completing in this WD during this interval.\nMaxIOWaitTime FLOAT Maximum duration of sleeps in milliseconds due to the I/O rate handling of a request\ncompleting in this WD during this interval.\nAvgOtherWaitTime FLOAT This ﬁeld is reserved for future use.\nMaxOtherWaitTime FLOAT This ﬁeld is reserved for future use.\nAvgCPURunDelay FLOAT Average wait time in milliseconds in the run queue of all the requests completing in this\nWD during this interval.\nMaxCPURunDelay FLOAT Maximum wait time in milliseconds in the run queue of a request completing in this WD\nduring this interval.\nAvgSeqRespTime FLOAT Average of the sum of the response times of the steps (as if all steps had been run\nsequentially) of all the requests completing in this WD during this interval, in milliseconds.\nMaxSeqRespTime FLOAT Maximum sum of the response times of the steps (as if all steps had been run\nsequentially) of a request completing in this WD during this interval, in milliseconds.\nAvgLogicalIO FLOAT Average count of logical I/Os of all requests completing in this WD during this interval.\nMaxLogicalIO FLOAT Maximum count of logical I/Os for a request completing in this WD during this interval.\nAvgLogicalKBs FLOAT Average logical I/O in KB of all requests completing in this WD during this interval.\nMaxLogicalKBs FLOAT Maximum logical I/O usage in KB of all requests completing in this WD during this interval.\nAvgPhysicalIO FLOAT Average count of physical I/Os of all requests completing in this WD during this interval.\nMaxPhysicalIO FLOAT Maximum physical I/O usage of all requests completing in this WD during this interval.\nAvgPhysicalKBs FLOAT Average physical I/O usage in KB of all requests completing in this WD during this\ninterval.\nMaxPhysicalKBs FLOAT Maximum physical I/O usage in KB for a request completing in this WD during this\ninterval.\nThrottleBypassed INTEGER The number of queries reported in the Completions ﬁeld that were allowed to run due to\nthe TASM ThrottleBypass ruleset attribute.\nLake - Monitor Resources and Performance\nPage 305 of 420Field/Column Name Data T ype Description\nFlexActive INTEGER The number of queries that are active in the system that were released by the Flex Throttle\nfeature.\nFlexComplete INTEGER The number of queries that were released by the Flex Throttle feature that completed\nduring this period.\nFlexArrivals INTEGER The number of new requests that became active due to Flex Throttle feature.\nDefer Count INTEGER Number of queries that are deferred in this WD due to an arrival rate meter rule.\nAvg Defer Time FLOAT Average defer time due to arrival rate meter rules in centiseconds for all queries assigned\nto this WD.\nActive Defer Count INTEGER Number of deferred queries in this WD.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a TDWM SUMMARY request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name BytesField Value\n0001 Req 16 Request TDWM SUMMARY\n0003 Data 96 MonVerID 9\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe following example shows the data returned by the TDWM SUMMARY request. Your application program may return this data in a different format or display.\nYou must enable TASM Workloads to submit a TDWM SUMMARY request.\nThe TDWM SUMMARY request reports WD statistics over a given period. As shown in this example of WD activity returned from the API call, queries are classiﬁed into WDs 1 and 3\nand not WDs 2, 4, and 5.\nSUCCESS parcel:\nStatementNo=1,    ActivityCount=1,\nActivityType=156, FieldCount=1\nTDWM Summary Request successful.\n         Sample Seconds: 120\nSUCCESS parcel:\nStatementNo=2,    ActivityCount=5,\nActivityType=156, FieldCount=43\nTDWM Summary - # of WDIds: 5\n  WLC   Arrivals  Complete  WereDlyd  Exceptns  Met SLG  CurrActv  CurrDlyd  Abt Cnt   Othr Cnt\n   ID   Min Resp  Max Resp  Avg Resp  Min CPU   Max CPU   Avg CPU  AvgDelay  Err Cnt\n        Collection Date/Time\n-----   --------  --------  --------  --------  --------  --------  --------  --------  --------\n   12          0         0         0         0         0         1         0\n    0          0\n             0.0       0.0       0.0       0.0       0.0       0.0       0.0\n    0\n         2011/06/15 18:33:49.00\n   13          0         0         0         0         0         0         0\n    0          0\n             0.0       0.0       0.0       0.0       0.0       0.0       0.0\n    0\n         2011/06/15 18:33:49.00\n   14          0         0         0         0         0         0         0\n    0          0\n             0.0       0.0       0.0       0.0       0.0       0.0       0.0\n    0\n         2011/06/15 18:33:49.00\n   15          0         0         0         0         0         0         0\n    0          0\n             0.0       0.0       0.0       0.0       0.0       0.0       0.0\nLake - Monitor Resources and Performance\nPage 306 of 420    0\n         2011/06/15 18:33:49.00\n   16          0         0         0         0         0         0         0\n    0          0\n             0.0       0.0       0.0       0.0       0.0       0.0       0.0\n    0\n         2011/06/15 18:33:49.00\nTDWM WD ASSIGNMENT\nChanges the Workload a session or request is assigned to.\nInput Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLIN\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT Host on which the session was established. The host ID cannot exceed 1023. A host ID of zero identiﬁes\nthe database operator Console.\nsession_no INTEGER Session number for record. This value is assigned by the host (or client) at logon.\nWith a given Host ID, a session number uniquely identiﬁes a session on the database system.\nPE_vproc_no SMALLINT PE vproc number where the session runs.\nscope SMALLINT Scope of the change deﬁned:\n0 = Current request\n1 = Session\nWLC_id INTEGER WD ID to which the request must be assigned.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nThe TDWM WD ASSIGNMENT request is comparable to changing the session priority by the way of the SQL SET SESSION ACCOUNT statement when TASM Workloads are not\nenabled.\nUse TDWM WD ASSIGNMENT to change the assigned WD for an individual request or session when the rules imposed by the current WD prevent the request from running.\nUse the MONITOR SESSION request to determine host_id, session_no, PE_vproc_no, scope, and WLC_id for the TDWM WD ASSIGNMENT input.\nYou must enable TASM Workloads. Contact Teradata Support for details.\nThe following table shows how the scope determines the effects of the TDWM WD ASSIGNMENT.\nScope Active Request Result\n0 (current request) No Current request has no effect.\n0 (current request) Yes Current request is moved into the speciﬁed WD.\nIf speciﬁed, the \"change workload\" exception is ignored for this request.\n1 (session) request No All subsequent requests on this session are assigned into the speciﬁed WD.\nLake - Monitor Resources and Performance\nPage 307 of 420Scope Active Request Result\nIf speciﬁed, the \"change workload\" exception is ignored for all requests.\n1 (session) Yes Current request and all subsequent requests on the session move into the speciﬁed\nWD.\nIf speciﬁed, the \"change workload\" exception is ignored for all requests.\nCLIv2 Request Parcels\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 0\nActivityType = 159 (PCLTWMWDASSIGNMENTSTMT)\nEndStatement 11 6 StatementNo = 1\nEndRequest 12 4 None\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a TDWM WD ASSIGNMENT request, built by CLIv2, appear when sent to the database server.\nIn this example, the size of the response buffer in the example is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name Bytes Field Value\n0001 Req 16 Request TDWM WD ASSIGNMENT\n0003 Data 8 MonVerID\nhost_id\nsession_no\nPE_vproc_no\nscope\nWLC_id7\n1\n1000\n16383\n1\n3\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe TDWM WD ASSIGNMENT request returns values approximately, as follows, when TASM Workloads rule is enabled and the following input data is speciﬁed:\nhost_id = 1\nsession_no = 1000\nPE_vproc_no =16383\nscope = 1\nWLC_id = 3\nThe TDWM WD ASSIGNMENT request commonly returns values in text character format. Your application program may return the values in a different format or display.\nSuccess parcel:\n StatementNo: 1    ActivityCount: 1\n ActivityType: 159    FieldCount: 1\nDataInfo parcel:\n FieldCount: 1\nEndStatement.\nEndRequest.\nUSER EVENT CONTROL\nActivates and deactivates a user event.\nLake - Monitor Resources and Performance\nPage 308 of 420Input Data\nElement Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nRequest Type SMALLINT\nNOT NULLType of request speciﬁed:\n0 = Deactivate event identiﬁed in Event Name\n1 = Activate event identiﬁed in Event Name\nEvent Name VARCHAR (30) The name of the user event. Maximum of 30 characters. Must be padded with blanks. Case-\nsensitive.\nDuration INTEGER\nNOT NULLTime, in minutes, that this user event remains active. This ﬁeld is valid for active requests only.\nA value of zero means the event is true.\nThe evaluation of all events, including user events, is based on the System Event Timer. If not a\nmultiple of the System Event timer, the Duration value is rounded to the next System Event timer\nvalue.\nMonitor Privileges\nTo use this request, you must have the ABORTSESSION and MONSESSION privileges as part of your default role or both privileges must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nUser Events are deﬁned externally only by the name and the attribute of being active or inactive. User Events also have an optional duration time. The event times out at the end of the\nduration time unless the event is de-activated or re-activated. A Duration value of zero indicates the Activate (a Request Type value of 1) is persistent and lasts until explicitly made\ninactive by another User Event call. User Events persist across a TPA restart or system failure.\nUser Event names are global, or system wide and, therefore, you must make sure that no conﬂicting usages of User Event Control request calls occur.\nCLIv2 Response Parcels\nThe following table lists information about the parcels for the USER EVENT CONTROL request.\nParcel Sequence Number Field Length Comments and Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo=1\nActivityCount = 1\nActivityType = PCLUSEREVENTCONTROLSTMT (169)\nDataInfo 71 6 to 64100 Optional: this parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100 (record mode)\n6 to 64100 (indicator mode)Depending on the request (Data or IndicData) data is returned in record\nor indicator mode. This is the only record returned.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nResponse\nLake - Monitor Resources and Performance\nPage 309 of 420The following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each ﬁeld corresponds to a ResultSet column returned by the Teradata JDBC Driver.\nSee Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe response to the USER EVENT CONTROL request returns a single Record parcel containing the result of the request.\nField/Column Name Data T ype Description\nUser-Deﬁned Event Status INTEGER\nNOT NULLCurrent status of the user-deﬁned event:\n0 = Inactive\n1 = Active\nPrevious User-Deﬁned Event StatusINTEGER\nNOT NULLPrevious status of the user-deﬁned event:\n0 = Previously inactive\n1 = Previously active\n2 = Previously not deﬁned\nThe USER EVENT CONTROL request can be used to activate or inactivate a single, speciﬁc User Event.\nThe response indicates if the operation was successful. For successful operations, the result (Previous User-Deﬁned Event Status) shows the previous value of this User Event. This\nallows the user to know if the User Event was previously active or not. For example, a successful operation, can return any of the following results:\nResult Meaning\n1,0 Current User Event is Active and was previously Inactive.\n1,0 Current User Event is Inactive and was previously Active.\n1,2 Current User Event is Active and was previously not deﬁned.\nThis table does not describe all possible response combinations.\nTeradata Dynamic Workload Management Open APIs (SQL Interfaces)\nThis section describes the Teradata Dynamic Workload Management SQL interfaces that are used to manage the workload and update the stored components (such as, WDs and\nrelated data) in the Teradata Dynamic Workload Management. These SQL interfaces consist of UDFs and external stored procedures that you can invoke from any application.\nThe SQL interfaces to workload management are installed by the DIPTDWM script as part of the database installation (see Requirements for Using the API).\nThese SQL interfaces provide similar functionality to the Teradata Dynamic Workload Management CLIv2 or Teradata JDBC Driver requests.\nYou must fully qualify Teradata dynamic workload management software UDFs and Teradata dynamic workload management software external stored procedures with the database\nname TDWM.\nFor examples of Teradata dynamic workload management software functions and external stored procedures, see the following topics.\nTDWMAbortDelayedRequest\nTDWMActiveWDs\nTDWMApply\nTDWMAssignWD\nTDWMEventControl\nTDWMEventMapping\nTDWMEventStatus\nTDWMExceptionRate\nTDWMExceptions\nTDWMGetDelayedQueries\nTDWMGetDelayedUtilities\nTDWMInquire\nTDWMListWDs\nTDWMLoadUtilStatistics\nTDWMReleaseDelayedRequest\nTDWMRuleControl\nTDWMSetLimits\nTDWMSummary\nTDWMSummaryRate\nTDWMThrottleStatistics\nTDWMAbortDelayedRequest\nAborts a request or utility session on the Teradata dynamic workload management software defer or delay queue.\nIf successful, this function returns a zero.\nTDWMAbortDelayedRequest Syntax\nTDWMAbortDelayedRequest Usage Notes\nTDWMAbortDelayedRequest Example\nLake - Monitor Resources and Performance\nPage 310 of 420TDWMAbortDelayedRequest Syntax\nREPLACE FUNCTION TDWM.TDWMAbortDelayedRequest (\n  HostId SMALLINT,\n  SessionNo  INTEGER,\n  RequestNo  INTEGER,\n  WDId INTEGER\n) RETURNS INTEGER\n  ...\n;\nSyntax Elements\nHostId\nHost ID for the session.\nSessionNo\nNumber of the session.\nRequestNo\nRequest number of the task.\nIf the value is zero, the utility session is aborted.\nWDId\nWD ID for the request in the defer or delay queue being examined.\nTDWMAbortDelayedRequest Usage Notes\nThe TDWMAbortDelayedRequest function provides similar functionality to a TDWM DELAY REQUEST CHANGE request. For more information, see TDWM DELAY REQUEST CHANGE.\nTDWMAbortDelayedRequest Example\nThis example shows how to stop a delayed request on SessionNo 1011.\nSELECT TDWM.TDWMAbortDelayedRequest(HostId, SessionNo, RequestNo, 0)\n FROM TABLE (TDWMGetDelayedQueries('O')) AS t1\n  WHERE SessionNo=1011;\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 3 seconds.\nTDWMAbortDelayedRequest(HostId,SessionNo,RequestNo,0)\n-----------------------------------------------------\n                                                    0\nThe request on SessionNo 1011, if delayed, is stopped as follows:\nSELECT DatabaseName FROM dbc.databasesv;\n *** Starting at Tue Apr 26 15:22:42 2005\n *** Failure 3151 TWM Workload violation: Delay Request Change Abort\n                Statement# 1, Info =0\nTDWMActiveWDs\nReturns a list of all active workloads. TDWMActiveWDs is a table function.\nTDWMActiveWDs Syntax\nTDWMActiveWDs Usage Notes\nTDWMActiveWDs Example\nTDWMActiveWDs Syntax\nREPLACE FUNCTION TDWMActiveWDs (\n) RETURNS TABLE (\n    WDId INTEGER,\n    WDName VARCHAR(30) CHARACTER SET UNICODE,\n    Status VARCHAR(8) CHARACTER SET LATIN,\n    SLG INTEGER,\n    PGID INTEGER,\n    AGID INTEGER,\n    LogMode VARCHAR(8) CHARACTER SET LATIN,\n    CurrOpEnv INTEGER,\n    ActualOpEnv INTEGER\n  )\nLANGUAGE C\nNO SQL\nNO EXTERNAL DATA\nPARAMETER STYLE SQL \nNOT DETERMINISTIC \nLake - Monitor Resources and Performance\nPage 311 of 420CALLED ON NULL INPUT \nEXTERNAL NAME 'SL!api'';\nSyntax Elements\nWDId\nThe WD number.\nWDName\nThe WD name.\nStatus\nEnabled status.\nSLG\nService level goal.\nPGID\nPerformance group number assigned to the WD.\nAGID\nAllocation group number assigned to the WD.\nLogMode\nType of logging.\nCurrOpEnv\nCurrent operating environment.\nActualOpEnv\nActive operating environment.\nTDWMActiveWDs Usage Notes\nThe GDO for TDWM.TDWMActiveWDS exceeds the size of the protected buffer, so this function uses the non-protected buffer. Note, this means the function is not protected.\nTDWMActiveWDs Example\nsel * from table (tdwm.TDWMActiveWDs()) as t1;\n*** Query completed. One row found. 9 columns returned. \n *** Total elapsed time was 1 second.\n WDId  WDName       Status   SLG  PGID   AGID  LogMode    CurrOpEnv  ActualOpEnv\n-----  ----------  -------  ----  ----  -----  --------  ----------  -----------\n  250  WD-Default  Default     0     0      0  Summary           12           12\nTDWMApply\nApplies changes to one or more of the Teradata dynamic workload management software categories.\nTDWMApply Syntax\nTDWMApply Usage Notes\nTDWMApply Example\nTDWMApply Syntax\nREPLACE PROCEDURE TDWM.TDWMApply (\n  IN RuleSetID  INTEGER,\n  IN FilterCat  VARCHAR(1) CHARACTER SET LATIN,\n  IN ThrottleCat  VARCHAR(1) CHARACTER SET LATIN,\n  IN WorkloadCat  VARCHAR(1) CHARACTER SET LATIN,\n  IN EventCat  VARCHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nSyntax Elements\nRuleSetID\nID of the rule set to apply. This must be the current rule set.\nFilterCat\nRequest for the Filters rule category:\nY = Apply changes to the rule category\nN = Skip this rule category\nThrottleCat\nRequest for the system query or system session limits rule category:\nY = Apply changes to the rule category\nN = Skip this rule category\nWorkloadCat\nRequest for the workloads rule category:\nLake - Monitor Resources and Performance\nPage 312 of 420Y = Apply changes to the rule category\nN = Skip this rule category\nEventCat\nRequest for the Event category:\nY = Apply changes to the category\nN = Skip this category\nTDWMApply Usage Notes\nDo not issue TDWMApply while holding locks on any TDWM database tables. This causes a self-deadlock condition because the database must read the TDWM database tables to\nperform this apply.\nUsing the TDWMApply procedure, you can only apply changes to the active rule set.\nThis procedure activates all rules in the database for the category being applied.\nTDWMApply Example\nCALL TDWM.TDWMApply (200, 'Y', 'N', 'N', 'N');\nTDWMAssignWD\nChanges the workload a session or request it is assigned to.\nThis function returns a zero if it is successful.\nTDWMAssignWD Syntax\nTDWMAssignWD Usage Notes\nTDWMAssignWD Example\nTDWMAssignWD Syntax\nREPLACE FUNCTION TDWM.TDWMAssignWD (\n  HostId SMALLINT,\n  SessionNo  INTEGER,\n  VprocNo INTEGER,\n  Scope VARCHAR(1),\n  WDId INTEGER\n) RETURNS INTEGER\n  ...\n;\nSyntax Elements\nHostId\nID of the host on which the session was issued. HostId cannot exceed 1023. A hostid of zero identiﬁes the database operator Console.\nSessionNo\nSession number. SessionNo combined with HostId produces a unique session ID.\nVprocNo\nPE Vproc number where the session runs.\nScope\nScope of the change deﬁned:\nR = Change the workload of the current request\nS = Change the workload of the session\nWDId\nWD ID to which the request must be assigned.\nTDWMAssignWD Usage Notes\nIf TASM Workloads are not enabled and if the database cannot ﬁnd a valid host ID and session number combination, an error message is returned.\nThe TDWMAssignWD function provides similar functionality to a TDWM WD ASSIGNMENT request. For more information about this interface, see TDWM WD ASSIGNMENT.\nTDWMAssignWD Example\nSELECT TDWM.TDWMAssignWD(Hostid, sessionNo, runvprocno, 'S', 7)\nFROM TABLE (MonitorSession(1,'*',0)) AS t1\nwhere username='user14';\n *** Query completed. 5 rows found. One column returned.\n *** Total elapsed time was 2 seconds.\nTDWMAssignWD(HostId,SessionNo,RunVprocNo,'S',7)\n----------------------------------------------\n                                             0\n                                             0\n                                             0\nLake - Monitor Resources and Performance\nPage 313 of 420                                             0\n                                             0\nTDWMEventControl\nActivates or deactivates a user-deﬁned event.\nTDWMEventControl Syntax\nTDWMEventControl Usage Notes\nTDWMEventControl Example\nTDWMEventControl Syntax\nREPLACE PROCEDURE TDWM.TDWMEventControl (\n  IN EventName  TD_ANYTYPE,\n  IN Operation  VARCHAR(1) CHARACTER SET LATIN,\n  IN Duration  INTEGER,\n  OUT NewStatus VARCHAR(8) CHARACTER SET LATIN,\n  OUT PriorStatus VARCHAR(8) CHARACTER SET LATIN\n)\n  ...\n;\nSyntax Elements\nEventName\nName of the event speciﬁed.\nOperation\nStatus of the event:\nA = Active\nI = Inactive\nDuration\nTime, in minutes, after the event expires.\nA value of zero indicates no expiration time.\nNewStatus\nStatus of the event after the procedure call.\nPriorStatus\nStatus of the event before the procedure call.\nTDWMEventControl Usage Notes\nThe user-deﬁned event speciﬁed must be an existing event in the active rule set and can include the following actions:\nNotiﬁcations (for example, send alerts, run programs, or post to a queue table)\nActivate a health condition (SysCon) or planned environment (OpEnv). The highest priority for health conditions and planned environments determines the rule state values that\nthe system enforces. Rule attributes that can be changed based on the rule state include:\nRule enable ﬂag\nRule system session, system query, and utility throttle limits\nWorkload throttle limits\nThe TDWMEventControl procedure provides similar functionality to the USER EVENT CONTROL request. For more information about this interface, see USER EVENT CONTROL.\nTDWMEventControl Example\nCALL TDWM.TDWMEventControl('NodeDownEvent', 'A', 0, NewStatus, PriorStatus);\nTDWMEventMapping\nLists all objects that make up the system state.\nTDWMEventMapping Syntax\nTDWMEventMapping Syntax Elements\nTDWMEventMapping Usage Notes\nTDWMEventMapping Example\nTDWMEventMapping Syntax\nREPLACE FUNCTION TDWM.TDWMEventMapping\n  RETURNS TABLE (\n    ObjectName VARCHAR(128) CHARACTER SET UNICODE, \n    ObjectType VARCHAR(10) CHARACTER SET LATIN,\n    ObjectId INTEGER,\n    ObjectActive CHAR CHARACTER SET LATIN,\n    PrecSeverity INTEGER,\n    EventKind VARCHAR(12) CHARACTER SET LATIN,\nLake - Monitor Resources and Performance\nPage 314 of 420    EventClass VARCHAR(12) CHARACTER SET LATIN,\n    StatusDate INTEGER,\n    StatusTime FLOAT\n    )\n  ...\n;\nTDWMEventMapping Syntax Elements\nObjectType\nType of object, for example: an Event, Expression, SysCon, OpEnv, and a State.\nObjectId\nInternal object ID number.\nObjectName\nType of object, for example: an Event, Expression, SysCon, OpEnv, and a State.\nObjectActive\nStatus of the object:\n0 = Inactive\n1 = Active\nPrecSeverity\nIndicator of the Precedence or Severity of the SysCon or OpEnv object types only:\nSysCon = Indicates the Severity of the SysCon.\nOpEnv = Indicates the Precedence of the OpEnv.\nEventKind\nText string of the speciﬁc event. You may see the following strings as a result of this interface:\nUser Deﬁned SysCon. The user-deﬁned system condition.\nUser Deﬁned OpEnv. The user-deﬁned operating environment.\nTime Period. The time range.\nFatal AMPs. The number of AMPs with the status of FATAL.\nFatal PEs. The number of PEs with the status of FATAL.\nFatal GTWs. The number of Gateways with the status of FATAL.\nNodes Down. The % of nodes down within a clique.\nMinimum available AWTs. The number of in-use AMP AWTs.\nAMPs In Flow Control. The number of AMPs in ﬂow control.\nAverage System CPU. This value is calculated by the CPU usage columns in the resusagespmaV and resusagespsV tables and compared to the threshold deﬁned by\nthe user in this event.\nSystem CPU Skew. This value is calculated by the CPU usage columns in the resusagespmaV and resusagespsV tables.\nWD CPU %. This value is calculated by the CPU usage columns in the resusagespmaV and resusagespsV tables.\nWD SLG Response. The % of request in this WD that have met the deﬁned Response Time Service Level Goal (SLG).\nWD SLG Throughput. The % of request in this WD that have met the deﬁned Throughput SLG.\nWD Arrivals. The number of new requests for this WD.\nWD Active Request. The number of active requests in this WD.\nWD Delay Queue Depth. The number of requests on the Delay Queue for this WD.\nWD Delay Query Time. The max time a request has been delayed in this WD.\nWD AWT Wait Time. The max time a request was on an AMP mailbox waiting for an AWT.\nTwmFlexAvailableAWTsEvent. The number of AWTs that are available for work.\nTwmFlexAvgCpuEvent. This value is calculated by the CPU usage columns in the resusagespmaV and resusagespsV tables and compared to the threshold deﬁned by\nthe user in this event.\nEventClass\nThis ﬁeld is only valid for Object Type of Event and Expression. The values are:\n1 = OpEnv\n2 = SysCon\n3 = FlexThrtl\nTDWMEventMapping Usage Notes\nThe TDWMEventMapping function provides similar functionality to an EVENT STATUS request. For more information about this interface, see EVENT STATUS.\nTDWMEventMapping Example\nSELECT ObjectName, ObjectType, ObjectId, ObjectActive\n  FROM TABLE (TDWM.TDWMEventMapping()) AS t1\n  where objecttype='syscon';\n *** Query completed. 3 rows found. 4 columns returned.\n *** Total elapsed time was 1 second.\nObjectName            ObjectType  ObjectId  ObjectActive\n----------            ----------  --------  ------------\nExtra SysCon1         SYSCON      225       I\nDegraded SysCon       SYSCON      250       I\nNormal                SYSCON      200       A\nTDWMEventStatus\nLake - Monitor Resources and Performance\nPage 315 of 420Returns the deﬁned events.\nTDWMEventStatus Syntax\nTDWMEventStatus Syntax Elements\nTDWMEventStatus Usage Notes\nTDWMEventStatus Example\nTDWMEventStatus Syntax\nREPLACE FUNCTION TDWM.TDWMEventStatus (\n  RequestType  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS TABLE (\n    EventId INTEGER,\n    EventStatus CHAR(1) CHARACTER SET LATIN,\n    EventActiveDate INTEGER,\n    EventActiveTime FLOAT,\n    ExpressionId INTEGER,\n    ExpressionStatus CHAR(1) CHARACTER SET LATIN,\n    ExpActiveDate INTEGER,\n    ExpActiveTime FLOAT,\n    RecordType VARCHAR(8) CHARACTER SET LATIN,\n    RecordId INTEGER,\n    RecordStatus CHAR(1) CHARACTER SET LATIN,\n    DueToDuration CHAR(1) CHARACTER SET LATIN,\n    ActiveDate INTEGER,\n    ActiveTime FLOAT\n  )\n  ...\n;\nTDWMEventStatus Syntax Elements\nRequestType\nRequest type:\nA= Return all events.\nC = Return current state events.\nEventId\nInternal ID of the Event. A value of zero indicates there is no event for this record entry and there are no events for the Normal SysCo n, the Always OpEnv, and a State.\nEvents are reported in order of appearance in the associated expression. Only events in the associated expression are included.\nEventStatus\nCurrent status of the event. The value is either Inactive or Active.\nEventActiveDate\nDate when EventStatus was last changed. This is the date when the EventStatus was set to Inactive or Active.\nEventActiveTime\nTime when EventStatus was last changed. This is the time when EventStatus is set to Inactive or Active.\nExpressionId\nInternal ID of the Expression. A value of zero indicates there is no expression for this record entry.\nThere are no expressions for the Normal SysCon, the Always OpEnv, and a State.\nFor the CURRENT state request, the ﬁrst TRUE expression for the State is included. When there are multiple TRUE expressions for a state, only the ﬁrst one processed is\nreported. The order of processing is consistent within a rule set and, therefore, the same TRUE expression is reported on every request.\nExpressionStatus\nCurrent status of the Expression:\n0 = Inactive\n1 = Active\nExpActiveDate\nDate when ExpressionStatus last changed.\nExpActiveTime\nTime when Expression Status was last changed. This is the time when Expression Status was set to either Active or Inactive.\nRecordType\nType of record, for example: a SysCon, OpEnv, or Notify Only Expression.\nRecordId\nInternal ID of the SysCon or OpEnv depending on the type of record speciﬁed in the RecordType ﬁeld.\nA value of zero indicates the Notify Only Expression record type.\nRecordStatus\nCurrent status of the SysCon or OpEnv record:\nY = Active\nN = Inactive\nDueToDuration\nAn indicator that the corresponding Syscon is being considered as TRUE or is TRUE:\n0 = Inactive if the SysCon is TRUE based on the deﬁned expressions.\n1 = Active if the corresponding SysCon is being considered as TRUE due to the MinDuration value being in affect.\nThis ﬁeld is valid only when SysCon is the speciﬁed RecordType.\nStateActiveDate\nLake - Monitor Resources and Performance\nPage 316 of 420Date when RecordStatus was last changed.\nStateActiveTime\nTime when RecordStatus was last changed.\nTDWMEventStatus Usage Notes\nThe TDWMEventStatus function provides similar functionality to an EVENT STATUS request. For more information about this interface, see EVENT STATUS.\nTDWMEventStatus Example\nSELECT * FROM TABLE (TDWM.TDWMEventStatus('c')) AS t1;\n *** Query completed. 3 rows found. 14 columns returned.\n *** Total elapsed time was 1 second.\n         EventId            0\n     EventStatus  I\n EventActiveDate            0\n EventActiveTime   0.00000000000000E 000\n    ExpressionId            0\nExpressionStatus  I\n   ExpActiveDate            0\n   ExpActiveTime   0.00000000000000E 000\n      RecordType  SYSCON\n        RecordId            1\n    RecordStatus  A\n   DueToDuration  N\n      ActiveDate      1070518\n      ActiveTime   8.39380000000000E 004\n         EventId            0\n     EventStatus  I\n EventActiveDate            0\n EventActiveTime   0.00000000000000E 000\n    ExpressionId            0\nExpressionStatus  I\n   ExpActiveDate            0\n   ExpActiveTime   0.00000000000000E 000\n      RecordType  OPENV\n        RecordId            1\n    RecordStatus  A\n   DueToDuration  N\n      ActiveDate      1070518\n      ActiveTime   8.39380000000000E 004\n         EventId            0\n     EventStatus  I\n EventActiveDate            0\n EventActiveTime   0.00000000000000E 000\n    ExpressionId            0\nExpressionStatus  I\n   ExpActiveDate            0\n   ExpActiveTime   0.00000000000000E 000\n      RecordType  STATE\n        RecordId            1\n    RecordStatus  A\n   DueToDuration  N\n      ActiveDate      1070517\n      ActiveTime   1.00006000000000E 005\nTDWMExceptionRate\nReturns the ﬁrst record of the TDWM Exception request, which is the collection rate.\nThe SMALLINT data type returns the duration of the collection period in seconds. This value represents the collection rate.\nTDWMExceptionRate Syntax\nTDWMExceptionRate Example\nTDWMExceptionRate Syntax\nREPLACE FUNCTION TDWM.TDWMExceptionRate (\n) RETURNS SMALLINT\n  ...\n;\nTDWMExceptionRate Example\nLake - Monitor Resources and Performance\nPage 317 of 420SELECT TDWM.TDWMExceptionRate();\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nTDWMExceptionRate()\n-------------------\n                 60\nTDWMExceptions\nCollects the Teradata dynamic workload management software exception data from the database.\nTDWMExceptions Syntax\nTDWMExceptions Syntax Elements\nTDWMExceptions Usage Notes\nTDWMExceptions Example\nTDWMExceptions Syntax\nREPLACE FUNCTION TDWM.TDWMEXCEPTIONS (\n) RETURNS TABLE (\n    VProcID SMALLINT,\n    QueryID BIGINT,\n    UserName VARCHAR(128) CHARACTER SET UNICODE,\n    SessionID INTEGER,\n    RequestNum INTEGER,\n    LogicalHostID SMALLINT,\n    AcctString VARCHAR(128) CHARACTER SET UNICODE,\n    WDID INTEGER,\n    OpEnvID INTEGER,\n    SysConID INTEGER,\n    ClassifyTime FLOAT,\n    ClassifyDate INTEGER,\n    ExceptionTime FLOAT,\n    ExceptionDate INTEGER,\n    ExceptionValue INTEGER,\n    ExceptionAction VARCHAR(10) CHARACTER SET LATIN,\n    NewWDID INTEGER,\n    ExceptionCode INTEGER,\n    ExceptionSubCode INTEGER,\n    ErrorText VARCHAR(255) CHARACTER SET UNICODE,\n    ExtraInfo VARCHAR(200) CHARACTER SET UNICODE,\n    RuleID INTEGER,\n    WarningOnly VARCHAR(1) CHARACTER SET LATIN,\n    RejectionCat SMALLINT\n  )\n  ...\n;\nTDWMExceptions Syntax Elements\nVprocID\nVproc the request with the exception was running on.\nQueryID\nQuery ID for the query that encountered an exception.\nUserName\nUser name used in the query with the exception.\nSessionID\nSession ID of the query with the exception.\nRequestNum\nRequest number of the query with the exception.\nLogicalHostID\nLogical host ID of the query with the exception.\nAcctString\nAccount string of the query with the exception.\nWDID\nWD ID the query with the exception was running in.\nOpEnvID\nPlanned environment ID in force when the query encountered the exception.\nSysConID\nHealth condition ID in force when the query encountered the exception.\nClassifyTime\nTime the query with the exception was classiﬁed.\nClassifyDate\nLake - Monitor Resources and Performance\nPage 318 of 420Date the query with the exception was classiﬁed.\nExceptionTime\nTime the query encountered the exception.\nExceptionDate\nDate the query encountered the exception.\nExceptionValue\nType of exception that occurred:\n0x00000001 - Exception time limit exceeded.\n0x00000002 - CPU time (AMP and PE) limit exceeded.\n0x00000004 - Blocked time limit exceeded.\n0x00000008 - Disk to CPU ratio exceeded.\n0x00000010 - AMP CPU skew limit exceeded.\n0x00000020 - AMP I/O count limit exceeded.\n0x00000040 - AMP I/O skew limit exceeded.\n0x00000080 - Max row count (for a step) exceeded.\n0x00000100 - Max row count (for a query) exceeded.\n0x00000200 - Spool space limit exceeded.\n0x00000400 - Number of AMPs used in query exceeded.\n0x00000800 - Disk CPU ratio value exceeded\n0x00001000 - I/O space value exceeded.\nA conversion to hex is used to extract the bit values. For example, a value of 1024 converted to hex is 400.\nExceptionAction\nException action taken by the exception handler:\nA = Abort\nC = Change WD\nNew WDId contains the new WD.\nL = Log\nE = Execute (run) Program\nExProgram contains the program name.\nT = Alert\nExAlert contains the alert name.\nN = No action\nThis option disables exception detection and cannot be combined with other actions.\nS = Abort if the statement is a SELECT and no update has been done in the current transaction\nQ = Insert a row to DBC.SystemQTbl\nFor example, CE stands for change WD and run program.\nNewWDID\nWD the query was moved into if the ExceptionAction was change WD.\nExceptionCode\nDatabase exception code.\nExceptionSubCode\nCode for additional information.\nThis ﬁeld is not used.\nErrorText\nError text generated for the exception.\nExtraInfo\nException values noted at the time of the exception.\nRuleID\nTeradata dynamic workload management software rule ID of the rule with the exception handling directive.\nWarningOnly\nIndicator that this is a warning only.\nRejectionCat\nTeradata dynamic workload management software category this query was rejected from.\nTDWMExceptions Usage Notes\nThe TDWMExceptions function provides similar functionality to a TDWM Exceptions request. For more information about this interface, see TDWM EXCEPTIONS.\nTDWMExceptions Example\nSELECT * from table (TDWM.TDWMExceptions()) as t2;\n *** Query completed. 1 row found. 24 columns returned.\n *** Total elapsed time was 1 second.\n         VprocId       16383\n         QueryId   163837185173601767\n        UserName LUMBER\n       SessionId          32\nLake - Monitor Resources and Performance\nPage 319 of 420      RequestNum           2\n   LogicalHostId      1\n      AcctString LUMBER\n            WdId          11\n           OpEnv           1\n          SysCon           1\n    ClassifyTime  1.55443000000000E 005\n    ClassifyDate     1090928\n   ExceptionTime  1.55449000000000E 005\n   ExceptionDate     1090928\n  ExceptionValue           2\n ExceptionAction LA\n         NewWDID          11\n   ExceptionCode        3156\nExceptionSubCode           0\n       ErrorText CPUTime: 1734ms.\n       ExtraInfo\n          RuleId           2\n     WarningOnly\n    RejectionCat           0\nTDWMGetDelayedQueries\nReturns the delayed query data ﬁelds and delay information.\nThis table function is only supported in Constant Mode.\nTDWMGetDelayedQueries Syntax\nTDWMGetDelayedQueries Syntax Elements\nTDWMGetDelayedQueries Examples\nTDWMGetDelayedQueries Syntax\nREPLACE FUNCTION TDWM.TDWMGetDelayedQueries (\n  RequestType  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS TABLE (\n    Username          VARCHAR(128) CHARACTER SET UNICODE,\n    HostId            SMALLINT,\n    SessionNo         INTEGER,\n    RequestNo         INTEGER,\n    RuleName          VARCHAR(128) CHARACTER SET UNICODE,\n    RuleId            INTEGER,\n    TotalTimeHeld     INTEGER,\n    OverRidable       CHAR CHARACTER SET LATIN,\n    BlockingCnt       INTEGER,\n    PEId              INTEGER,\n    WDDelayed         INTEGER,\n    ObjDelayed        INTEGER,\n    UtilDelayed       INTEGER,\n    RuleType          INTEGER,\n    GroupDelayed      INTEGER,\n    FlexEligible      SMALLINT,\n    MeterDeferred     INTEGER\n  )\n  ...\n;\nTDWMGetDelayedQueries Syntax Elements\nRequestType\nRequest type:\nO = Return the system query or system session delay queue.\nW = Return the workload delay queue.\nA = Return queries on the Delay and Defer queue.\nM = Return queries on the Defer queue only.\nUsername\nLogon user name of session.\nHostId\nHost ID of the session number for the delayed request.\nSessionNo\nSession number for the held request.\nRequestNo\nRequest number for the delayed request.\nLake - Monitor Resources and Performance\nPage 320 of 420RuleName\nRule name identiﬁed in the Rule ID ﬁeld.\nRuleId\nRule ID for the workload or the system query or system session throttle rule that caused the query to be delayed or the rule ID for an arrival rate meter that caused the query to\nbe deferred.\nTotalTimeHeld\nTotal number of wall clock seconds that this request or session has been held.\nBlockingCnt\nCount of the number of consecutive times that this request has been identiﬁed as blocking at least one other session.\nThe value is zero if Request Flag is 6.\nOverridable\nRequest or session allowed to be stopped or released by the administrator. A session that exceeds the internal AMP worker task limit cannot be released. A delayed session\ncan be stopped.\nIf the value is Y, the request or session is overridable.\nIf the value is N, the request or session is not overridable.\nThe queue table requests are controlled internally by the database and cannot be altered by the administrator.\nIf Request Flag is 6, this ﬁeld indicates if the delayed session can be released. A session that exceeds the internal AMP worker task limit or an internal utility limit cannot be\nreleased.\nA delayed session can be aborted.\nPEId\nPE VPROC ID which initiated this request.\nWDDelayed\nIndicator that the request is delayed for a workload rule.\nA value of zero indicates the values is not delayed because of a workload throttle.\nObjDelayed\nIndicator that the request is delayed for a system query or system session throttle rule.\nA value of zero indicates the request is not delayed because of a system query or system session throttle.\nUtilDelayed\nIndicator that the request is delayed for a Utility rule.\nA value of zero indicates the request is not delayed because of a utility throttle.\nRuleType\nRule type for the request:\n0 = Workload\n1 = System\n2 = Utility\n3 = Workload Group\n4 = Virtual Partition\n5 = Resource Limit (AWT or Memory)\n6 = Arrival Rate Meter\nGroupDelayed\nWhether Query is delayed for a workload group throttle: 1 (yes) or 0 (no).\nThis ﬁeld is only valid on monitor version software ID 10 or later.\nFlexEligible\nThe delayed request that is in a workload and is tagged as eligible for the Flex Throttle feature. Flagged requests must meet all requirements for Flex Throttles before being\nreleased, such as system throttle restrictions.\n0 = Flex eligible\n1 = Not Flex eligible\nMeterDeferred\nOutput parameter. Indicator of a request being deferred for an arrival rate meter.\n0 = Query is not deferred\n1 = Query is deferred\nTDWMGetDelayedQueries Examples\nUsing TDWMGetDelayedQueries to Get the System Query or System Session Delay Queue\nThis example shows how to get the system query or system session delay queue.\nSELECT * FROM TABLE (TDWM.TDWMGetDelayedQueries('O')) AS t1;\nwhere 'O' is for system query or system session delay queue.\n*** Query completed. One row found. 9 columns returned.\n *** Total elapsed time was 1 second.\n   Username  LUMBER\n     HostId       1\n  SessionNo      1010\n  RequestNo            3\n     WDName  test2\n       WDId            1\n   TimeHeld        6676\nOverRidable   Y\nBlockingCnt            0\nLake - Monitor Resources and Performance\nPage 321 of 420Using TDWMGetDelayedQueries to Get the W orkload Delay Queue\nThis example shows how to get the workload delay queue.\nSELECT * FROM TABLE (TDWM.TDWMGetDelayedQueries('W')) AS t1;\nwhere 'W' is for workload delay queue.\n*** Query completed. 2 rows found. 9 columns returned.\n*** Total elapsed time was 1 second.\n   Username LUMBER\n     HostId 1\n  SessionNo 1008\n  RequestNo 3\n     WDName test-wd\n       WDId 6\n   TimeHeld 7131\nOverRidable Y\nBlockingCnt 0\n   Username LUMBER\n     HostId 1\n  SessionNo 1009\n  RequestNo 3\n     WDName test-wd\n       WDId 6\n   TimeHeld 7114\nOverRidable Y\nBlockingCnt 0\nUsing TDWMGetDelayedQueries to Get All Delay Queues\nThis example shows how to get all the delay queues.\nSELECT * FROM TABLE (TDWM.TDWMGetDelayedQueries('A')) AS t1;\nwhere 'A' or null is for all delay queues.\n*** Query completed. 3 rows found. 9 columns returned.\n*** Total elapsed time was 1 second.\nUsername HostId  SessionNo  RequestNo  WDName  WDId  TimeHeld  OverRidable\n-------- ------  ---------  ---------  ------  ----  --------  -----------\nLUMBER        1       1010          3  test2      1      7717  Y\nLUMBER        1       1008          3  test       6      7748  Y\nLUMBER        1       1009          3  test       6      7731  Y\nTDWMGetDelayedUtilities\nReturns the utility delay queue.\nTDWMGetDelayedUtilities Syntax\nTDWMGetDelayedUtilities Syntax Elements\nTDWMGetDelayedUtilities Example\nTDWMGetDelayedUtilities Syntax\nREPLACE FUNCTION TDWM.TDWMGetDelayedUtilities (\n) RETURNS TABLE (\n    Username       VARCHAR(128)CHARACTER SET UNICODE,\n    HostId         SMALLINT,\n    SessionNo      INTEGER,\n    TotalTimeHeld  INTEGER,\n    OverRidable    CHAR CHARACTER SET LATIN,\n    PEId           INTEGER,\n    RequestNum     INTEGER,\n    WDDelayed      INTEGER,\n    ObjDelayed     INTEGER,\n    UtilDelayed    INTEGER,\n    RuleType       INTEGER\n    RuleName       VARCHAR(128) CHARACTER SET UNICODE\n  )\n  ...\n;\nTDWMGetDelayedUtilities Syntax Elements\nLake - Monitor Resources and Performance\nPage 322 of 420Username\nUser name of the session.\nHostId\nHost ID of the session number for the delayed utility.\nSessionNo\nSession number for the held utility.\nTotalTimeHeld\nTotal number of wall clock seconds that this request has been held.\nOverridable\nRequest or session allowed to be stopped or released by the administrator. A session that exceeds the internal AMP worker task limit cannot be released. A delayed session\ncan be stopped.\nIf the value is Y, this request or session is overridable.\nIf the value is N, this request or session is not overridable.\nThe queue table requests are controlled internally by the database and cannot be altered by the administrator.\nIf Request Flag is 6, this ﬁeld indicates if the delayed session can be released. A session that exceeds the internal AMP worker task limit or an internal utility limit cannot be\nreleased.\nA delayed session can be aborted.\nRuleId\nID of the rule that caused this query to be delayed.\nRequestNum\nRequest number for the held utility.\nWDDelayed\nIndicator that the request is delayed for a workload rule.\nA value of zero indicates the request is not delayed because of a workload throttle.\nObjDelayed\nIndicator that the request is delayed for a system query or system session throttle rule.\nA value of zero indicates the request is not delayed because of a system throttle.\nUtilDelayed\nIndicator that the request is delayed for a Utility rule.\nA value of zero indicates the request is not delayed because of a utility throttle.\nRuleType\nRule type for the request:\n0 = Workload\n1 = System\n2 = Utility\n3 = Workload group\n4 = Virtual Partition\nRuleName\nRule name identiﬁed in the Rule ID ﬁeld.\nTDWMGetDelayedUtilities Example\nSELECT * FROM TABLE (TDWM.TDWMGetDelayedUtilities()) AS t1;\n *** Query completed. 4 rows found. 6 columns returned.\n *** Total elapsed time was 1 second.\nUsername HostId SessionNo  Total TimeHeld  OverRidable  RuleId\n-------- ------ ---------  --------------  -----------  ------\nUSER1         1      2709              16            0       1\nUSER1         1      2710              12            0       2\nUSER1         1      2711               9            0       3\nDBC           1      2712               5            0       4\nTDWMInquire\nReturns the status of each category (active or inactive).\nTDWMInquire Syntax\nTDWMInquire Example\nTDWMInquire Syntax\nREPLACE FUNCTION TDWM.TDWMInquire (\n) RETURNS TABLE (\n    RuleSetId         INTEGER,\n    Filter_category   VARCHAR(10) CHARACTER SET LATIN,\n    Throttle_category VARCHAR(10) CHARACTER SET LATIN,\n    Workload_category VARCHAR(10) CHARACTER SET LATIN,\n    Vent_category     VARCHAR(10) CHARACTER SET LATIN\n  )\n  ...\n;\nSyntax Elements\nLake - Monitor Resources and Performance\nPage 323 of 420RuleSetId\nID of the rule set to apply. This must be the current rule set.\nFilter_Category\nCurrent status of the Filters rule category. The value is either Active or Inactive.\nThrottle_Category\nCurrent status of the Throttle rule category. The value is either Active or Inactive.\nWorkload_Category\nCurrent status of the WD rule category. The value is either Active or Inactive.\nEvent_Category\nCurrent status of the Event category. The value is either Active or Inactive.\nTDWMInquire Example\nSELECT * FROM TABLE (TDWM.TDWMInquire()) AS t1;\n *** Query completed. One row found. 5 columns returned.\n *** Total elapsed time was 5 seconds.\nRuleSetId Filter_Category Throttle_Category Workload_Category Event_Category\n--------- --------------- ----------------- ----------------- --------------\n9060      Inactive        Inactive          Active            Active\nTDWMListWDs\nReturns a list of the WDs.\nTDWMListWDs Syntax\nTDWMListWDs Usage Notes\nTDWMListWDs Example\nTDWMListWDs Syntax\nREPLACE FUNCTION TDWM.TDWMListWDs (\n  EnabledOnly  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS TABLE (\n    RuleSetId   INTEGER,\n    EnabledFlag VARCHAR(10) CHARACTER SET LATIN,\n    WDId        INTEGER,\n    WDName      VARCHAR(128) CHARACTER SET UNICODE\n  )\n  ...\n;\nSyntax Elements\nEnabledOnly\nEnabled workload names.\nThe values, Y and N, return enabled WDs only.\nRuleSetId\nRule set in which the WD is located.\nEnabledFlag\nIndicator that the WDs speciﬁed are enabled.\nWDId\nWD ID.\nWDName\nWD ID.\nWDName\nName of the WD.\nTDWMListWDs Usage Notes\nThis table function is only supported in Constant Mode.\nThe TDWMListWDs function provides similar functionality to a TDWM LIST WD request. For more information about this interface, see TDWM LIST WD.\nTDWMListWDs Example\nSELECT * FROM TABLE (TDWM.TDWMListWDs('Y')) AS t1;\n *** Query completed. 40 rows found. 4 columns returned.\n *** Total elapsed time was 2 seconds.\n  RuleSetId  EnabledFlag  WDId  WDName\n-----------  -----------  ----  ------\n       9889  Enabled      201   WD1\n       9889  Enabled      202   WD2\n       9889  Enabled      203   WD3\n       9889  Enabled      204   WD4\nLake - Monitor Resources and Performance\nPage 324 of 420       9889  Enabled      205   WD5\n       9889  Enabled      206   WD6\n       9889  Enabled      207   WD7\n       9889  Enabled      208   WD8\n       9889  Enabled      209   WD9\n       9889  Enabled      210   WD10\nTDWMLoadUtilStatistics\nReturns the statistics on the load utilities that are available in the system.\nTDWMLoadUtilStatistics Syntax\nTDWMLoadUtilStatistics Example\nTDWMLoadUtilStatistics Syntax\nREPLACE FUNCTION TDWM.TDWMLoadUtilStatistics (\n) RETURNS TABLE (\n    UtilityType VARCHAR(10) CHARACTER SET LATIN,\n    UtilityCount SMALLINT,\n    UtilityLimit SMALLINT\n  )\n  ...\n;\nSyntax Elements\nUtilityType\nType of utility:\n0 = MultiLoad + FastLoad\n1 = MultiLoad\n2 = FastLoad\n3 = FastExport\n4 = ARC\n5 = Standalone Mload\n6 = Standalone FastLoad\n7 = Standalone FastExport\n8 = TPT update Op: MultiLoad\n9 = TPT load Op: Fastload\n10 = TPT export Op: FastExport\n11 = JDBC MultiLoad\n12 = JDBC FastLoad\n13 = JDBC FastExport\n14 = CSP Save Dump (FastLoad)\n15 = DSA\n16 = DSA Backup\n17 = DSA Restore\n18 = MLOADX\nUtilityCount\nNumber of utilities of this type that are active.\nUtilityLimit\nCurrent limit on the number of utilities of this type.\nThere is one record for every utility.\nTDWMLoadUtilStatistics Example\nSELECT * FROM TABLE (TDWM.TDWMLoadUtilStatistics()) AS t1;\n *** Query completed. 4 rows found. 3 columns returned.\n *** Total elapsed time was 3 seconds.\nUtilityType  UtilityCount  UtilityLimit\n-----------  ------------  ------------\nMultiLoad               0            30\nFastLoad                0            30\nFastExport              0            60\nARC                     0           350\n       .\n       .\n       .\nTDWMReleaseDelayedRequest\nReleases a request or utility session in the Teradata dynamic workload management software defer or delay queue.\nLake - Monitor Resources and Performance\nPage 325 of 420If successful, this function returns a zero.\nTDWMReleaseDelayedRequest Syntax\nTDWMReleaseDelayedRequest Usage Notes\nTDWMReleaseDelayedRequest Examples\nTDWMReleaseDelayedRequest Syntax\nREPLACE FUNCTION TDWM.TDWMReleaseDelayedRequest (\n  HostId SMALLINT,\n  SessionNo  INTEGER,\n  RequestNo  INTEGER,\n  WDId INTEGER\n) RETURNS INTEGER\n  ...\n;\nSyntax Elements\nHostId\nHost ID for the session.\nSessionNo\nNumber of the session.\nRequestNo\nRequest number of the task.\nA value of zero indicates the utility session is released.\nWDId\nWD ID for the request in the defer or delay queue being acted on.\nTDWMReleaseDelayedRequest Usage Notes\nThe TDWMReleaseDelayedRequest function provides similar functionality to a TDWM DELAY REQUEST CHANGE request. For more information about this interface, see TDWM DELAY\nREQUEST CHANGE.\nYou must quality this Teradata dynamic workload management software function with the database name TDWM (see the examples).\nTDWMReleaseDelayedRequest Examples\nUsing TDWMReleaseDelayedRequest to Release a Delayed Request\nSELECT TDWM.TDWMReleaseDelayedRequest(HostId, SessionNo, RequestNo, 0)\n FROM TABLE (TDWMGetDelayedQueries('O')) AS t1\n WHERE SessionNo=4531;\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nTDWMReleaseDelayedRequest(HostId,SessionNo,RequestNo,0)\n-------------------------------------------------------\n                                                      0\nUsing TDWMReleaseDelayedRequest to Release Multiple Delayed Requests\nSELECT TDWM.TDWMAbortDelayedRequest(HostId, SessionNo, RequestNo, 0)\n FROM TABLE (TDWMGetDelayedQueries('O')) AS t1\n WHERE t1.Username='TwmUser33';\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nTDWMAbortDelayedRequest(HostId,SessionNo,RequestNo,0)\n-----------------------------------------------------\n                                                    0\nTDWMRuleControl\nUpdates the EnabledFlag of the rule and the EnabledFlag in the base state for the rule in the TDWM database.\nTDWMRuleControl Syntax\nTDWMRuleControl Usage Notes\nTDWMRuleControl Example\nTDWMRuleControl Syntax\nREPLACE PROCEDURE TDWM.TDWMRuleControl (\n  IN RuleSetId    INTEGER,\n  IN RuleName     TD_ANYTYPE,\n  IN Operation    VARCHAR(1) CHARACTER SET LATIN,\nLake - Monitor Resources and Performance\nPage 326 of 420  IN TDWMLock     VARCHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nSyntax Elements\nRuleSetId\nID of the rule set in which the rule is found.\nRuleName\nName of the rule speciﬁed.\nOperation\nRequest to enable or disable the rule:\nE = Enable the rule\nD = Disable the rule\nTDWMLock\nType of request performed on the TDWMLock table:\nW = Wait for the TDWMLock\nA = Abort if the TDWMLock table is locked\nS = Perform the update without locking the TDWMLock table\nThe TDWM places an exclusive lock on the TDWMLock table at startup.\nTDWMRuleControl Usage Notes\nThe TDWMRuleControl procedure must be used with rules deﬁned only with the base state as this is the only state value that the procedure changes.\nTDWMRuleControl Example\nCALL TDWM.TDWMRuleControl(1, 'throttle1', 'D', 'W');\nTDWMSetLimits\nUpdates the system query or system session throttle limits of a rule in the TDWM database.\nTDWMSetLimits Syntax\nTDWMSetLimits Example\nTDWMSetLimits Syntax\nREPLACE PROCEDURE TDWM.TDWMSetLimits (\n  IN RuleSetId      INTEGER,\n  IN RuleName       TD_ANYTYPE,\n  IN TDWMLock       VARCHAR(1) CHARACTER SET LATIN,\n  IN SessionLimit   INTEGER,\n  IN QueryLimit     INTEGER,\n  IN UtilityLimit   INTEGER,\n  IN TimeUnit       VARCHAR(1) CHARACTER SET LATIN,\n  IN QualifyTime    INTEGER\n)\n  ...\n;\nSyntax Elements\nRuleSetId\nID of the rule set in which the rule is found.\nRuleName\nName of the rule speciﬁed.\nTDWMLock\nType of request performed on the TDWMLock table:\nW = Wait for the TDWMLock\nA = Abort if the TDWMLock table is locked\nS = Perform the update without locking the TDWMLock table\nThe TDWM places an exclusive lock on the TDWMLock table at startup.\nSessionLimit\nMaximum number of concurrent sessions. NULL indicates that the ﬁeld is not changed.\nQueryLimit\nMaximum number of concurrent queries. NULL indicates that the ﬁeld is not changed.\nIf the rule is an arrival rate meter, this value is used with TimeUnit and QualifyTime to describe an arrival rate limit. The limit is QueryLimit/TimeUnit for QualifyTime. For example,\na maximum of 10 (requests)/minute for 120 seconds.\nUtilityLimit\nMaximum number of concurrent utilities. NULL indicates that the ﬁeld is not changed.\nTimeUnit\nLake - Monitor Resources and Performance\nPage 327 of 420The time unit of the arrival rate meter:\nH = hour\nM = minute\nS = second\nQualifyTime\nNumber of seconds that the arrival rate must continuously remain at the limit before new requests are held in the Defer queue.\nTDWMSetLimits Example\nCALL TDWM.TDWMSetLimits(1, 'throttle1', 'A', NULL, 10, NULL);\nTDWMSummary\nReturns the Teradata dynamic workload management software WD summary data ﬁelds.\nTDWMSummary Syntax\nTDWMSummary Syntax Elements\nTDWMSummary Usage Notes\nTDWMSummary Example\nTDWMSummary Syntax\nREPLACE FUNCTION TDWM.TDWMSummary (\n) RETURNS TABLE (\n    WDId INTEGER,\n    Arrivals INTEGER,\n    Completions INTEGER,\n    MinRespTime FLOAT,\n    MaxRespTime FLOAT,\n    AvgRespTime FLOAT,\n    MinCPUTime FLOAT,\n    MaxCPUTime FLOAT,\n    AvgCPUTime FLOAT,\n    DelayedCnt INTEGER,\n    AvgDelayTime FLOAT,\n    ExceptionCnt INTEGER,\n    MetSLGCnt INTEGER,\n    ActiveQueryCnt INTEGER,\n    ActiveDelayedCnt INTEGER,\n    ErrorCnt INTEGER,\n    AbortCnt INTEGER,\n    CollectionDate INTEGER,\n    CollectionTime FLOAT,\n    ExceptionAbCnt INTEGER,\n    ExceptionMvCnt INTEGER,\n    ExceptionCoCnt INTEGER,\n    IntervalDelayCnt INTEGER,\n    RejectedCount INTEGER,\n    MovedInCount INTEGER,\n    VirtualPartNum INTEGER,\n    AvgIOWaitTime FLOAT,\n    MaxIOWaitTime FLOAT,\n    AvgOtherWaitTime FLOAT,\n    MaxOtherWaitTime FLOAT,\n    AvgCPURunDelay FLOAT,\n    MaxCPURunDelay FLOAT,\n    AvgSeqRespTime FLOAT,\n    MaxSeqRespTime FLOAT,\n    AvgLogicalIO FLOAT,\n    MaxLogicalIO FLOAT,\n    AvgLogicalKBs FLOAT,\n    MaxLogicalKBs FLOAT,\n    AvgPhysicalIO FLOAT,\n    MaxPhysicalIO FLOAT,\n    AvgPhysicalKBs FLOAT,\n    MaxPhysicalKBs FLOAT,\n    ActiveThrottleBypass INTEGER,\n    FlexActive INTEGER,\n    FlexComplete INTEGER,\n    FlexArrivals INTEGER,\n    DeferCnt     INTEGER,\n    ActiveDeferCnt INTEGER,\n    AvgDeferTime FLOAT\nLake - Monitor Resources and Performance\nPage 328 of 420  )\n  ...\n;\nTDWMSummary Syntax Elements\nWDId\nWD ID.\nArrivals\nNumber of queries that were classiﬁed into this WD by the Teradata dynamic workload management software.\nCompletions\nNumber of queries that completed in this WD in this dashboard or logging interval with:\nNo error code or an error code of 3158\nNo abort ﬂag\nEither an AMP count of > 0 or a Parser CPU > 0\nMinRespTime\nMinimum response time in centiseconds of any query.\nMaxRespTime\nMaximum response time in centiseconds of any query.\nAvgRespTime\nAverage response time in centiseconds for this workload based on the total response time of all completions divided by number of completions.\nMinCPUTime\nMinimum CPU in milliseconds of all the queries that completed in this workload in this dashboard or logging interval, where CPU is the minimum CPU used by any one AMP of\nthe query plus the Parser CPU time used by that same query.\nMaxCPUTime\nMaximum CPU in milliseconds of all the queries that completed in this workload in this dashboard or logging interval, where CPU is the maximum CPU used by any one AMP of\nthe query plus the Parser CPU time used by that same query.\nAvgCPUTime\nRunning total in milliseconds of Parser CPU time plus the total AMP CPU of each query that completed in this workload divided by the number of completions of queries in this\nworkload in this dashboard or logging interval.\nDelayedCnt\nNumber of queries that are delayed in this workload.\nAvgDelayTime\nAverage delay time in centiseconds of all the queries that are delayed in this workload.\nExceptionCnt\nNumber of queries with exceptions in this workload.\nMetSLGCnt\nNumber of queries that met WD Response Time SLG requirements.\nIf the WD does not have Response Time SLG requirement, the query is still counted as met.\nActiveQueryCnt\nNumber of active queries in this workload.\nActiveDelayCnt\nNumber of queries delayed in this workload.\nErrorCnt\nNumber of queries that ﬁnished in this WD in this dashboard or logging interval with an error code > 0 but not 3158 or 3156.\nAbortCnt\nNumber of queries that ﬁnished in this WD in this dashboard or logging interval with an error code of 0 or 3156 and an abort ﬂag.\nCollectionDate\nDate of data collection.\nCollectionTime\nTime of data collection.\nExceptionAbCnt\nNumber of queries that aborted due to a TDWM exception.\nExceptionMvCnt\nNumber of queries that were moved into this WD due to an exception.\nExceptionCoCnt\nNumber of queries that raised an exception but continued in this WD.\nIntervalDelayCnt\nNumber of queries that were delayed in this WD during this interval.\nRejectedCount\nNumber of queries that were rejected by TDWM due to a ﬁlter or throttle rule violation.\nMovedInCount\nNumber of queries that were moved into this WD either due to an exception action or manual move using PMPC.\nVirtualPartNum\nVirtual Partition number of the WD.\nAvgIOWaitTime\nAverage duration of sleeps in milliseconds due to the I/O rate handling over the life of all requests completing in this WD during this interval.\nMaxIOWaitTime\nMaximum duration of sleeps in milliseconds due to the I/O rate handling of a request completing in this WD during this interval.\nAvgOtherWaitTime\nThis column is reserved for future use.\nMaxOtherWaitTime\nLake - Monitor Resources and Performance\nPage 329 of 420This column is reserved for future use.\nAvgCPURunDelay\nAverage wait time in milliseconds in the run queue of all the requests completing in this WD during this interval.\nMaxCPURunDelay\nMaximum wait time in milliseconds in the run queue of a request completing in this WD during this interval.\nAvgSeqRespTime\nAverage of the sum of the response times of the steps (as if all the steps had run sequentially) of all the requests completing in this WD during this interval, in milliseconds.\nMaxSeqRespTime\nMaximum sum of the response times of the steps (as if all steps had run sequentially) of a request completing in this WD during this interval, in milliseconds.\nAvgLogicalIO\nAverage count of logical I/Os for a request completing in this WD during this interval.\nMaxLogicalIO\nMaximum count of logical I/Os for a request completing in this WD during this interval.\nAvgLogicalKBs\nAverage logical I/O usage in KB of all requests completing in this WD during this interval.\nMaxLogicalKBs\nMaximum logical I/O usage in KB for a request completing in this WD during this interval.\nAvgPhysicalIO\nAverage count of physical I/Os of all requests completing in this WD during this interval.\nMaxPhysicalIO\nMaximum physical I/O usage of all requests completing in this WD during this interval.\nAvgPhysicalKBs\nAverage physical I/O usage in KB of all requests completing in this WD during this interval.\nMaxPhysicalKBs\nMaximum physical I/O usage in KB for a request completing in this WD during this interval.\nActiveThrottleBypass\nThe number of queries reported in the Completions column that were allowed to run due to the ThrottleBypass ruleset attribute.\nFlexActive\nThe number of queries that are active in the system that were released by the Flex Throttle feature.\nFlexComplete\nThe number of queries that were released by the Flex Throttle feature that completed during this period.\nFlexArrivals\nThe number of new requests that became active due to Flex Throttle feature.\nDeferCnt\nThe number of queries in this WD that are deferred because of an arrival rate meter rule.\nActiveDeferCnt\nNumber of deferred queries in this WD.\nAvgDeferTime\nAverage defer time due to an arrival rate meter rule, in centiseconds, for all queries assigned to this WD.\nTDWMSummary Usage Notes\nThe TDWMSummary function provides similar functionality to a TDWM Summary request. For more information about this interface, see TDWM SUMMARY.\nTDWMSummary returns information for all queries completed in the dashboard interval for the WD.\nTDWMSummary Example\nUsing TDWMSummary\nSELECT WDId, Arrivals, MetSLGCnt, ActiveReqs FROM TABLE (TDWM.TDWMSummary()) AS t2\n WHERE arrivals <>0;\n *** Query completed. 13 rows found. 4 columns returned.\n *** Total elapsed time was 1 second.\n       WDId     Arrivals    MetSLGCnt   ActiveReqs\n-----------  -----------  -----------  -----------\n        213            8            8            0\n        217            1            0            0\n        221            3            3            0\n        240          109           91            1\nTDWMSummaryRate\nReturns the collection rate (the duration of the collection period in seconds).\nTDWMSummaryRate Syntax\nTDWMSummaryRate Usage Notes\nTDWMSummaryRate Example\nTDWMSummaryRate Syntax\nREPLACE FUNCTION TDWM.TDWMSummaryRate (\n) RETURNS SMALLINT\nLake - Monitor Resources and Performance\nPage 330 of 420  ...\n;\nTDWMSummaryRate Usage Notes\nUse the SetSessionRate function to set the collection rate for updating session-level statistics within memory.\nThe TDWMSummaryRate function provides similar functionality to a TDWM Summary request. For more information about this interface, see TDWM SUMMARY.\nTDWMSummaryRate Example\nUsing TDWMSummaryRate\nSELECT TDWM.TDWMSummaryRate();\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 3 seconds.\nTDWMSummaryRate()\n-----------------\n               60\nTDWMThrottleStatistics\nReturns statistics for throttled database system queries or sessions, throttled workloads, or all throttles.\nTDWMThrottleStatistics Syntax\nTDWMThrottleStatistics Syntax Elements\nTDWMThrottleStatistics Usage Notes\nTDWMThrottleStatistics Examples\nTDWMThrottleStatistics Syntax\nREPLACE FUNCTION TDWM.TDWMThrottleStatistics (\n  RequestType  VARCHAR(1) CHARACTER SET LATIN\n) RETURNS TABLE (\n    ObjectType     VARCHAR(17) CHARACTER SET LATIN,\n    RuleId         INTEGER,\n    RuleName       VARCHAR(128) CHARACTER SET UNICODE,\n    ObjectName     VARCHAR(128) CHARACTER SET UNICODE,\n    SubName        VARCHAR(128) CHARACTER SET UNICODE,\n    Active         INTEGER,\n    ThrottleLimit  INTEGER,\n    Delayed        INTEGER,\n    ThrottleType   VARCHAR(1) CHARACTER SET LATIN,\n    FlexEligible   SMALLINT,\n    TimeUnit       VARCHAR(1) CHARACTER SET LATIN,\n    CurQualifyTime INTEGER,\n    ReqQualifyTime INTEGER\n   )\n  ...\n;\nTDWMThrottleStatistics Syntax Elements\nRequestType\nRequest type:\nA = Return all throttle statistics.\nQ = Return statistics for throttled database system queries.\nS = Return statistics for throttled database system sessions.\nW = Return statistics for throttled workloads.\nObjectType\nType of object for this statistic:\nUser\nAccount\nAccount String\nProﬁle\nClient\nNetwork Address\nApplication\nDatabase\nTable\nMacro\nStored Procedure\nWorkload\nUtility\nLake - Monitor Resources and Performance\nPage 331 of 420Collection\nView\nQueryband\nFunction\nMethod\nVirtual partition\nRESAWT (AWT Resource Limit)\nArrival Rate Meter\nRESMEM (memory resource limit)\nRuleId\nWhen this ﬁeld is a workload, the workload ID.\nRuleName\nWhen this ﬁeld is a workload, the workload name.\nObjectName\nFor table, macro, stored procedure, view, function, and method object types, this is the name of the qualifying database.\nFor all other types, this is the name of the object.\nSee the ObjectType column.\nSubName\nName of the table, macro, stored procedure, view, function, or method.\nActive\nNumber of requests active for this object. This is, the number of active queries or sessions depending on the information requested in the input record.\nIf ObjectType is Arrival Rate Meter, this value is used with TimeUnit to describe the current rate. The current rate is Active/TimeUnit, such as 8 (requests)/minute.\nIf ObjectType is RESMEM, this value is the current total memory usage, in megabytes, of active requests that qualify for a speciﬁc memory resource limit rule.\nThrottleLimit\nCurrent Teradata dynamic workload management software limit on the object.\nThis is the limit on the number of queries or sessions depending on the information requested in the input record.\nA value of -1 indicates that no system query or session throttle limit is deﬁned.\nActive and delayed sessions are not valid when the ThrottleLimit value is -1.\nIf ObjectType is Arrival Rate Meter, this is the arrival rate limit.\nIf ObjectType is RESMEM, this is the memory limit, in megabytes, for requests that qualify for a speciﬁc memory resource limit rule.\nDelayed\nNumber of requests on the delay queue at this time for this object.\nIf ObjectType is Arrival Rate Meter, this is the number of requests being deferred by the arrival rate meter.\nThrottleType\nType of throttle statistic. Possible values include:\nQ = Throttled database system query\nS = Throttled database system session\nW = Throttled workload\nFlexEligible\nThe delayed request that is in a workload and is tagged as eligible for the Flex Throttle feature. Flagged requests must meet all requirements for Flex Throttles before being\nreleased, such as system throttle restrictions.\n0 = Flex eligible\n1 = Not Flex eligible\nTimeUnit\nTime unit of the arrival rate meter:\nH = hour\nM = minute\nS = second\nCurQualifyTime\nNumber of seconds in which the current arrival rate has continuously remained at the limit.\nReqQualifyTime\nNumber of seconds in which the current arrival rate must continuously remain at the limit before new requests are held in the Defer queue.\nTDWMThrottleStatistics Usage Notes\nThe TDWMThrottleStatistics function provides similar functionality to a TDWM STATISTICS request. For more information, see TDWM STATISTICS.\nThis Teradata dynamic workload management software function must be qualiﬁed by the database name TDWM (see the examples).\nTDWMThrottleStatistics Examples\nUsing TDWMThrottleStatistics to Request Query Throttle Statistics\nselect * from table (TDWM.TDWMThrottleStatistics('Q')) AS t1;\n *** Query completed. 4 rows found. 8 columns returned.\n *** Total elapsed time was 1 second.\nObjectType   RuleId RuleName    ObjectName  Subname Active ThrottleLimit Delayed\n----------   ------ --------    ----------  ------- ------ ------------- -------\nUser         1      test2       LUMBER                2      2             1\nUse          2      test4       LUMBER                1      1             0\nTable        3      table test  LUMBER      ORDERS    1      1             0\nMacro        4      macro test  LUMBER      VENDMACRO 0      1             1\nLake - Monitor Resources and Performance\nPage 332 of 420Using TDWMThrottleStatistics to Request Session Throttle Statistics\nselect * from table (TDWM.TDWMThrottleStatistics('S')) AS t1;\n *** Query completed. 2 rows found. 8 columns returned.\n *** Total elapsed time was 1 second.\nObjectType  RuleId  RuleName  ObjectName  Subname Active ThrottleLimit Delayed\n----------  ------  --------  ----------  ------- ------ ------------- -------\nUser        1       test2     LUMBER               2          4          0\nUser        2       test4     LUMBER               2          2          0\nUsing TDWMThrottleStatistics to Request W orkload Throttle Statistics\nselect * from table (TDWM.TDWMThrottleStatistics('W')) AS t1;\n*** Query completed. 2 rows found. 8 columns returned.\n *** Total elapsed time was 1 second.\nObjectType  RuleId  RuleName    ObjectName Subname Active ThrottleLimit Delayed\n----------  ------  ----------- ---------- ------- ------ ------------- -------\nWorkload      0                                     -1          0         1\nWorkload      2     WD-ConsoleR                      0         -1         0\nWorkload      3     WD-ConsoleH                      0         -1         0\nWorkload      4     WD-ConsoleM                      0         -1         0\nWorkload      5     WD-ConsoleL                      0         -1         0\nWorkload      1     WD-Default                       0         -1         0\nWorkload      6     test-wd                          0          0         2\nUsing TDWMThrottleStatistics to Request All Throttle Statistics\nSELECT ObjectType(FORMAT 'x(10)'), rulename(FORMAT 'x(17)'),\n  ObjectName(FORMAT 'x(13)'), active(FORMAT 'Z9'),\n  throttlelimit as ThrLimit, delayed(FORMAT 'Z9'), throttletype as ThrType\n   FROM TABLE (TDWM.TDWMTHROTTLESTATISTICS('A')) AS t1\n       ORDER BY 1,2;\n *** Query completed. 10 rows found. 7 columns returned.\n *** Total elapsed time was 1 second.\nObjectType  RuleName           ObjectName    Active ThrLimit Delayed  ThrType\n----------  -----------------  ------------  ------ -------- -------  -------\nTable       t900throttlerule7  T9TESTUSER         1        1      6    Q\nUser        session919rule     T900APIUSER4       4        5      0    S\nWorkload    WD-Default                            0       -1      0    W\nWorkload    WD1                                   0       -1      0    W\nWorkload    WD3                                   1        1      0    W\nWorkload    WD345678901234567                     1        1      3    W\nWorkload    WD4                                   0        1      0    W\nWorkload    WD5                                   0       -1      0    W\nWorkload    WD6                                   0       -1      0    W\nWorkload    WD7                                   0       -1      0    W\nWorkload Management: Query Band APIs\nA query band can be retrieved through two types of interfaces:\nQuery Band PM/API\nQuery Band Open APIs (SQL Interfaces)\nBefore using the query band APIs, you may want to familiarize yourself with the following topics:\nQuery Band PM/API\nQuery Band Open APIs (SQL Interfaces)\nQuery Band API Features\nExamples Using PM/API and Open APIs\nQuery Band PM/API\nThis section describes the MONITOR QUERYBAND interface that uses CLIv2 or the Teradata JDBC Driver. This interface is called a PM/API.\nFor details on using the MONITOR QUERYBAND Teradata JDBC Driver request, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nMONITOR QUERYBAND is the only query band PM/API request available. This request provides similar functionality to the MonitorQueryBand function.\nMONIT OR QUER YBAND\nReturns the concatenated transaction, session, and proﬁle query band for the speciﬁed session.\nLake - Monitor Resources and Performance\nPage 333 of 420Input Data\nField Name Data T ype Description\nIndByte BYTE Indicator bits that specify which ﬁelds to treat as NULL if you are using indicator mode.\nEach bit in the byte corresponds to one ﬁeld in the input data.\nIf data is supplied for that ﬁeld, set the bit to zero.\nIf the data for that ﬁeld is NULL (that is, there is no data supplied for that ﬁeld), set the bit to 1.\nThe IndByte ﬁeld is only required if the CLIv2 request is submitted in indicator mode.\nmon_ver_id SMALLINT\nNOT NULLMONITOR software version ID. This can be version 6 or later.\nFor a general explanation of monitor version choices, see MONITOR VERSION.\nhost_id SMALLINT Logical ID of a host (or client) with sessions logged on. For example, a hostid of zero identiﬁes internal\nsessions or system Console sessions.\nhost_id cannot exceed 1023.\nSessionNo INTEGER Number of the session. session_no combined with host_id represents a unique session ID.\nRunPEVprocNo SMALLINT PE vproc number where the session runs. This is typically from the RunVprocNo data ﬁeld of the MONITOR\nSESSION response (see Group I Data Fields and JDBC ResultSet Columns). If this ﬁeld is speciﬁed with\nNULL or zero, all PEs are searched for the session, causing signiﬁcant overhead.\nMonitor Privileges\nTo use this request, you must have the MONSESSION privilege as part of your default role or this privilege must be granted directly to you.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nUsage Notes\nIf you encounter a problematic query that is using a large amount of system resources, use the associated query band to identify the source application issuing the request.\nThe MONITOR QUERYBAND request cannot be used on internal sessions or sessions that are logged onto the MONITOR partition. The query band is not stored for these types of\nsessions and is only stored for SQL partitions.\nCLIv2 Response Parcels\nThe MONITOR QUERYBAND request is treated internally as a one statement request that generates one response. The statement response returned from Database Engine 20\ncontains the following sequence of parcel types:\nParcel Sequence Parcel Number Length (Bytes) Comments/Key Parcel Body Fields\nSuccess 8 18 to 273 StatementNo = 1\nActivityCount = 1\nActivityType = 168 (PCLMONQUERYBANDSTMT)\nDataInfo 71 6 to 64100 Optional: This parcel is present if request was IndicData parcel.\nRecord 10\n5 to 64100(record mode)\n6 to 64100 (indicator mode)Depending on the request (Data or IndicData), data is in record or indicator mode.\nThis record contains the query band text.\nEndStatement 11 6 StatementNo = 2-byte integer\nEndRequest 12 4 None\nResponse\nThe following statement corresponds to a ResultSet returned by the Teradata JDBC Driver, and each of the ﬁelds correspond to a ResultSet column returned by the Teradata JDBC\nDriver. See Teradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe Record parcel returns the following ﬁeld:\nLake - Monitor Resources and Performance\nPage 334 of 420Field/Column Name Data T ype Description\nQueryBand VARCHAR (0 to 12304), NOT\nNULLConcatenated query band string for the transaction, session, and proﬁle.\nThe QueryBand column returns the following concatenated transaction, session, and proﬁle query band text:\n=T> transaction query band =S> session query band =P> proﬁle query band\nQuery Band Text\nTransaction query band =T> transaction query band\nSession query band =S> session query band\nProﬁle query band =P> proﬁle query band\nNone NULL. The return string is zero bytes or NULL in indicator mode.\nSample Input - CLIv2 Request\nThe following example shows how the parcels for a MONITOR QUERYBAND request, built by CLIv2, appear when sent to the Teradata server.\nIn this example the size of the response buffer is set at the maximum (64,000 bytes).\nNumber Length Body\nNum Name BytesField Value\n0001 Req 16 Request MONITOR QUERYBAND\n0003 Data 12 HostId\nSessionNo\nRunPEVprocNo1\n1002\n16383\n0004 Resp 6 BufferSize 64000\nSample Input - T eradata JDBC Driver Request\nFor an example of how the PM/API request, built in Java, appears when sent to the database server, see Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Output\nThe following example shows a concatenated query band string that is returned for the current transaction and session.\n=T> job=x1; =S> org=Finance;report=Fin123;\nRelated Information\nFor information on setting the query band for a session or transaction, see SET QUERY_BAND.\nFor information on setting a proﬁle query band, see CREATE PROFILE.\nQuery Band Open APIs (SQL Interfaces)\nThis section describes the SQL interfaces for retrieving a query band and parsing the query band string for name and value pairs. The SQL interfaces consist of UDFs and external\nstored procedures that you can invoke from any application.\nQuery band external stored procedures run on the PE and can retrieve query bands directly from memory. Query band functions run on the AMPs and require message passing to\nretrieve the query band. The external stored procedures provide better performance than query band functions.\nYou need not qualify query band UDFs with the database name. The DBS searches the SYSLIB database.\nYou must qualify query band external stored procedures with the database name SYSLIB.\nFor examples of query band functions and external stored procedures, see the following topics.\nGetQueryBand\nGetQueryBandPairs\nGetQueryBandSP\nGetQueryBandValue\nGetQueryBandValueSP\nMonitorQueryBand\nQueryBandReservedNames_TBF\nGetQueryBand\nLake - Monitor Resources and Performance\nPage 335 of 420Returns the concatenated query band string for the current transaction, session, and proﬁle.\nGetQueryBand Syntax\nGetQueryBand Usage Notes\nGetQueryBand Example\nGetQueryBand Related Information\nGetQueryBand Syntax\nREPLACE FUNCTION SYSLIB.GetQueryBand (\n) RETURNS VARCHAR(12304)CHARACTER SET UNICODE,\n  ...\n;\nGetQueryBand Usage Notes\nThe GetQueryBand function can be used in a SELECT statement and an input parameter for a table function.\nThis function is created in the SYSLIB database when the Environment is created. EXECUTE privileges are granted to PUBLIC by default. For more information, see Requirements for\nUsing the API.\nGetQueryBand Example\nSELECT GetQueryBand();\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\nGetQueryBand()\n-------------------------------------------------------------------\n=S> a=1;b=2;c=3;d=4;\nGetQueryBand Related Information\nFor information on setting the query band for a session or transaction, see SET QUERY_BAND.\nFor information on setting a proﬁle query band, see CREATE PROFILE.\nGetQueryBandPairs\nReturns the name and value pairs in the query band.\nGetQueryBandPairs Syntax\nGetQueryBandPairs Usage Notes\nGetQueryBandPairs Examples\nGetQueryBandPairs Syntax\nGetQueryBandPairs are two overloaded table functions. One requires the query band string to be passed in; the other uses internal calls to retrieve the query band.\nREPLACE FUNCTION SYSLIB.GetQueryBandPairs (\n  SearchType  SMALLINT\n) RETURNS TABLE (\n    QBName  VARCHAR(129) CHARACTER SET UNICODE,\n    QBValue VARCHAR(257) CHARACTER SET UNICODE\n  )\n  ...\n;\nREPLACE FUNCTION SYSLIB.GetQueryBandPairs (\n  QueryBandIn   TD_ANYTYPE,\n  SearchType    SMALLINT\n) RETURNS TABLE (\n    QBName  VARCHAR(129) CHARACTER SET UNICODE,\n    QBValue VARCHAR(257) CHARACTER SET UNICODE\n  )\n  ...\n;\nSyntax Elements\nSearchType\nSearch type:\n0 = Return the name-value pairs in both transaction and session query bands are returned.\nIf the same name occurs in both the transaction and the session query bands, the value for the transaction query band is returned.\n1 = Return only the name-value pairs in the transaction query band.\nLake - Monitor Resources and Performance\nPage 336 of 4202 = Return only the name-value pairs in the session query band.\n3 = Return only the name-value pairs in the proﬁle query band.\nQueryBandIn\nQuery band string.\nQBName\nName of the query band.\nQBValue\nValue of the query band.\nGetQueryBandPairs Usage Notes\nBoth functions are created in the SYSLIB database when the Environment is created. EXECUTE privileges are granted to PUBLIC by default. For more information, see Requirements\nfor Using the API.\nGetQueryBandPairs Examples\nUsing GetQueryBandPairs\nThe following example shows how to call the GetQueryBandPairs function.\nSELECT * FROM TABLE(GetQueryBandPairs(0)) AS t1;\n *** Query completed. 3 rows found. 2 columns returned.\n *** Total elapsed time was 1 second.\nQBName    QBValue\n--------- ---------------\nORG       FINANCE\nJOB       ENDOFMONTH\nJOBID      193858\nUsing GetQueryBandPairs with MonitorQueryBand as Input\nThe following example shows how to call the GetQueryBandPairs function using the MonitorQueryBand function as input.\nSELECT * FROM TABLE(GetQueryBandPairs(MonitorQueryBand(1, 103, 16383), 0)) AS t1;\n *** Query completed. 3 rows found. 2 columns returned.\n *** Total elapsed time was 1 second.\nQBName     QBValue\n---------- ---------------\nORG       FINANCE\nJOB       ENDOFMONTH\nJOBID      193858\nGetQueryBandSP\nReturns the concatenated query band for the current transaction and session.\nGetQueryBandSP Syntax\nGetQueryBandSP Usage Notes\nGetQueryBandSP Example\nGetQueryBandSP Syntax\nREPLACE PROCEDURE SYSLIB.GetQueryBandSP (\n  OUT queryband  VARCHAR(12304) CHARACTER SET UNICODE\n)\n  ...\n;\nSyntax Elements\nqueryband\nThe query band output parameter contains the concatenated transaction, session, and proﬁle query bands.\nGetQueryBandSP Usage Notes\nThe GetQueryBandSP procedure retrieves the query band directly from memory.\nThis procedure is created in the SYSLIB database when the Environment is created. EXECUTE privileges are granted to PUBLIC by default. For more information, see Requirements for\nUsing the API.\nFor information on setting the query band for a session or transaction, see SET QUERY_BAND.\nGetQueryBandSP Example\nLake - Monitor Resources and Performance\nPage 337 of 420CALL SYSLIB.GetQueryBandSP(TheQueryBand);\n *** Procedure has been executed.\n *** Total elapsed time was 1 second.\nqueryband\n-----------------------------------------------------------------\n=T> aa=123;bb=yxs;cc=mmmmm; =S> a=1;b=2;c=3;d=4;\nGetQueryBandV alue\nReturns the value of the speciﬁed name in the current query band.\nIf no matches are found, the return value is an empty string or NULL.\nGetQueryBandValue Syntax\nGetQueryBandValue Usage Notes\nGetQueryBandValue Examples\nGetQueryBandValue Syntax\nThe GetQueryBandValue functions are two overloaded functions. One requires the query band string to be passed in; the other uses internal calls to retrieve the query band.\nREPLACE FUNCTION SYSLIB.GetQueryBandValue (\n  SearchType  SMALLINT,\n  QBName     TD_ANYTYPE\n) RETURNS VARCHAR (257)CHARACTER SET UNICODE\n  ...\n;\nREPLACE FUNCTION SYSLIB.GetQueryBandValue (\n  QueryBandIn  TD_ANYTYPE,\n  SearchType   SMALLINT,\n  QBName      TD_ANYTYPE\n) RETURNS VARCHAR (257)CHARACTER SET UNICODE\n  ...\n;\nSyntax Elements\nSearchType\nSearch type:\n0 = Return the value of the ﬁrst name-value pair where name is speciﬁed by the QBName input argument.\nIf the query band contains the name-value pairs for the transaction and session, the function searches the transaction name-value pairs ﬁrst.\n1= Search the transaction name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input parameter.\n2 = Search the session name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input parameter.\n3 = Search the proﬁle name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input parameter.\nQBName\nName in the query band pair to search for.\nQueryBandIn\nA query band string or NULL.\nGetQueryBandValue Usage Notes\nYou can use these functions to query the DBC.DBQLogTbl table based on the names and values speciﬁed in the QueryBand column.\nBoth functions are created in the SYSLIB database when the Environment is created. EXECUTE privileges are granted to PUBLIC by default. For more information, see Requirements\nfor Using the API.\nGetQueryBandValue Examples\nUsing GetQueryBandV alue to Query the QueryBand Column in QryLogV\nThis example shows you how to query the DBC.DBQLogTbl table for all Teradata brands speciﬁed in the QueryBand column.\nSELECT t1.queryband(FORMAT 'X(50)') FROM\n  dbc.qrylogv t1\n  WHERE GetQueryBandValue(t1.queryband, 0, 'brand') = 'teradata'\n    AND username='qbuser' ORDER BY t1.queryid;\nResult:\nQueryBand\n--------------------------------------------------\n=T> game=monopoly;brand=teradata;\n=T> game=monopoly;brand=teradata;\nLake - Monitor Resources and Performance\nPage 338 of 420=T> game=monopoly;brand=teradata;\n=T> game=monopoly;brand=teradata;\nUsing GetQueryBandV alue to Query DBQLogTbl (QryLogV)\nThis example shows how to query the DBC.DBQLogTbl table for all cat names speciﬁed in the QueryBand column.\nSEL GetQueryBandValue(t1.queryband, 0, 'cat') FROM\n  dbc.qrylogv t1 where\n     GetQueryBandValue(t1.queryband, 0, 'CAT') IS NOT NULL\n     AND username='qbuser' ORDER BY t1.queryid;\nResult:\nGetQueryBandValue(QueryBand,0,'cat')\n------------------------------------------------------------------------\nasta\nasta\nasta\nasta\nasta\nasta\nasta\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nGetQueryBandV alueSP\nReturns the value of the speciﬁed name in the current query band.\nGetQueryBandValueSP Syntax\nGetQueryBandValueSP Example\nGetQueryBandValueSP Syntax\nREPLACE PROCEDURE SYSLIB.GetQueryBandValueSP (\n  IN SearchType  SMALLINT,\n  IN QBName VARCHAR (129) CHARACTER SET UNICODE,\n  OUT QBValue VARCHAR(257) CHARACTER SET UNICODE\n)\n  ...\n;\nSyntax Elements\nSearchType\nSearch type:\n0 = Return the value of the ﬁrst name-value pair where name is speciﬁed by the QBName input argument.\nIf the query band contains name-value pairs for the transaction and session, the function searches the transaction name-value pairs ﬁrst.\n1= Search the transaction name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input argument.\n2 = Search the session name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input argument.\n3 = Search the proﬁle name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input argument.\nQBName\nName in the query band pair to search for.\nQBValue\nValue of speciﬁed name.\nGetQueryBandValueSP Example\nCALL SYSLIB.GetQueryBandValueSP(1,'aa',qbval);\n *** Procedure has been executed.\n *** Total elapsed time was 1 second.\nLake - Monitor Resources and Performance\nPage 339 of 420QBValue\n-------------------------------------\n111\nMonitorQueryBand\nReturns the concatenated query band string for the current transaction, session, and proﬁle. If there is no concatenated query band, the function returns an empty string.\nMonitorQueryBand Syntax\nMonitorQueryBand Usage Notes\nMonitorQueryBand Example\nMonitorQueryBand Related Information\nMonitorQueryBand Syntax\nREPLACE FUNCTION SYSLIB.MonitorQueryBand (\n  HostId     SMALLINT,\n  SessionNo   INTEGER,\n  RunVprocNo  SMALLINT)\n  RETURNS VARCHAR(12304)CHARACTER SET UNICODE\n  )\n  ...\n;\nSyntax Elements\nHostId\nLogical ID of a host.\nSessionNo\nNumber of the session to get the query band for.\nRunVprocNo\nPE vproc number where the session runs, from the RunVprocNo ﬁeld of a MONITOR SESSION response (see Group I Data Fields and JDBC ResultSet Columns).\nMonitorQueryBand Usage Notes\nThe privileges to use this function are not granted by default. The database administrator must explicitly grant the privilege to users that require it.\nThe MonitorQueryBand function provides similar functionality to a MONITOR QUERYBAND request. For more information about this interface, see MONITOR QUERYBAND.\nMonitorQueryBand Example\nSELECT MonitorQueryBand (1, 1003, 16382);\n* * * Query completed. One row found. One column returned.\n* * * Total elapsed time was 5 seconds.\nMonitorQueryBand (1, 1003, 16382)\n---------------------------------\n=T= job=x1; =S= org=Finance; report=Fin123;\nMonitorQueryBand Related Information\nFor information on setting the query band for a session or transaction, see SET QUERY_BAND.\nFor information on setting a proﬁle query band, see CREATE PROFILE.\nQueryBandReservedNames_TBF\nReturns all the query band names and descriptions, including those dropped from a release.\nQueryBandReservedNames_TBF Syntax\nQueryBandReservedNames_TBF Usage Notes\nQueryBandReservedNames_TBF Example\nQueryBandReservedNames_TBF Syntax\nREPLACE FUNCTION SYSLIB.QueryBandReservedNames_TBF (\n) RETURNS TABLE (\n    Queryband_Name      VARCHAR(128) CHARACTER SET UNICODE,\n    Release_Introduced  CHAR(5) CHARACTER SET LATIN,\n    Release_Dropped     CHAR(5) CHARACTER SET LATIN,\n    Category            CHAR(1) CHARACTER SET LATIN,\n    [ Max_Len            INTEGER, ]\n    Default_Value       VARCHAR(256) CHARACTER SET UNICODE,\n    Description         VARCHAR(512) CHARACTER SET UNICODE,\n    Queryband_Type      CHAR(1) CHARACTER SET LATIN\nLake - Monitor Resources and Performance\nPage 340 of 420  )\n;\nREPLACE VIEW SYSLIB.QueryBandReservedNames AS\n  SELECT  Queryband_Name , Category , Max_Len, \n          Default_Value , Description , Queryband_Type\n  FROM TABLE (QueryBandReservedNames_TBF()) AS t1\n  WHERE  Release_Dropped  IS NULL\n; \nSyntax Elements\nQueryband_Name\nName of the query band.\nRelease_Introduced\nVersion number of when the query band name was introduced.\nThe version number is at the granularity of a minor release in standard format (that is, two digits for a major release number followed by a period and two digits for a minor\nrelease number). For example, '15.0' and '15.10'.\nCategory\nQuery band name category:\nT = Teradata restricted name (directive to the database)\nA = Application query band name (recommended for use by Teradata, Customer, and Partner applications)\nI = Teradata internal name (for internal Teradata use)\nMax_Len\n[Optional] Maximum length of the value for the property.\nDefault: 256\nDefault_Value\nDefault value of the property, which is NULL.\nDescription\nDescription of how the query band name is used and whether the name is appropriate for a session or transaction query band, or both.\nQueryband_Type\nQuery band type:\nS = The session query band.\nT = The Transaction query band.\nB = The session and transaction query band.\nQueryBandReservedNames_TBF Usage Notes\nThe QueryBandReservedNames view returns the current query band names only.\nThe QueryBandReservedNames_TBF function and QueryBandReservedNames view are created in the SYSLIB database when the Environment is created. The privileges to use the\nQueryBandReservedNames_TBF function and QueryBandReservedNames view are granted to PUBLIC.\nQueryBandReservedNames_TBF Example\nSELECT queryband_name(FORMAT 'X(30)'), release_introduced from table(queryband\nreservednames_tbf()) as t1 order by 1;\n *** Query completed. 28 rows found. 2 columns returned.\n *** Total elapsed time was 3 seconds.\nqueryband_name                  release_introduced\n------------------------------  ------------------\nACTION                          12.00\nAPPLICATIONNAME                 12.00\nBLOCKCOMPRESSION                14.10\nCLIENTUSER                      12.00\nDEADLINE                        12.00\nDESTINATION                     12.00\nGROUP                           12.00\nIMPORTANCE                      12.00\nJOBDEADLINE                     12.00\nJOBID                           12.00\nJOBLEN                          12.00\nJOBSEQ                          12.00\nMAXQUERYTIME                    12.00\nPROXYROLE                       13.00\nPROXYUSER                       13.00\nQUERYISSUETIME                  12.00\nREDRIVE                         14.10\nSOURCE                          12.00\nSTARTIME                        12.00\nUTILITYDATASIZE                 13.10\nUTILITYNAME                     13.10\nVERSION                         12.00\nLake - Monitor Resources and Performance\nPage 341 of 420Workload Management: Embedded Services System APIs\nThe following describes the embedded services system functions that are used to retrieve data from the Priority Scheduler and query band name values.\nBefore using the embedded services system APIs, you may want to familiarize yourself with the following topics:\nEmbedded Services System Open APIs (SQL Interfaces)\nEmbedded Services System API Features\nEmbedded Services System Open APIs (SQL Interfaces)\nThese SQL interfaces consist of UDFs that you can invoke from any application.\nWhen issuing embedded services system UDFs, you need not fully qualify them by the database name, TD_SYSFNLIB.\nFor examples of embedded services system UDFs, see the following topics.\nGetPSFVersion\nGetQueryBandValueSF\nTD_get_COD_limits\nGetPSFV ersion\nReturns the current type of Priority Scheduler, WORKLOADS.\nGetPSFVersion Syntax\nGetPSFVersion Example\nGetPSFVersion Syntax\nREPLACE FUNCTION TD_SYSFNLIB.GetPSFVersion (\n) RETURNS VARCHAR (10) CHARACTER SET LATIN,\n...\n;\nGetPSFVersion Example\nThis example shows the current Priority Scheduler is using workload deﬁnitions.\nSELECT TD_SYSFNLIB.GetPSFVersion();\n *** Query completed. One row found. One column returned.\n *** Total elapsed time was 1 second.\ngetpsfversion()  WORKLOADS\nGetQueryBandV alueSF\nReturns the value of the speciﬁed name in the current query band. If no matches are found, the return value is an empty string or NULL.\nGetQueryBandValueSF Syntax\nGetQueryBandValueSF Usage Notes\nGetQueryBandValueSF Examples\nGetQueryBandValueSF Syntax\nThe GetQueryBandValueSF functions are two overloaded functions. One requires the query band string to be passed in; the other uses internal calls to retrieve the query band.\nCREATE FUNCTION TD_SYSFNLIB.GetQueryBandValueSF (\n  QueryBandIn  TD_ANYTYPE,\n  SearchType   SMALLINT,\n  QBName      TD_ANYTYPE\n) RETURNS VARCHAR(257) CHARACTER SET UNICODE\n...\n;\nCREATE FUNCTION TD_SYSFNLIB.GetQueryBandValueSF (\n  SearchType   SMALLINT,\n  QBName      TD_ANYTYPE\n) RETURNS VARCHAR(257) CHARACTER SET UNICODE\n...\n;\nSyntax Elements\nQueryBandIn\nA query band string or NULL.\nSearchType\nLake - Monitor Resources and Performance\nPage 342 of 420A numeric argument specifying which query band type to search for the name:\n0 = Return the value of the ﬁrst name-value pair where name is speciﬁed by the QBName input argument.\nIf the query band contains name-value pairs for the transaction and session, the function searches the transaction name-value pairs ﬁrst.\n1= Search the transaction name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input argument.\n2 = Search the session name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input argument.\n3 = Search the proﬁle name-value pairs in the query band and return the value that corresponds to the name speciﬁed by the QBName input parameter.\nQBName\nName in the query band pair to search for. The function returns the value in the name-value pair. A query band name is a maximum of 128 characters.\nGetQueryBandValueSF Usage Notes\nThe GetQueryBandValueSF function provides similar functionality to the GetQueryBandValue function. For more information about this interface, see GetQueryBandValue.\nThis function allows NULL input argument and return values.\nYou can use this function to query the DBC.DBQLogTbl table based on the names and values speciﬁed in the QueryBand column.\nGetQueryBandValueSF Examples\nUsing GetQueryBandV alueSF to Query QryLogV\nThis example shows you how to query the DBC.DBQLogTbl table for all Teradata brands speciﬁed in the QueryBand column.\nSELECT t1.queryband(FORMAT 'X(50)') FROM\n  dbc.dbqlogtbl t1\n  WHERE GetQueryBandValueSF(t1.queryband, 0, 'brand') = 'teradata'\n    AND username='qbuser' ORDER BY t1.queryid;\nResult:\nQueryBand\n--------------------------------------------------\n=T> game=monopoly;brand=teradata;\n=T> game=monopoly;brand=teradata;\n=T> game=monopoly;brand=teradata;\n=T> game=monopoly;brand=teradata;\nUsing GetQueryBandV alueSF to Query DBQLogTbl (QryLogV)\nThis example shows how to query the DBC.DBQLogTbl table for all cat names speciﬁed in the QueryBand column.\nSEL GetQueryBandValueSF(t1.queryband, 0, 'cat') FROM\n  dbc.dbqlogtbl t1 where\n     GetQueryBandValue(t1.queryband, 0, 'CAT') IS NOT NULL\n     AND username='qbuser' ORDER BY t1.queryid;\nResult:\nGetQueryBandValueSF(QueryBand,0,'cat')\n------------------------------------------------------------------------\nasta\nasta\nasta\nasta\nasta\nasta\nasta\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nsabella\nTD_get_COD_limits\nRetrieves the maximum CPU and I/O Capacity on Demand (COD) values from the Priority Scheduler.\nTD_get_COD_limits Syntax\nLake - Monitor Resources and Performance\nPage 343 of 420TD_get_COD_limits Usage Notes\nTD_get_COD_limits Example\nTD_get_COD_limits Related Information\nTD_get_COD_limits Syntax\nCREATE FUNCTION TD_SYSFNLIB.TD_get_COD_limits (\n) RETURNS TABLE (\n    CPULimit SMALLINT,\n    IOLimit SMALLINT\n  )\n  ...\n;\nSyntax Elements\nCPULimit\nThe CPU COD maximum value.\nIf the WM COD mode is set and PM COD packages are installed, the CPULimit output parameter returns values less than 100%.\nThe PM COD package speciﬁes the maximum allowable values.\nIf the PM COD mode is set or there are no PM COD packages installed, the CPULimit output parameter returns 100%.\nIOLimit\nThe I/O COD maximum value.\nIf the WM COD mode is set and PM COD packages are installed, this output parameter returns values determined by the installed PM COD package.\nThe PM COD package speciﬁes the maximum allowable values.\nThe PM COD package speciﬁes the maximum allowable values.\nIf the PM COD mode is set or there are no PM COD packages installed, the IOLimit output parameter returns 100%.\nTD_get_COD_limits Usage Notes\nThere are two COD modes:\nMode Description\nPM COD Platform Metering Capacity on Demand (PM COD) sets resource limits on all activities on the node.\nPM CPU COD uses hardware throttling at the node level. PM I/O COD throttling is done at the disk device level.\nBoth PM I/O COD and WM I/O COD throttling are identical.\nWM COD Workload Management Capacity on Demand (WM COD) allows resource limitations to be applied to CPU and I/O for all database activity\non the node.\nWM CPU COD uses software throttling at the node level. WM I/O COD throttling is done at the disk device level.\nBoth PM I/O COD and WM I/O COD throttling are identical.\nWM COD Max is the maximum WM COD setting in WM COD mode. If there is a TDWM ruleset that exceeds WM COD Max, a message is\nlogged and WM COD is overridden and set to WM COD Max.\nWM COD mode is enabled on new installations. On upgrades, PM COD mode is enabled. The system can be switched to WM COD mode, which disables PM COD.\nThere are two types of PM COD packages:\nPackage teradata-pme-conﬁg-xxx, where xxx is the COD level (for example, 62.5, 75, 87.5, and so on). This package speciﬁes the CPU and I/O limits.\nPackage teradata-pme-conﬁg-cpu-xxx, where xxx is the COD level (for example, 62.5, 75, 87.5, and so on). This package speciﬁes only CPU limits.\nThe CPU and I/O limits are the maximum values speciﬁed by the PM COD packages that cannot be exceeded.\nThe function return values vary according to the mode and the PM COD packages installed.\nPM COD mode returns 100% for the CPULimit and IOLimit.\nWM COD mode returns 100% for the CPULimit and IOLimit, if there are no teradata-pme-conﬁg packages installed.\nWM COD mode returns less than 100% for CPULimit and IOLimit, depending on the teradata-pme-conﬁg-xxx package installed.\nWM COD mode returns less than 100% for CPULimit, depending on the teradata-pme-conﬁg-cpu-xxx package installed.\nIf you activate a Teradata dynamic workload management software ruleset that has CPU and I/O values greater than the COD maximum, the Priority Scheduler replaces the CPU and\nI/O values speciﬁed by the installed PM COD packages with the maximum allowable values and log a message in the messages log.\nThe maximum CPU and I/O COD values are global and not affected by planned environments (OpEnv). If you have multiple planned environments with different WM COD values, this\nis honored but is limited by the COD max value.\nPM COD packages such as teradata-pme-conﬁg-62.5 or teradata-pme-conﬁg-cpu-87.5 have one tenth of a percent CPU limit granularity. For example, if the CPU maximum allowable\nvalue is 62.5%, the TD_get_COD_limits function returns 63%.\nTD_get_COD_limits Example\nLake - Monitor Resources and Performance\nPage 344 of 420This example shows how to retrieve the CPU and I/O COD maximum values from the Priority Scheduler.\nSELECT * FROM TABLE (TD_SYSFNLIB.TD_get_COD_Limits( ) ) As d;\nCPULimit        IOLimit\n-----------     ------------\n75              75\nTD_get_COD_limits Related Information\nOrange Books are located on https://docs.teradata.com/. You must sign in to access the Orange Books.\nFor details about how to monitor WM COD and recommendations for applying it, see Workload Management Capacity on Demand and Other Hard Limits Orange Book,\nTDN0009761.\nFor details about the Priority Scheduler, see Priority Scheduler for Linux SLES 11 Orange Book, 541-0008867.\nWorkload Management: Ruleset APIs\nThe following discusses APIs for performing ruleset operations. More speciﬁcally:\nCreate or replace a TASM rule.\nDelete a TASM rule.\nManage a rule (for example, enable or disable).\nActivate a ruleset.\nOnly system throttle and meter rules are supported.\nThe APIs are external stored procedures (XSPs).\nAn entry is logged in the DBC.TDWMEventLog table when an XSP successfully completes.\nTo create a system throttle, arrival rate meter, or ﬁlter rule:\n1. If you are creating a TASM rule, the desired ruleset or conﬁg name can be retrieved from the TDWM.Conﬁgurations table. Use 'ALLRULESETS' as the ruleset name to create the\nrule in all existing rulesets.\n2. Call the XSP to create the rule without any classiﬁcation criteria. The new rule in initially disabled.\nTDWM.TDWMCreateSystemThrottle to create a System Throttle rule.\nTDWM.TDWMCreateArrivalRateMeter to create an Arrival Rate Meter rule.\nTDWM.TDWMCreateFilter to create a Filter rule.\n3. Call XSP TDWM.TDWMAddClassiﬁcationForRule to add a classiﬁcation criterion to the rule. This step is repeated for each additional classiﬁcation criterion, if necessary.\n4. Optionally, call XSP TDWM.TDWMAddClassiﬁcationForTarget to add a sub-criterion for a Target group classiﬁcation. This step is repeated for each sub-criterion, if necessary.\n5. Call XSP TDWM.TDWMAddLimitForRuleState to add the default limit or a query limit for a speciﬁc state. This step can be repeated for each state. At least one of these calls\nmust specify the default limit.\n6. Call XSP TDWM.TDWMManageRule to enable the new rule.\n7. Optionally, call XSP TDWM.TDWMActivateRuleset to activate an updated ruleset with the new rule.\nSee Ruleset API Examples.\nTDWMCreateSystemThrottle\nTDWMCreateArrivalRateMeter\nTDWMCreateFilter\nTDWMAddClassiﬁcationForRule\nTDWMAddClassiﬁcationForTarget\nTDWMAddLimitForRuleState\nTDWMManageRule\nTDWMActivateRuleset\nTDWMDeleteRule\nRuleset API Examples\nTDWMCreateSystemThrottle\nCreates a system throttle without any qualiﬁcation criteria in one or all existing rulesets.\nTDWMCreateSystemThrottle Syntax\nRuleset API Examples\nTDWMCreateSystemThrottle Syntax\nREPLACE PROCEDURE TDWM.TDWMCreateSystemThrottle (\n  IN RulesetName  TD_ANYTYPE,\n  IN ThrottleName  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN Attributes  VARCHAR(20) CHARACTER SET LATIN,\n  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nLake - Monitor Resources and Performance\nPage 345 of 420Syntax Elements\nRulesetName\nName of the ruleset in which to create the throttle. Use 'ALLRULESETS' to create the throttle in all existing rulesets. Cannot be null and its length must be between 1 and 30.\nThrottleName\nName of the throttle to be created. The speciﬁed name must be unique among all existing TASM rules: throttles, arrival rate meters, workloads, ﬁlters, and so on. Length must\nbe between 1 and 30.\nDescription\nDescription of the throttle. This can be null. Maximum length is 80.\nAttributes\nSee Workload Management User Guide for detailed descriptions of these attributes. Attributes can be combined.\nThrottle type. 'C', 'I', and 'M' are mutually exclusive.\n'C' = collective\n'I' = individual\n'M' = member\nDisabling override:\n'D' = disable manual release or abort\nReplaceOption\n'Y' = Delete the speciﬁed throttle and recreate it. If the speciﬁed throttle does not exist, an error is returned.\n'N' = Create a new throttle. If the speciﬁed throttle exists, an error is returned.\nTDWMCreateArrivalRateMeter\nCreates an arrival rate meter without any qualiﬁcation criteria in one or all existing rulesets.\nTDWMCreateArrivalRateMeter Syntax\nRuleset API Examples\nTDWMCreateArrivalRateMeter Syntax\nREPLACE PROCEDURE TDWM.TDWMCreateArrivalRateMeter (\n  IN RulesetName  TD_ANYTYPE,\n  IN ArrivalRateName  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN Attributes  VARCHAR(20) CHARACTER SET LATIN,\n  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nSyntax Elements\nRulesetName\nName of the ruleset in which to create the arrival rate meter. Use 'ALLRULESETS' to create the meter in all existing rulesets. Cannot be null and its length must be between 1\nand 30.\nArrivalRateName\nName of the arrival rate meter to be created. The speciﬁed name must be unique among all existing TASM rules: throttles, arrival rate meters, workloads, ﬁlters, and so on. The\nname cannot be null and its length must be between 1 and 30 characters.\nDescription\nDescription of the arrival rate meter.\nAttributes\nSee Workload Management User Guide for detailed descriptions of these attributes. Attributes can be combined.\nThrottle type:\n'C' = collective\nDisabling override:\n'D' = disable manual release or abort\nLogging Only (warning):\n'L' = Only log a warning instead of delay or reject\nReplaceOption\n'Y' = Delete the speciﬁed arrival rate meter and recreate it. If the speciﬁed arrival rate meter does not exist, an error is returned.\n'N' = Create a new arrival rate meter. If the speciﬁed arrival rate meter exists, an error is returned.\nTDWMCreateFilter\nCreates a ﬁlter rule without any qualiﬁcation criteria in one or all existing rule sets.\nSyntax\nREPLACE PROCEDURE TDWM.TDWMCreateFilter (\n  IN RulesetName  TD_ANYTYPE,\n  IN FilterName  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN Attributes  VARCHAR(20) CHARACTER SET LATIN,\nLake - Monitor Resources and Performance\nPage 346 of 420  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN)\n;\nSyntax Elements\nRulesetName\nName of the ruleset in which to create the ﬁlter. Use 'ALLRULESETS' to create the ﬁlter in all existing rulesets.\nFilterName\nName of the ﬁlter to be created. The name speciﬁed must be unique among all existing TASM rules (throttles, arrival rate meters, workloads, ﬁlters, and so on) and cannot be\nnull. The length must be between 1 and 30.\nDescription\nDescription of the ﬁlter.\nAttributes\nL = Logging Only (Warning) mode. Only log a warning instead of reject.\nNULL or blank = Reject if qualiﬁed.\nReplaceOption\nY = Delete the speciﬁed ﬁlter rule and recreate it. If the speciﬁed ﬁlter rule does not exist, an error is returned.\nN = Create a new ﬁlter rule. If the speciﬁed ﬁlter rule already exists, an error is returned.\nTDWMAddClassificationForRule\nAdds one classiﬁcation criterion for a speciﬁc TASM rule in one or all existing rulesets. This step is repeated for each additional classiﬁcation criterion, if necessary. This XSP is intended\nto support any TASM rule type (for example, throttle, arrival rate meter, workload, ﬁlter, and so on). However, only system throttle, arrival rate meter, and ﬁlter are supported in this\nrelease.\nTDWMAddClassiﬁcationForRule Syntax\nTDWMAddClassiﬁcationForRule Syntax Elements\nRuleset API Examples\nTDWMAddClassiﬁcationForRule Syntax\nREPLACE PROCEDURE TDWM.TDWMAddClassificationForRule (\n  IN RulesetName  TD_ANYTYPE,\n  IN RuleName  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN ClassifcationType  VARCHAR(20) CHARACTER SET LATIN,\n  IN ClassifcationValue  TD_ANYTYPE,\n  IN ClassifcationOperator  VARCHAR(6) CHARACTER SET LATIN,\n  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nTDWMAddClassiﬁcationForRule Syntax Elements\nRulesetName\nName of the ruleset that contains the RuleName. Use 'ALLRULESETS' to indicate all existing rulesets. Cannot be null and its length must be between 1 and 30.\nRuleName\nName of the rule to add the criterion. The speciﬁed name must be unique among existing TASM rules ( throttles, arrival rate meters, workloads, and ﬁlters). A combination of\nRulesetName and RuleName uniquely identiﬁes a speciﬁc rule. If RulesetName is 'ALLRULESETS', the criterion is added to the same rule name in all existing rulesets. The\nname length must be between 1 and 30. The name cannot be null.\nDescription\nDescription of the criterion.\nClassiﬁcationType\nThis table describes possible values for ClassiﬁcationType:\nValue Description Group\nUSER User name Request Source\nACCT Account name Request Source\nACCTSTR Account string Request Source\nPROFILE Proﬁle Request Source\nAPPL Application name Request Source\nCLIENTADDR Client IP address Request Source\nCLIENTID Client logon ID Request Source\nDB Database Target\nTABLE Table Target\nVIEW View Target\nMACRO Macro Target\nLake - Monitor Resources and Performance\nPage 347 of 420Value Description Group\nSPROC Stored procedure Target\nFUNCTION User-deﬁned function Target\nMETHOD User-deﬁned method Target\nSERVER QueryGrid server Target\nSTMT Statement type Query Characteristics\nALLAMP All AMP request Query Characteristics\nMSR Multi statement request Query Characteristics\nMINSTEPROWS Minimum estimated step row count Query Characteristics\nMAXSTEPROWS Maximum estimated step row count Query Characteristics\nMINFINALROWS Minimum estimated ﬁnal row count Query Characteristics\nMAXFINALROWS Maximum estimated ﬁnal row count Query Characteristics\nMINSTEPTIME Minimum estimated step processing timeQuery Characteristics\nMAXSTEPTIME Maximum estimated step processing timeQuery Characteristics\nMINTOTALTIME Minimum estimated total processing timeQuery Characteristics\nMAXTOTALTIME Maximum estimated total processing timeQuery Characteristics\nJOIN Join type Query Characteristics\nFTSCAN Full table scan Query Characteristics\nMEMORY Memory usage Query Characteristics\nIPE Incremental Planning and Execution Query Characteristics\nQUERYBAND Query Band Query Band\nUTILITY Utility type Utility\nClassiﬁcationValue\nValue of the classiﬁcation type to match for this criterion. A name can include the following wildcard characters:\n'*' = Matches zero or more characters\n'?' = Matches one character\nClassiﬁcation T ype Classiﬁcation V alue\nUSER User name\nACCT Account name\nACCTSTR Account string\nPROFILE Proﬁle name\nAPPL Application name\nCLIENTADDR Client IP address\nCLIENTID Client logon ID\nDB Database name\nTABLE Table name\nVIEW View name\nMACRO Macro name\nSPROC Stored procedure name\nFUNCTION User-deﬁned function name\nMETHOD User-deﬁned method name\nSERVER QueryGrid server name\nSTMT D = DDL\nM = DML\nS = SELECT\nC = COLLECT STATISTICS\nOr a combination of the preceding values.\nThis ClassiﬁcationType can only be included, so ClassiﬁcationOperator must be set to\n'I'.\nALLAMP Not applicable\nLake - Monitor Resources and Performance\nPage 348 of 420Classiﬁcation T ype Classiﬁcation V alue\nMSR Integer (>= 2) specifying minimum statement count\nMINSTEPROWS Integer (>= 1) specifying minimum estimated step row count\nMAXSTEPROWS Integer (>= 1) specifying maximum estimated step row count\nMINFINALROWS Integer (>= 1) specifying minimum estimated ﬁnal row count\nMAXFINALROWS Integer (>= 1) specifying maximum estimated ﬁnal row count\nMINSTEPTIME Decimal (>= 0) specifying minimum estimated step processing time\nMAXSTEPTIME Decimal (>= 1) specifying maximum estimated step processing time\nMINTOTALTIME Decimal (>= 1) specifying minimum estimated total processing time\nMAXTOTALTIME Decimal (>= 1) specifying maximum estimated total processing time\nJOIN Only one of these values is allowed.\nN = no join\nA = any join type\nP = product join\nQ = no product join\nU = unconstrained product join\nV = no unconstrained product join\nFTSCAN Not applicable\nMEMORY Only one of these values is allowed.\nI = increased\nL = large\nV = very large\nIPE Not applicable\nQUERYBAND QueryBand name-value pair\nUTILITY Multiple utility values separated by spaces can be used to specify multiple utilities.\nValue Description\nUFL FastLoad utility\nUMLMultiLoad utility\nUFE FastExport utility\nJFL JDBC FastLoad utility\nJMLJDBC MultiLoad utility\nJFE JDBC FastExport utility\nNFL Non-Teradata FastLoad utility\nNMLNon-Teradata MultiLoad utility\nNFE Non-Teradata FastExport utility\nTLD TPT Load operator\nTUP TPT Update operator\nTEX TPT Export operator\nTMXTPT MLOADX\nCSPCSP Save Dump\nARCArchive/Restore\nDBKDSA Backup\nDRSDSA Restore\nClassiﬁcationOperator\nThis parameter speciﬁes whether:\nThe classiﬁcation criterion is for inclusion or exclusion.\nFor Proﬁle and User inclusion criteria, the implicit AND operation can be overridden with an OR operation.\nFor CLIENTADDR criteria, the OR operation can be speciﬁed to check both ClientIpAddress and ClientIPAddrByClient. The default is to check only ClientIpAddress.\nA request is qualiﬁed for a rule (throttle, ARM, workload, and so on) if the following are true:\nThe request satisﬁes all inclusion criteria of the rule.\nThe request satisﬁes no exclusion criteria of the rule.\nWhen multiple criteria are attached to a rule name, TASM performs implicit OR/AND operations among the criteria.\nLake - Monitor Resources and Performance\nPage 349 of 420For multiple criteria from the Request Source group:\nCriteria of the same ClassiﬁcationType are joined together by the OR operator. For example, if the criteria of a throttle include USER=user1, USER=user2, then\nthe throttle is applied to requests from user1 OR user2.\nCriteria of the different ClassiﬁcationType are joined together by the AND operator. For example, if the criteria of a throttle include USER=user1, ACCT=ﬁnance,\nthen the throttle is only applied to requests from user1 AND ﬁnance account. This operation can be overridden so that USER and PROFILE criteria are joined\ntogether by the OR operator.\nFor multiple criteria from the Target group (except SERVER), they are joined together by the OR operator. For example, if the criteria of a throttle include DB=db1,\nTABLE=db3.tableX, then the throttle is applied to requests that reference db1 OR db3.tableX.\nFor multiple criteria from different groups, they are joined together by the AND operator. For example, if criteria include:\nUSER: user1, user2, and user3\nDB: db1, db2\nTABLE: db3.tableX, db4.tableY\nThen, the criteria are interpreted as: (user1 OR user2 OR user3) AND (db1 OR db2 OR db3.tableX OR db4.tableY)\nValues Descriptions\nI Inclusion criterion (mutually inclusive with E)\nE Inclusion criterion (mutually exclusive with I)\nO Proﬁle and User criteria can be joined with an OR operator. For CLIENTADDR\ncriteria, IP Address ﬁelds ClientIpAddress and ClientIPAddrByClient can be joined\nwith an OR operator for request evaluation.\nOnly valid with PROFILE, USER, or CLIENTADDR criteron.\nThe 'O' operator must be combined with either 'I' or 'E' because criteria\nmust be either inclusive or exclusive.\nReplaceOption\n'Y' = Delete the existing criteria of the speciﬁed rule and add the criterion. If the speciﬁed rule does not exist or does not have any criteria, an error is returned.\n'N' = Add a criterion. If the speciﬁed criterion exists, an error is returned.\nTDWMAddClassificationForTarget\nAdds a sub-criterion for a Target group classiﬁcation (database, table, and so on) in one or all existing rulesets. The speciﬁed target must exist. This step is repeated for each\nadditional sub-criterion, if necessary.\nTDWMAddClassiﬁcationForTarget Syntax\nTDWMAddClassiﬁcationForTarget Syntax Elements\nRuleset API Examples\nTDWMAddClassiﬁcationForT arget Syntax\nREPLACE PROCEDURE TDWM.TDWMAddClassificationForTarget (\n  IN RulesetName  TD_ANYTYPE,\n  IN RuleName  TD_ANYTYPE,\n  IN TargetType  VARCHAR(20), CHARACTE SET LATIN,\n  IN TargetValue  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN ClassifcationType  VARCHAR(20) CHARACTER SET LATIN,\n  IN ClassifcationValue  TD_ANYTYPE,\n  IN ClassifcationOperator  VARCHAR(6) CHARACTER SET LATIN,\n  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nTDWMAddClassiﬁcationForT arget Syntax Elements\nRulesetName\nName of the ruleset that contains the RuleName. Use 'ALLRULESETS' to indicate all existing rulesets. Cannot be null and its length must be between 1 and 30.\nRuleName\nName of the rule to add the criterion. The speciﬁed name must be unique among all existing TASM rules: throttles, arrival rate meters, workloads, ﬁlters. A combination of\nRulesetName and RuleName uniquely identiﬁes a speciﬁc rule. If RulesetName is 'ALLRULESETS', the criterion is added to the same rule name in all existing rulesets. The\nname cannot be null. The length must be between 1 and 30.\nTargetType and TargetValue\nThese parameters identify the target to which to add the sub-criterion. The maximum length of TargetValue is 256 characters. A TargetValue may include the following wildcard\ncharacters:\n'*' = Matches zero or more characters\n'?' = Matches one character\nThe following table describes possible values for TargetType and TargetValue.\nTargetT ype TargetV alue\nDB Database name\nTABLE Table name\nLake - Monitor Resources and Performance\nPage 350 of 420TargetT ype TargetV alue\nVIEW View name\nMACRO Macro name\nSPROC Stored procedure name\nDescription\nDescription of the criterion.\nClassiﬁcationType\nAllowable values for ClassiﬁcationType depend on the speciﬁed TargetType. The following table describes possible values for ClassiﬁcationType for each\nTargetType.MINACCPCT speciﬁes the estimated minimum percentage of the speciﬁed table that a request accesses.\n  DB TABLE VIEW MACRO SPROC\nFTSCAN X X X X X\nJOIN X X X X X\nMINSTEPROWS X X X X X\nMAXSTEPROWS X X X X X\nMINSTEPTIME X X X X X\nMINACCPCT   X      \nSTMT\nD (DDL)\nM (DML)\nS (SELECT)  X      \nClassiﬁcationValue\nThis table describes possible values for ClassiﬁcationValue.\nClassiﬁcation T ype Classiﬁcation V alue\nSTMT D = DDL\nM = DML\nS = SELECT\nOr a combination of the preceding values.\nMINSTEPROWS Integer (>= 1) specifying minimum estimated step row count\nMAXSTEPROWS Integer (>= 1) specifying maximum estimated step row count\nMINSTEPTIME Decimal (>= 0) specifying minimum estimated step processing time\nMAXSTEPTIME Decimal (>= 0) specifying maximum estimated step processing time\nJOIN Only one of these values is allowed.\nN = no join\nA = any join type\nP = product join\nQ = no product join\nU = unconstrained product join\nV = no unconstrained product join\nFTSCAN Not applicable\nMINACCPCT Decimal (<= 100) specifying minimum percentage of table being accessed.\nClassiﬁcationOperator\nIf ClassiﬁcationType value is FTSCAN, this parameter speciﬁes whether the criterion is for inclusion or exclusion. For all other ClassiﬁcationType values of a target, the criterion\nmust be set for inclusion.\n'I' = criterion is for inclusion\n'E' = criterion is for exclusion\n'I' and 'E' are mutually exclusive.\nReplaceOption\n'Y' = Delete the all existing sub-criteria of the speciﬁed target and add the sub-criterion. If the speciﬁed target does not exist or does not have any sub-criteria, an error\nis returned.\n'N' = Add a sub-criterion. If the speciﬁed sub-criterion exists, an error is returned.\nTDWMAddLimitForRuleState\nAdds the default limit or query limit for a speciﬁc state. This step is repeated for each state, if necessary. At least one of these calls must specify the default limit.\nThis XPS is intended to support any TASM rule types (for example, throttle, arrival rate meter, workload, ﬁlter, and so on). However, only system throttle, arrival rate meter, and ﬁlter are\nsupported in this release.\nTDWMAddLimitForRuleState Syntax\nTDWMAddLimitForRuleState Syntax Elements\nRuleset API Examples\nLake - Monitor Resources and Performance\nPage 351 of 420TDWMAddLimitForRuleState Syntax\nREPLACE PROCEDURE TDWM.TDWMAddLimitForRuleState (\n  IN RulesetName  TD_ANYTYPE,\n  IN RuleName  TD_ANYTYPE,\n  IN StateName  TD_ANYTYPE,\n  IN Description  TD_ANYTYPE,\n  IN StateLimit  VARCHAR(50) CHARACTER SET LATIN,\n  IN Action VARCHAR(6) CHARACTER SET LATIN,\n  IN ReplaceOption  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nTDWMAddLimitForRuleState Syntax Elements\nRulesetName\nName of the ruleset that contains the RuleName. Use 'ALLRULESETS' to add limit for the speciﬁed rule state in all existing rulesets. Cannot be null and its length must be\nbetween 1 and 30.\nRuleName\nName of the throttle to add the limit. The speciﬁed name must be unique among all existing TASM rules: throttles, arrival rate meters, workloads, ﬁlters, and so on. Cannot be\nnull and the length must be between 1 and 30.\nStateName\nName of the state of the RuleName to add the limit. ‘DEFAULT’ is reserved for the default limit that is used for any state that does not have a speciﬁc limit. A combination of\nRulesetName, RuleName, and StateName uniquely identiﬁes a speciﬁc rule state. If RulesetName is 'ALLRULESETS', the limit is added for the same StateName of the same\nRuleName in all existing rulesets.\nDescription\nDescription of the state limit. Description can be null. The maximum length is 80.\nStateLimit\nThis parameter is ignored if the rule type is ﬁlter. For other rule types, the parameter speciﬁes the limit of a state.\nAction\nAction to for the speciﬁed state. These actions are mutually exclusive.\nFilter rules can be enabled or disabled on a state by state basis and automatically reject qualifying queries. Valid actions are:\n'E' = Enable\n'N' = Disable (not enabled)\nThrottle and arrival rate meter rules are enabled at the rule level. At the state level, you can specify the action to take for new qualifying requests when the throttle limit is\nreached. Valid actions are:\n'D' = Delay\n'R' = Reject\nReplaceOption\n'Y' = Delete the all existing limits of the speciﬁed state and add a new state limit. If the speciﬁed state does not exist or does not have any sub-criteria, an error is\nreturned.\n'N' = Add the speciﬁed state limit. If the speciﬁed state has a limit, an error is returned.\nTDWMManageRule\nEnables or disables a speciﬁc rule or rules. If the operation is to enable a rule, validations are performed (for example, qualiﬁcation criteria, default state limit) to reduce the risk of\nenabling an incomplete rule. If a rule fails any validation, the rule remains disabled.\nTDWMManageRule Syntax\nRuleset API Examples\nTDWMManageRule Syntax\nREPLACE PROCEDURE TDWM.TDWMManageRule (\n  IN RulesetName  TD_ANYTYPE,\n  IN RuleName  TD_ANYTYPE,\n  IN Operation  CHAR(1) CHARACTER SET LATIN\n)\n  ...\n;\nSyntax Elements\nRulesetName\nName of the ruleset that contains the RuleName. Use 'ALLRULESETS' to enable the speciﬁed rule in all existing rulesets. Cannot be null and its length must be between 1 and\n30.\nRuleName\nName of the rule to be managed. A combination of RulesetName and RuleName uniquely identiﬁes a speciﬁc throttle or an arrival rate meter. The speciﬁed name must be\nunique among all existing TASM rules: throttles, arrival rate meters, workloads, ﬁlters, and so on. Cannot be null and the length must be between 1 and 30.\nOperation\n'E' = enable\nLake - Monitor Resources and Performance\nPage 352 of 420'D' = disable\nTDWMActivateRuleset\nActivates a ruleset. This procedure cannot be enclosed in BEGIN TRANSACTION (BT) and END TRANSACTION (ET) statements or an error may occur.\nTDWMActivateRuleset Syntax\nRuleset API Examples\nTDWMActivateRuleset Syntax\nREPLACE PROCEDURE TDWM.TDWMActivateRuleset (\n  IN RulesetName  TD_ANYTYPE\n)\n  ...\n;\nSyntax Elements\nRulesetName\nName of the ruleset to be activated. Cannot be null and the length must be between 1 and 30.\nTDWMDeleteRule\nDeletes a speciﬁc rule in one or all existing rulesets, deletes all classiﬁcation criteria and state limits associated with the rule or rules, and supports system throttle, arrival rate meter,\nand ﬁlter rules.\nTDWMDeleteRule Syntax\nRuleset API Examples\nTDWMDeleteRule Syntax\nREPLACE PROCEDURE TDWM.TDWMDeleteRule (\n  IN RulesetName  TD_ANYTYPE,\n  IN RuleName  TD_ANYTYPE\n)\n  ...\n;\nSyntax Elements\nRulesetName\nName of the ruleset that contains the RuleName. Use 'ALLRULESETS' to delete the speciﬁed rule in all existing rulesets. Cannot be null and the length must be between 1 and\n30.\nRuleName\nName of the rule to be deleted. The rule can be either a system throttle or an arrival rate meter. The speciﬁed name must be unique among all existing TASM rules: throttles,\narrival rate meters, workloads, ﬁlters, and so on. Cannot be null and the length must be between 1 and 30.\nTDWMSetRulesetAttr\nThis XSP updates attributes of a speciﬁc ruleset. You can modify only one ruleset. To modify multiple attributes, specify their new values. A NULL parameter value indicates no change\nto the corresponding attribute.\nTDWMSetRulesetAttr Syntax\nRuleset API Examples\nTDWMSetRulesetAttr Syntax\nSyntax\nREPLACE PROCEDURE TDWM.TDWMSetRulesetAttr \n(  IN RulesetName            TD_ANYTYPE,\n   IN NewRulesetName         TD_ANYTYPE,\n   IN NewEventInterval    INTEGER,\n   IN NewDashboardInterval   INTEGER,\n   IN NewLoggingInterval  INTEGER,\n   IN NewExceptionInterval   INTEGER,\n   IN NewFlexActionInterval  INTEGER,\n   IN NewBlockerCycles    VARCHAR(20) CHARACTER SET LATIN,\n   IN NewBlockerAction    VARCHAR(20) CHARACTER SET LATIN,\n   IN NewActivationOptions   VARCHAR(20) CHARACTER SET LATIN,\n   IN NewTSAutoDecay  CHAR(1) CHARACTER SET LATIN,\n   IN NewAvailAWTDefinition   VARCHAR(20) CHARACTER SET LATIN,\n   IN NewOtherOptions VARCHAR(20) CHARACTER SET LATIN \nLake - Monitor Resources and Performance\nPage 353 of 420) \n  ...\nSyntax Elements\nRulesetName\nName of the existing ruleset to be updated. Cannot be NULL and the length must be between 1 and 30.\nNewRulesetName\nUpdate the name of this ruleset.\nNULL = No change in ruleset name.\nnew_ruleset_name = New name for this ruleset. The length must be between 1 and 30. The new name cannot be ‘FirstConﬁg’ and cannot be the same as an existing\nruleset.\nNewEventInterval\nUpdate event interval.\nNULL = No change in event interval.\n<integer> = New event interval value in seconds.Valid values are 5, 10, 30, and 60.\nNewDashboardInterval\nUpdate dashboard interval.\nNULL = No change in dashboard interval.\n<integer> = New dashboard interval value in seconds must be: At most 600, and a multiple of EventInterval.\nNewLoggingInterval\nUpdate logging interval.\nNULL = No change in logging interval.\n<integer> = New logging interval value in seconds must be: Between 60 and 3600, and a multiple of dashboard interval.\nNewExceptionInterval\nUpdate exception interval.\nNULL = No change in exception interval.\n<integer> = New exception interval value in seconds. Valid values are from 1 to 3600.\nNewFlexActionInterval\nUpdate ﬂex throttle action interval.\nNULL = No change in ﬂex throttle action interval.\n<integer> = New ﬂex throttle interval action value in seconds must be: A multiple of event interval. Less than or equal to 3600.\nNewBlockerCycles\nUpdate the number of consecutive exception intervals that the system must identify a delayed request as a blocker before taking the Blocker Action.\nNULL = No change in the number of consecutive cycles.\nOFF = Turn off blocker detection.\n<integer> = New deadlock cycle value. Valid values are from 1 to 3.\nNewBlockerAction\nUpdate action on blocker.\nNULL = No change in blocker action.\nLOG = Log an indication that the delayed request is a blocker.\nRELEASE = Release the blocker to run.\nABORT = Abort the blocker\nNewActivationOption\nUpdate activation option value.\nNULL = No change in activation option value.\nF = Activate Filters and Utility Sessions.\nT = Activate System Throttles and Session Control.\nFT = Activate ‘Filters and Utility Sessions’ and ‘System Throttles and Session Control’\nNewTSAutoDecay\nUpdate timeshare decay setting.\nNULL = No change in timeshare decay setting.\nE = Enable timeshare decay.\nD = Disable timeshare decay.\nNewAvailAWTDeﬁtion\nUpdate available AWT deﬁnition.\nLake - Monitor Resources and Performance\nPage 354 of 420NULL = No change in available AWT deﬁnition.\nWORKNEW = Available AWTs are WORKNEW work type.\nANY = Available AWTs are in unreserved pool of any work type.\nNewOtherOptions\nUpdate other options of a ruleset.\nNULL = No change in other options.\n+<option> = Set the speciﬁed option.\n-<option> = Clear the speciﬁed option.\n'{+<option> | -<option>} …' = Set and/or clear multiple options\nOptions\nL - Transaction Locks bypass throttling: Do not delay requests in a transaction after non-access locks are placed within the transaction. This option is the same as the\n‘Prevent Mid-Transaction Throttle Delay’ option of Viewpoint Workload Designer\nP - Prioritize the delay queue based on priorities of workloads associated with delayed requests. Clearing this option prioritizes the delay queue based on delayed time\nof requests.\nX - Enable high MLOADX limit.\nF - Enable Flex Throttle.\nE - Set Flex Throttle in Evaluation mode. Only applicable when Flex Throttle is enabled (‘F’ option).\nRuleset API Examples\nCreate a Filter\nThis is an example of running a Vantage-as-a-Service (VaaS) system and the user wants to control access to the system with a TASM ﬁlter rule using the IP address of the client/user\nmachines. Those that qualify for the rule are denied access to the system.\nFor this example, assume the client/user machines IP addresses are 55.77.100.224 and 55.77.100.255.\nThe TASM ﬁlter rule attributes are:\nRule Type: Filter\nRule Name: FILTER_IP_ADDRESS\nQualiﬁcations:\nClient IP Address: 55.77.100.224 or 55.77.100.255\nUse ORing option to enable ClientIPAddrByClient check.\nLimit: Default: Enabled\nThe API call sequence:\n1. The desired rules name, MyFirstConﬁg, is known so the query the TDWM.Conﬁgurations table need not be queried.\n2. Create ﬁlter rule FILTER_IP_ADDRESS without any classiﬁcation criteria.\nCALL TDWM.TDWMCreateFilter(\n   'MyFirstConfig',                        /* RulesetName */\n   'FILTER_IP_ADDRESS',                    /* FilterName */\n   'Filter by Client IP Address',          /* Description */\n   NULL,                                   /* Attributes */\n   'N'                                     /* ReplaceOption */);\n3. Add classiﬁcation criteria.\nAdd client IP address criterion for client/user machine 55.77.100.224. Set ORing option to enable ClientIPAddrByClient check.\nCALL TDWM.TDWMAddClassificationForRule(\n   'MyFirstConfig',                        /* RulesetName */\n   'FILTER_IP_ADDRESS',                    /* RuleName */\n   'Address classification',               /* Description */\n   'CLIENTADDR',                           /* ClassificationType */\n   '55.77.100.224',                        /* ClassificationValue */\n   'IO',                                   /* ClassificationOperator */\n   'N'                                     /* ReplaceOption */);\nAdd client IP address criterion for client/user machine 55.77.100.225. Set ORing option to enable ClientIPAddrByClient check.\nCALL TDWM.TDWMAddClassificationForRule( \n   'MyFirstConfig',                        /* RulesetName */\n   'FILTER_IP_ADDRESS’,                    /* RuleName */\n   'Address classification',               /* Description */\n   'CLIENTADDR',                           /* ClassificationType */\n   '55.77.100.225',                        /* ClassificationValue */\n   'IO',                                   /* ClassificationOperator */\n   'N'                                     /* ReplaceOption */);\n4. Enable the ﬁlter in the default state. For a ﬁlter, the StateLimit is not applicable.\nLake - Monitor Resources and Performance\nPage 355 of 420CALL TDWM.TDWMAddLimitForRuleState(\n   'MyFirstConfig',                       /* RulesetName */\n   'FILTER_IP_ADDRESS',                   /* RuleName */\n   'DEFAULT',                             /* StateName */\n   'Default limit',                       /* Description */\n   NULL,                                  /* StateLimit */\n   'E',                                   /* Action */\n   'N'                                    /* ReplaceAction */);\n5. Enable the ﬁlter rule (at the rule level).\nCALL TDWM.TDWMManageRule(\n   'MyFirstConfig',                     /* RulesetName */\n   'FILTER_IP_ADDRESS',                 /* RuleName */\n   'E'                                  /* Operation */);\n6. Activate the MyFirstConﬁg ruleset with the new ﬁlter rule.\nCALL TDWM.TDWMActivateRuleset(\n  'MyFirstConfig',                      /* RulesetName */);\nCreate System Throttle or ARM\nIn the MyFirstConﬁg ruleset, create a member system throttle called TableA_FTS to set a concurrency limit of 1 with delay action for each user for requests that perform full table scans\non the myDB.TableA table with estimated minimum total processing time of 3600 seconds from the WebApp application. This throttle is cannot be overridden.\nThe TASM rule attributes are:\nRuleset name: MyFirstConﬁg\nSystem throttle name: TableA_FTS\nDescription: Member throttle FTS on myDB.TableA from WebApp\nThrottle type: Member\nQualiﬁcations:\nApplication: WebApp\nTable: myDB.TableA\nSubcriteria on myDB.TableA: Full Table Scan and minimum total process time of 3600 seconds\nLimit: 1\nThe API call sequence:\n1. The desired ruleset name, MyFirstConﬁg, is known, so the TDWM.Conﬁgurations table need not be queried.\n2. Create a system throttle called TableA_FTS without any classiﬁcation criteria.\nCALL TDWM.TDWMCreateSystemThrottle(\n  'MyFirstConfig',    /* ruleset name */\n  'TableA_FTS',       /* throttle name */\n  'Member throttle FTS on myDB.TableA from WebApp' /* description */,\n  'DM',               /* 'D': disable override, 'M': member type */\n  'N'                 /* not replace */);\n3. Add classiﬁcation criteria.\nAdd application criterion:\nCALL TDWM.TDWMAddClassificationForRule(\n  'MyFirstConfig',               /* ruleset name */\n  'TableA_FTS',                  /* rule name */\n  'Application classification',  /* description */\n  'APPL',                        /* application criterion type */\n  'WebApp',                      /* APPL = WebApp */\n  'I',                           /* Inclusion criterion APPL = WebApp */\n  'N'                            /* Not a replace */);\nAdd table type criterion:\nCALL TDWM.TDWMAddClassificationForRule(\n  'MyFirstConfig',              /* ruleset name */\n  'TableA_FTS',                 /* rule name */\n  'Table classification',       /* description */\n  'TABLE',                      /* table criterion type */\n  'myDB.TableA',                /* TABLE = myDB.TableA */\n  'I',                          /* Inclusion criterion */\n  'N'                           /* Not a replace */);\n4. Add sub-criteria for table criterion.\nAdd full table scan sub-criterion for target myDB.TableA:\nLake - Monitor Resources and Performance\nPage 356 of 420CALL TDWM.TDWMAddClassificationForTarget( \n  'MyFirstConfig',              /* ruleset name */\n  'TableA_FTS',                 /* rule name */\n  'TABLE',                      /* Target: TABLE criterion type */\n  'myDB.TableA',                /* Target: TABLE = myDB.TableA */\n  'FTSCAN sub-criterion',       /* description */\n  'FTSCAN',                     /* full table scan type */\n  NULL,                         /* TargetValue not needed */ \n  'I',                          /* Inclusion criterion FTSCAN */\n  'N'                           /* Not a replace */);\nAdd minimum step time sub-criterion for target myDB.TableA:\nCALL TDWM.TDWMAddClassificationForTarget( \n  'MyFirstConfig',               /* ruleset name */\n  'TableA_FTS',                  /* rule name */\n  'TABLE',                       /* Target: TABLE criterion type */\n  'myDB.TableA',                 /* Target: TABLE = myDB.TableA */\n  'Min step time sub-criterion', /* description */\n  'MINSTEPTIME',                 /* minimum step time */\n  '3600',                        /* min >= 3600 seconds */\n  'I',                           /* Inclusion criterion */\n  'N'                            /* Not a replace */);\n5. Set the default limit for the system throttle:\nCALL TDWM.TDWMAddLimitForRuleState(\n  'MyFirstConfig',               /* ruleset name */\n  'TableA_FTS',                  /* rule name */\n  'Default’,                     /* state name */\n  'Default limit',               /* description */\n  '1',                           /* limit */\n  'D'                            /* delay */\n  'N'                            /* Not a replace */);\n6. Enable the system throttle:\nCALL TDWM.TDWMManageRule(\n  'MyFirstConfig',               /* ruleset name */\n  'TableA_FTS',                  /* rule name */\n  'E'                            /* enable throttle */);\n7. Call TDWM.TDWMActivateRuleset to activate the MyFirstConﬁg ruleset with the new throttle.\nCALL TDWM.TDWMActivateRuleset(\n  'MyFirstConfig'      /* ruleset name */);\nDelete System Throttle, Arrival Rate Meter , or Filter\n1. If you want to delete a system throttle, arrival rate meter, or ﬁlter in a speciﬁc ruleset, retrieve the desired ruleset name from the TDWM.Conﬁgurations table.\n2. Call the XSP TDWM.TDWMDeleteRule to delete a system throttle, arrival rate meter, or ﬁlter by specifying its name.\nCALL TDWM.TDWMDeleteRule(\n  'MyFirstConfig',         /* ruleset name */\n  'Throttle_AcctDDL'       /* throttle name */);\n3. Call the XSP TDWM.TDWMActivateRuleset to activate the updated MyFirstConﬁg ruleset, which no longer has the system throttle, arrival rate meter, or ﬁlter.\nCALL TDWM.TDWMActivateRuleset(\n  'MyFirstConfig'          /* ruleset name */);\nUpdates Attributes of Rulesets\nThis XSP updates attributes of a speciﬁc ruleset. You can specify their new values to modify multiple attributes. An error occurs if the row in the TDWM.Conﬁgurations table does not\nmeet the following condition (representing the speciﬁed ruleset).\nConﬁgurations.ConﬁgName = RulesetName parameter\nDepending on the attributes being updated, this XSP updates one or more columns of the TDWM.Conﬁgurations table.\nREPLACE PROCEDURE TDWM.TDWMSetRulesetAttr \n(  IN RulesetName            TD_ANYTYPE,\n   IN NewRulesetName         TD_ANYTYPE,\n   IN NewEventInterval    INTEGER,\n   IN NewDashboardInterval   INTEGER,\n   IN NewLoggingInterval  INTEGER,\n   IN NewExceptionInterval   INTEGER,\nLake - Monitor Resources and Performance\nPage 357 of 420   IN NewFlexActionInterval  INTEGER,\n   IN NewBlockerCycles    VARCHAR(20) CHARACTER SET LATIN,\n   IN NewBlockerAction    VARCHAR(20) CHARACTER SET LATIN,\n   IN NewActivationOptions   VARCHAR(20) CHARACTER SET LATIN,\n   IN NewTSAutoDecay  CHAR(1) CHARACTER SET LATIN,\n   IN NewAvailAWTDefinition   VARCHAR(20) CHARACTER SET LATIN,\n   IN NewOtherOptions VARCHAR(20) CHARACTER SET LATIN \n) \n  ...\nWorkload Management: Ruleset Views\nThe following database views support the retrieval capabilities using SQL to view TASM rules in any ruleset.\nTDWM.RuleInfoV\nTDWM.ClassiﬁcationForRuleV\nTDWM.ClassiﬁcationForTargetV\nTDWM.RuleStateLimitV\nTDWM.WorkloadInfoV\nTDWM.WorkloadPlanEnvV\nA multi-step example that makes use of many of these views to recreate a system throttle is described in Example setup: Recreate/Clone a System Throttle.\nExample setup: Recreate/Clone a System Throttle\nThis is a multi-part example to illustrate the process of recreating/cloning a system throttle named 'TableA_FTS' of the ruleset 'TestRuleset' in another ruleset named 'ProdRuleset' using\nTDWM views and Workload Management Ruleset APIs. The new throttle in 'ProdRuleset' will have the same rule name, attributes, classiﬁcation criteria, classiﬁcation sub-criteria, and\nstate limit.\n1. Create a new throttle 'TableA_FTS' in 'ProdRuleset' with the same attributes of 'TableA_FTS' in 'TestRuleset' (but without classiﬁcation criteria, classiﬁcation sub-criteria, and state\nlimit).\nSee Example 2 in TDWM.RuleInfoV.\n2. Add the same classiﬁcation criteria of 'TableA_FTS' in 'TestRuleset' to the new throttle.\nSee Example 2 in TDWM.ClassiﬁcationForRuleV.\n3. Add the same classiﬁcation sub-criteria of 'TableA_FTS' in 'TestRuleset' to the new throttle.\nSee Example 2 in TDWM.ClassiﬁcationForTargetV.\n4. Set the same state limit of 'TableA_FTS' in 'TestRuleset' for the new throttle.\nSee Example 2 in TDWM.RuleStateLimitV.\n5. Enable the rule and activate ruleset to make 'TableA_FTS' in 'ProdRuleset' operational.\nSee Example 2 in TDWM.RuleStateLimitV.\nTDWM.RuleInfoV\nReturns a list of TASM rules in every ruleset. One row is returned for each of the following rules: ﬁlter, (arrival rate) meter, system (query) throttle, utility limit, utility session, workload,\nsession throttle, workload group, virtual partition throttle, and AWT resource limit.\nTDWM.RuleInfoV Syntax\nExamples: TDWM.RuleInfoV\nTDWM.RuleInfoV Syntax\nREPLACE VIEW TDWM.RuleInfoV \n  (RulesetName ,\n   RuleId,\n   RuleName , \n   RuleType ,\n   RuleStatus ,\n   RuleAttributes ,\n   RuleDescription\n   )  AS\nSELECT \n  ...\nSyntax Elements\nRulesetName\nRuleset name.\nRuleId\nRule ID.\nRuleName\nRule name.\nRuleType\nRule type. Possible values:\nLake - Monitor Resources and Performance\nPage 358 of 420'Filter'\n'Meter': Arrival rate meter\n'System Throttle'\n'Utility Limit'\n'Utility Session'\n'Workload'\n'Session Throttle'\n'Workload Group'\n'VPartition Throttle': Virtual partition throttle\n'Res Limit - AWT': AWT resource limit\nRuleStatus\nIndicates if a rule is enabled or disabled. Possible values:\n'E': Enabled\n'D': Disabled\nRuleAttributes\nMultiple attributes can be returned. Possible values:\nIf RuleType is 'Meter', then\n'C': Collective\n'D': Disable manual release or abort\n'L': Log only (warning mode)\nIf RuleType is 'Filter', then\n'L': Log only (warning mode)\nBlank: Reject if qualiﬁed\nIf RuleType is 'System Throttle', then\n'C': Collective\n'I': Individual\n'M': Member\n'D': Disable manual release or abort\n'C', 'I', and 'M' are mutually exclusive.\nIf RuleType is another value, then\n'C': Collective\nRuleDescription\nDescription of a rule.\nExamples: TDWM.RuleInfoV\nExample 1: List rules in the ruleset 'Comp_ruleset1' and their attributes\nQuery\nSELECT RuleId, RuleName, RuleType, RuleStatus, RuleAttributes AS RuleAttr, \n       RuleDescription AS RuleDesc\nFROM TDWM.RuleInfoV \nWHERE RulesetName = 'Comp_ruleset1'\nORDER BY RuleType, RuleName;\nOutput\nRuleId  RuleName                     RuleType             RuleStatus  RuleAttr  RuleDesc\n------  ---------------------------  -------------------  ----------  --------  --------------\n   721  FILTER_DSSACCT5              Filter               E           L         Filter All-AMP …\n   720  FILTER_DSSUSER9              Filter               E\n   723  ARM_DSSACT123                Meter                E           C\n   ...\n   736  AWT_UTIL                     Res Limit - AWT      E           C         Utility AWT …\n   729  SESTHROTTLE_DSS              Session Throttle     E           C\n   ...\n   727  THROTTLE_DSSACCTSTR123       System Throttle      E           I\n   726  THROTTLE_DSSPROF123          System Throttle      E           M         Query throttle …\n   728  THROTTLE_TACTUSER            System Throttle      E           C\n   730  UTIL_LOAD                    Utility Limit        E           C\n   ...\n   715  FastLoad+MultiLoad-Default   Utility Session      E           C\n   717  FastLoad+MultiLoad-Large     Utility Session      E           C\n   716  FastLoad+MultiLoad-Small     Utility Session      E           C\n   737  VP1_THROTTLE                 VPartition Throttle  E           C\n   ...\n   732  WD_DSSLG1                    Workload             E           C\n   734  WD_DSSTS1                    Workload             E           C\n   731  WD_TACT1                     Workload             E           C\n   733  WD_UTILLOAD                  Workload             E           C\nLake - Monitor Resources and Performance\nPage 359 of 420   735  WD_UTILOTHER                 Workload             E           C\n   738  WDGRP_DSS                    Workload Group       E           C\nExample 2: Create a new throttle\nThis example illustrates step #1 in Example setup: Recreate/Clone a System Throttle (Create a new throttle 'TableA_FTS' in 'ProdRuleset' with the same attributes of 'TableA_FTS' in\n'TestRuleset' (but without classiﬁcation criteria, classiﬁcation sub-criteria, and state limit)).\nBTEQ script\n/*****************************************************************\n* Step 1:  Create new rule with same attributes.\n*****************************************************************/\n.SET TITLEDASHES OFF\n.EXPORT DATA FILE=TDWM_RuleInfo_Temp_P1.exp\nSELECT RuleName        (TITLE ''),\n       RuleAttributes  (TITLE ''),\n       RuleDescription (TITLE '')\nFROM TDWM.RuleInfoV\nWHERE RulesetName = 'TestRuleset'\n  AND RuleType = 'System Throttle'\n  AND RuleName = 'TableA_FTS';\n.EXPORT RESET\n.SET TITLEDASHES ON\n.IMPORT DATA FILE=TDWM_RuleInfo_Temp_P1.exp;\n.REPEAT *\nusing (RuleName         VARCHAR(30), \n       RuleAttributes   VARCHAR(20), \n       RuleDescription  VARCHAR(80))\ncall TDWM.TDWMCreateSystemThrottle (\n     'ProdRuleset'          /* RulesetName */,\n     :RuleName              /* ThrottleName */, \n     :RuleDescription       /* Description */,\n     :RuleAttributes        /* Attributes */,\n     'N'                    /* ReplaceOption */);\n.IMPORT RESET\nResult\n'TableA_FTS' is created in 'ProdRuleset' with the same rule attributes as 'TableA_FTS' in 'TestRuleset'.\nQuerying the view TDWM.RuleInfoV returns the same results for the source and new throttle except that RuleStatus of 'TableA_FTS' in 'ProdRuleset' is 'D' (disabled).\n    RulesetName TestRuleset\n       RuleName TableA_FTS\n       RuleType System Throttle\n     RuleStatus E\n RuleAttributes DM\nRuleDescription Member throttle FTS on myDB.TableA from WebApp\n    RulesetName ProdRuleset\n       RuleName TableA_FTS\n       RuleType System Throttle\n     RuleStatus D\n RuleAttributes DM\nRuleDescription Member throttle FTS on myDB.TableA from WebApp\nExample 3: Analyze the Effectiveness of a System Throttle\nThis example shows how to use the view TDWM.RuleInfoV with DBQL data (i.e., DBC.QryLog) to analyze the effectiveness of a system throttle. More speciﬁcally, retrieve the following\nmetrics:\nNumber of delayed queries due to this throttle during a speciﬁc period\nMinimum, maximum, and average delay time\nSuppose the throttle is 'Throttle_Proﬁle1' in the ruleset 'TestConﬁg'. The TDWMRuleID column in the view DBC.QryLog indicates ID of the TASM rule which caused the delay.\nThe following SQL statement retrieves RuleId of 'Throttle_Proﬁle1' from TDWM.RuleInfoV to join with DBC.QryLog to get number of delayed queries, minimum, maximum, and average\ndelay time.\nQuery\nLake - Monitor Resources and Performance\nPage 360 of 420SELECT COUNT(*) AS DelayCount, MIN(DelayTime) AS MIN_DelayTime, MAX(DelayTime) AS MAX_DelayTime, AVG(DelayTime) AS AVG_DelayTime\nFROM TDWM.RuleInfoV R, DBC.QryLog Q\nWHERE R.RulesetName = 'TestConfig'\n  AND R.Rulename = 'Throttle_Profile1'\n  AND R.RuleId = Q.TDWMRuleID\n  AND Q.DelayTime > 0\n  AND Q.StartTime >= TIMESTAMP '2025-04-14 00:00:00' and Q.StartTime < TIMESTAMP '2025-04-21 00:00:00';\nOutput\n DelayCount   MIN_DelayTime   MAX_DelayTime   AVG_DelayTime\n-----------  --------------  --------------  --------------\n     205883           0.010           4.180           0.377\nTDWM.ClassificationForRuleV\nReturns classiﬁcation criteria of existing rules/workloads. One row is returned for each classiﬁcation criterion of a rule/workload.\nClassiﬁcation criteria for a target (or sub-criteria) of a rule/workload can be retrieved using TDWM.ClassiﬁcationForTargetV.\nTDWM.ClassiﬁcationForRuleV Syntax\nREPLACE VIEW TDWM.ClassificationForRuleV\n  (RulesetName,\n   RuleId,\n   RuleName ,\n   RuleType ,\n   ClassificationType , \n   ClassificationValue ,\n   ClassificationOperator ,\n   ClassificationTarget ,\n   ClassificationDesc\n   )  AS\nSELECT \n       ...\nSyntax Elements\nRulesetName\nRuleset name.\nRuleId\nRule ID or workload ID.\nRuleName\nRule name or workload name.\nClassiﬁcationType\nSame as the element ClassiﬁcationType of the ruleset API TDWM.TDWMAddClassiﬁcationForRule. See TDWMAddClassiﬁcationForRule Syntax Elements.\nClassiﬁcationValue\nSame as the element ClassiﬁcationValue of the ruleset API TDWM.TDWMAddClassiﬁcationForRule. See TDWMAddClassiﬁcationForRule Syntax Elements.\nClassiﬁcationOperator\nSame as the element ClassiﬁcationOperator of the ruleset API TDWM.TDWMAddClassiﬁcationForRule. See TDWMAddClassiﬁcationForRule Syntax Elements.\nClassiﬁcationTarget\nPossible values:\nY - This target has classiﬁcation sub-criteria.\nN - This target does not have any classiﬁcation sub-criteria\nClassiﬁcationDesc\nDescription of crtiterion.\nExamples: TDWM.ClassiﬁcationForRuleV\nExample 1: List classiﬁcation criteria of rules in the ruleset 'T estConﬁg'\nQuery\nSELECT RuleType, RuleName, ClassificationType AS ClassType, \n       ClassificationOperator AS ClassOp, ClassificationValue AS ClassValue, \n       ClassificationTarget AS ClassTarget\nFROM TDWM.ClassificationForRuleV\nWHERE Rulesetname = 'TestConfig'\nORDER BY RuleType, RuleName;\nOutput\nRuleType         RuleName         ClassType        ClassOp  ClassValue           ClassTarget\n---------------  ---------------  ---------------  -------  -------------------  -----------\nLake - Monitor Resources and Performance\nPage 361 of 420Filter           FTS_Filter       TABLE            I        DB1.VLTABLE          Y\n...\nSystem Throttle  AllUsers         USER             I        USER*                N\nSystem Throttle  Huge_Join        TABLE            I        DB2.HUGETABLE        Y\n...\nWorkload         H-WD             ACCTSTR          I        $H*                  N\n...\nWorkload         MM               MINTOTALTIME     I        10                   N\nWorkload         MM               MAXTOTALTIME     I        50                   N\n...\nWorkload         TC               MAXTOTALTIME     I        1                    N\nWorkload         TC               ALLAMP           I        N                    N\n...\nWorkload         TDaaS_High       QUERYBAND        I        TDaaS_Priority=High  N\nWorkload         TDaaS_High       USER             I        TDaaS*               N\n...\nExample 2: Add classiﬁcation criteria to new system throttle\nThis example illustrates step #2 in Example setup: Recreate/Clone a System Throttle (Add the same classiﬁcation criteria of 'TableA_FTS' in 'TestRuleset' to the new throttle).\nBTEQ script\n/*****************************************************************\n* Step 2:  Add rule classification criteria\n*****************************************************************/\n.SET TITLEDASHES OFF\n.EXPORT DATA FILE=TDWM_RuleInfo_Temp_P2.exp\nSELECT RuleName               (TITLE ''),\n       ClassificationType     (TITLE ''),\n       ClassificationValue    (TITLE ''),\n       ClassificationOperator (TITLE ''),\n       ClassificationDesc     (TITLE '')\nFROM TDWM.ClassificationForRuleV\nWHERE RulesetName = 'TestRuleset'\n  AND RuleType = 'System Throttle'\n  AND RuleName = 'TableA_FTS';\n.EXPORT RESET\n.SET TITLEDASHES ON\n.IMPORT DATA FILE=TDWM_RuleInfo_Temp_P2.exp;\n.REPEAT *\nusing (RuleName                 VARCHAR(30), \n       ClassificationType       VARCHAR(20),\n       ClassificationValue      VARCHAR(30), \n       ClassificationOperator   VARCHAR(6),\n       ClassificationDesc       VARCHAR(80))\nCALL TDWM.TDWMAddClassificationForRule(\n     'ProdRuleset'              /* RulesetName */,\n     :RuleName                  /* RuleName */,\n     :ClassificationDesc        /* Description */,\n     :ClassificationType        /* ClassificationType */,\n     :ClassificationValue       /* ClassificationValue */,\n     :ClassificationOperator    /* ClassificationOperator */,\n     'N'                        /* ReplaceOption */);\n.IMPORT RESET\nResult\n'TableA_FTS' in 'ProdRuleset' has the same classiﬁcation criteria as 'TableA_FTS' in 'TestRuleset' except for ClassiﬁcationTarget value. The reason is that sub-criteria have not been\nadded to 'TableA_FTS' in 'ProdRuleset' (step #3 of the process - Adding the same classiﬁcation sub-criteria of 'TableA_FTS' in 'TestRuleset' to the new throttle), addressed in Example 2\nin TDWM.ClassiﬁcationForTargetV.\nQuerying the view TDWM.ClassiﬁcationForRuleV returns the following results for the source and new throttle.\n           RulesetName TestRuleset\n              RuleName TableA_FTS\n    ClassificationType APPL\n   ClassificationValue WebApp\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget N\n           RulesetName TestRuleset\nLake - Monitor Resources and Performance\nPage 362 of 420              RuleName TableA_FTS\n    ClassificationType TABLE\n   ClassificationValue myDB.TableA\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget Y\n           RulesetName ProdRuleset\n              RuleName TableA_FTS\n    ClassificationType APPL\n   ClassificationValue WebApp\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget N\n           RulesetName ProdRuleset\n              RuleName TableA_FTS\n    ClassificationType TABLE\n   ClassificationValue myDB.TableA\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget N                 (no sub-criteria)\nTDWM.ClassificationForTargetV\nReturns one row per sub-criterion for a target group classiﬁcation (e.g., database, table, etc.) of a rule/workload.\nTDWM.ClassiﬁcationForTargetV Syntax\nExamples: ClassiﬁcationForTargetV\nTDWM.ClassiﬁcationForT argetV Syntax\nREPLACE VIEW TDWM.ClassificationForTargetV\n  (RulesetName ,\n   RuleId,\n   RuleName ,\n   RuleType ,\n   TargetType ,\n   TargetValue , \n   TargetClassificationType , \n   TargetClassificationValue ,\n   TargetClassificationOperator ,\n   TargetClassificationDesc\n   )  AS\nSELECT \n   ...\nSyntax Elements\nRulesetName\nRuleset name.\nRuleId\nRule ID or workload ID.\nRuleName\nRule name or workload name.\nTargetType\nSame as the TargetType element in TDWMAddClassiﬁcationForTarget Syntax Elements.\nTargetValue\nSame as the TargetValue element in TDWMAddClassiﬁcationForTarget Syntax Elements.\nTargetClassiﬁcationType\nSame as the ClassiﬁcationType element in TDWMAddClassiﬁcationForTarget Syntax Elements.\nTargetClassiﬁcationValue\nSame as the ClassiﬁcationValue element in TDWMAddClassiﬁcationForTarget Syntax Elements.\nTargetClassiﬁcationOperator\nSame as the ClassiﬁcationOperator element in TDWMAddClassiﬁcationForTarget Syntax Elements.\nTargetClassiﬁcationDesc\nDescription of target criterion.\nExamples: ClassiﬁcationForT argetV\nExample 1: List classiﬁcation sub-criteria of each rule in 'T estConﬁg' ruleset\nQuery\nLake - Monitor Resources and Performance\nPage 363 of 420SELECT RuleName, RuleType, TargetType AS ObjType, TargetValue AS ObjValue,\n       TargetClassificationType AS TarClassType, \n       TargetClassificationValue AS TarClassVal, \n       TargetClassificationOperator AS TarClassOp\nFROM TDWM.ClassificationForTargetV\nWHERE RulesetName = 'TestConfig' \nORDER BY RuleName, TargetValue, TargetType;\nOutput\nRuleName      RuleType          ObjType     ObjValue      TarClassType  TarClassVal   TarClassOp\n------------  ----------------  ----------  ------------  ------------  ------------  ----------\nHugeFTS       Filter            TABLE       HUGE_TABLE    FTSCAN        Y             I\nVLTable_Join  System Throttle   TABLE       VLDB.VLTABLE  MINSTEPROWS   10000000      I\nVLTable_Join  System Throttle   TABLE       VLDB.VLTABLE  STMT          M             I\nVLTable_Join  System Throttle   TABLE       VLDB.VLTABLE  MINACCPCT     40            I\nVLTable_Join  System Throttle   TABLE       VLDB.VLTABLE  JOIN          A             I\n...\nExample 2: Recreate System Throttle\nThis example illustrates step #3 in Example setup: Recreate/Clone a System Throttle (Adding the same classiﬁcation sub-criteria of 'TableA_FTS' in 'TestRuleset' to the new throttle).\nBTEQ script\n/*****************************************************************\n* Step 3:  Add rule sub-classification criteria (if any)\n*****************************************************************/\n.SET TITLEDASHES OFF\n.EXPORT DATA FILE=TDWM_RuleInfo_Temp_P3.exp\nSELECT RuleName                     (TITLE ''),\n          TargetType                   (TITLE ''),\n          TargetValue                  (TITLE ''),\n          TargetClassificationType     (TITLE ''),\n          TargetClassificationValue    (TITLE ''),\n          TargetClassificationOperator (TITLE ''),\n          TargetClassificationDesc     (TITLE '')\n   FROM TDWM.ClassificationForTargetV\n   WHERE RulesetName = 'TestRuleset'\n     AND RuleType = 'System Throttle'\n     AND RuleName = 'TableA_FTS';\n.EXPORT RESET\n.SET TITLEDASHES ON\n.IMPORT DATA FILE=TDWM_RuleInfo_Temp_P3.exp;\n.REPEAT *\nusing (RuleName                       VARCHAR(30), \n       TargetType                     VARCHAR(20),\n       TargetValue                    VARCHAR(30),\n       TargetClassificationType       VARCHAR(20),\n       TargetClassificationValue      VARCHAR(30), \n       TargetClassificationOperator   VARCHAR(6),\n       TargetClassificationDesc       VARCHAR(80))\nCALL TDWM.TDWMAddClassificationForTarget(\n     'ProdRuleset'                  /* RulesetName */,\n     :RuleName                      /* RuleName */,\n     :TargetType                    /* TargetType */,\n     :TargetValue                   /* TargetValue */,\n     :TargetClassificationDesc      /* Description */,\n     :TargetClassificationType      /* ClassificationType */,\n     :TargetClassificationValue     /* ClassificationValue */,\n     :TargetClassificationOperator  /* ClassificationOperator */,\n     'N'                            /* ReplaceOption */);\n.IMPORT RESET\nResult\n'TableA_FTS' in 'ProdRuleset' has the same classiﬁcation criteria as 'TableA_FTS' in 'TestRuleset'.\nQuerying TDWM.ClassiﬁcationForTargetV (for sub-criteria) and TDWM.ClassiﬁcationForRuleV (for criteria) returns the following results for the source and new throttle\nLake - Monitor Resources and Performance\nPage 364 of 420                 RulesetName TestRuleset\n                    RuleName TableA_FTS\n                  TargetType TABLE\n                 TargetValue myDB.TableA\n    TargetClassificationType FTSCAN\n   TargetClassificationValue Y\nTargetClassificationOperator I\n                 RulesetName TestRuleset\n                    RuleName TableA_FTS\n                  TargetType TABLE\n                 TargetValue myDB.TableA\n    TargetClassificationType MINSTEPTIME\n   TargetClassificationValue 3600\nTargetClassificationOperator I\n                 RulesetName ProdRuleset\n                    RuleName TableA_FTS\n                  TargetType TABLE\n                 TargetValue myDB.TableA\n    TargetClassificationType FTSCAN\n   TargetClassificationValue Y\nTargetClassificationOperator I\n                 RulesetName ProdRuleset\n                    RuleName TableA_FTS\n                  TargetType TABLE\n                 TargetValue myDB.TableA\n    TargetClassificationType MINSTEPTIME\n   TargetClassificationValue 3600\nTargetClassificationOperator I\n/* Recheck ClassificationTarget value adding sub-criteria */\n           RulesetName TestRuleset\n              RuleName TableA_FTS\n    ClassificationType APPL\n   ClassificationValue WebApp\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget N\n           RulesetName TestRuleset\n              RuleName TableA_FTS\n    ClassificationType TABLE\n   ClassificationValue myDB.TableA\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget Y\n           RulesetName ProdRuleset\n              RuleName TableA_FTS\n    ClassificationType APPL\n   ClassificationValue WebApp\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget N\n           RulesetName ProdRuleset\n              RuleName TableA_FTS\n    ClassificationType TABLE\n   ClassificationValue myDB.TableA\nClassificationOperator I\n    ClassificationDesc\n  ClassificationTarget Y                 (sub-criteria added)\nExample 3: Diagnose an Unexpected Query Filter\nThis example illustrates using TDWM.ClassiﬁcationForRuleV to diagnose an unexpected query failure due to a ﬁlter rule.\nSuppose the current ruleset is 'TestConﬁg' and a SELECT statement fails with error 3149 as shown.\nSELECT * FROM db1.xltable;\nLake - Monitor Resources and Performance\nPage 365 of 420 *** Failure 3149 TDWM Filter violation for Query Request: For Rule Name 'Filter_XLtable'\nThe error message indicates the failure is due to the ﬁlter named 'Filter_XLTable'.\n1. Use the view TDWM.ClassiﬁcationForRuleV to retrieve classiﬁcation criteria of 'Filter_XLTable' in the ruleset 'TestConﬁg'.\nQuery\nSELECT * FROM TDWM.ClassificationForRuleV\nWHERE RulesetName = 'TestConfig'\n  AND RuleName = 'Filter_XLTable';\nResult:\n           RulesetName TestConfig\n                RuleId         917\n              RuleName Filter_XLtable\n              RuleType Filter\n    ClassificationType TABLE\n   ClassificationValue DB1.XLtable\nClassificationOperator I\n  ClassificationTarget Y\n    ClassificationDesc\nOne row indicates only one classiﬁcation criterion.\nThe ClassiﬁcationType and ClassiﬁcationValue columns indicate the classiﬁcation criterion is on the table 'DB1.XLtable' which matches the table in the failed SELECT\nstatement.\nThe value of ClassiﬁcationTarget is 'Y' which indicates the presence of sub-criteria. So, the next step is to retrieve sub-criteria.\n2. Use TDWM.ClassiﬁcationForTargetV to retrieve classiﬁcation sub-criteria of 'Filter_XLTable'.\nQuery\nSELECT * FROM TDWM.ClassificationForTargetV\nWHERE RulesetName = 'TestConfig'\n  AND RuleName = 'Filter_XLTable';\nResult\n                 RulesetName TestConfig\n                      RuleId         917\n                    RuleName Filter_XLtable\n                    RuleType Filter\n                  TargetType TABLE\n                 TargetValue DB1.XLtable\n    TargetClassificationType FTSCAN\n   TargetClassificationValue Y\nTargetClassificationOperator I\n    TargetClassificationDesc\nOne row indicates only one classiﬁcation sub-criterion.\nThe TargetClassiﬁcationType and TargetClassiﬁcationValue columns indicate the sub-criterion is FTSCAN (for full table scan).\n3. Diagnosis and correction:\nDiagnosis: Based on rule Filter_XLtable, the SELECT statement is failing because it is performing a full table scan on table 'DB1.XLtable' which is prohibited by the rule.\nCorrection: If possible, add a WHERE clause to the SELECT statement so that it doesn't perform a full table scan.\nSELECT * FROM db1.xltable where c1 = 1;\n            c1           c2\n   -----------  -----------\n             1            2\nTDWM.RuleStateLimitV\nReturns state limits of each rule. One row is returned for each state limit of an existing rule/workload.\nTDWM.RuleStateLimitV Syntax\nExamples: TDWM.RuleStateLimitV\nTDWM.RuleStateLimitV Syntax\nREPLACE VIEW TDWM.RuleStateLimitV \n  (RulesetName ,\n   RuleId,\n   RuleName , \n   RuleType ,\n   RuleStateId ,\n   RuleStateName ,\n   RuleStateLimit ,\nLake - Monitor Resources and Performance\nPage 366 of 420   RuleStateAction ,\n   RuleStateLimitDesc\n   )  AS\nSELECT \n  ...\nSyntax Elements\nRulesetName\nRuleset name.\nRuleId\nRule ID or workload ID.\nRuleName\nRule name or workload name.\nRuleType\nRule type. Possible values:\n'Filter'\n'Meter': Arrival rate meter\n'System Throttle'\n'Utility Limit'\n'Utility Session'\n'Workload'\n'Session Throttle'\n'Workload Group'\n'VPartition Throttle': Virtual partition throttle\n'Res Limit - AWT': AWT resource limit\nRuleStateId\nID of rule state.\nRuleStateName\nName of rule state.\nRuleStateLimit\nLimit of a speciﬁc rule state. Possible values depend on RuleType. Possible values:\n'Filter': NULL\n'Meter': Maximum query admission rate\n'System Throttle': Maximum concurrent queries\n'Utility Limit': Maximum concurrent utility jobs\n'Utility Session': Number of utility sessions\n'Workload': Maximum concurrent queries in a workload\n'Session Throttle': Maximum concurrent sessions\n'Workload Group': Maximum concurrent queries in a workload group\n'VPartition Throttle': Maximum concurrent queries in a virtual partition\n'Res Limit - AWT': Maximum percentage of total AWTs\nRuleStateAction\nAction of a speciﬁc rule state. Possible values depend on RuleType.\n'Filter'\n'E': Enabled\n'N': Disabled\nOther rule types:\n'D': Delay\n'R': Reject\nExamples: TDWM.RuleStateLimitV\nExample 1: List state limits of existing rules in ruleset 'Comp_ruleset1'\nQuery\nSELECT RuleId, RuleName, RuleType, RuleStateName AS State, \n       RuleStateLimit AS StateLimit, RuleStateAction AS Action\nFROM TDWM.RuleStateLimitV WHERE RulesetName = 'Comp_ruleset1'\nORDER BY RuleType, RuleName, RuleStateName;\nOutput\nRuleId  RuleName               RuleType             State     StateLimit     Action\n------  ---------------------  -------------------  --------  -------------  ------\n   721  FILTER_DSSACCT5        Filter               Default   ?              N\n   721  FILTER_DSSACCT5        Filter               State1    ?              E\n   720  FILTER_DSSUSER9        Filter               Default   ?              E\n   720  FILTER_DSSUSER9        Filter               State1    ?              N\n   723  ARM_DSSACT123          Meter                Default   15/M QT=0      D\n   723  ARM_DSSACT123          Meter                State1    5/M QT=0       D\n   722  ARM_DSSUSER            Meter                Default   20/M QT=0      D\nLake - Monitor Resources and Performance\nPage 367 of 420        ...\n   736  AWT_UTIL               Res Limit - AWT      Default   50             D\n   729  SESTHROTTLE_DSS        Session Throttle     Default   100            D\n        ...\n   726  THROTTLE_DSSPROF123    System Throttle      Default   1              D\n   726  THROTTLE_DSSPROF123    System Throttle      State1    15             D\n        ...\n   730  UTIL_LOAD              Utility Limit        Default   15             D\n   730  UTIL_LOAD              Utility Limit        State1    20             D\n        ...\n   712  FastExport-Default     Utility Session      Default   4              D\n   714  FastExport-Large       Utility Session      Default   4              D\n   713  FastExport-Small       Utility Session      Default   2              D\n        ...\n   737  VP1_THROTTLE           VPartition Throttle  Default   1200           D\n   737  VP1_THROTTLE           VPartition Throttle  State1    550            D\n        ...\n   731  WD_TACT1               Workload             Default   NoLimit        D\n   733  WD_UTILLOAD            Workload             Default   8              D\n   733  WD_UTILLOAD            Workload             State1    15             D\n   735  WD_UTILOTHER           Workload             Default   5              D\n   738  WDGRP_DSS              Workload Group       Default   50             D\n   738  WDGRP_DSS              Workload Group       State3    20             D\nExample 2: Set the state limit for the new throttle\nThis example illustrates Step #4 (Set the same state limit of 'TableA_FTS' in 'TestRuleset' for the new throttle) and Step #5 (Enable rule and activate ruleset) in Example setup:\nRecreate/Clone a System Throttle.\nBTEQ script\n/*****************************************************************\n* Step 4:  Add rule state limits and actions\n*****************************************************************/\n.SET TITLEDASHES OFF\n.EXPORT DATA FILE=TDWM_RuleInfo_Temp_P4.exp\nSELECT RuleName            (TITLE ''),\n       RuleStateName       (TITLE ''),\n       RuleStateLimit      (TITLE ''),\n       RuleStateAction     (TITLE ''),\n       RuleStateLimitDesc  (TITLE '')\nFROM TDWM.RuleStateLimitV\nWHERE RulesetName = 'TestRuleset'\n  AND RuleType = 'System Throttle'\n  AND RuleName = 'TableA_FTS';\n.EXPORT RESET\n.SET TITLEDASHES ON\n.IMPORT DATA FILE=TDWM_RuleInfo_Temp_P4.exp;\n.REPEAT *\nusing (RuleName                 VARCHAR(30),\n       RuleStateName            VARCHAR(30),\n       RuleStateLimit           VARCHAR(30),\n       RuleStateAction          VARCHAR(6),\n       RuleStateLimitDesc       VARCHAR(80))\nCALL TDWM.TDWMAddLimitForRuleState(\n     'ProdRuleset'              /* RulesetName */,\n     :RuleName                  /* RuleName */,\n     :RuleStateName             /* StateName */,\n     :RuleStateLimitDesc        /* Description */,\n     :RuleStateLimit            /* StateLimit */,\n     :RuleStateAction           /* Action */,\n     'N'                        /* ReplaceOption */);\n.IMPORT RESET\n/***************************************************************** \n* Step 5:  Enable the cloned rule.\n*****************************************************************/\nCALL TDWM.TDWMManageRule (\nLake - Monitor Resources and Performance\nPage 368 of 420     'ProdRuleset'          /* RulesetName */,\n     'TableA_FTS'           /* RuleName */,\n     'E'                    /* Operation */);\nResult\n'TableA_FTS' in 'ProdRuleset' has the same state limit as 'TableA_FTS' in 'TestRuleset'.\nQuerying TDWM.RuleStateLimitV returns the following results:\n       RulesetName TestRuleset\n          RuleName TableA_FTS\n     RuleStateName Default\n    RuleStateLimit 1\n   RuleStateAction D\nRuleStateLimitDesc\n       RulesetName ProdRuleset\n          RuleName TableA_FTS\n     RuleStateName Default\n    RuleStateLimit 1\n   RuleStateAction D\nRuleStateLimitDesc\n(Step #4) Throttle 'TableA_FTS' is completely recreated in 'ProdRuleset' with the same rule attributes, classiﬁcation criteria, classiﬁcation sub-criteria, and state limit as 'TableA_FTS' in\n'TestRuleset'; however, it is disabled. Do the following:\nEnable 'TableA_FTS' by calling TDWM.TDWMManageRule.\nActivate 'ProdRuleset by calling TDWM.TDWMActivateRuleset.\n(Step #5) Activate ProdRuleset to apply the changes if ProdRuleset is the currently active ruleset.\nSee \"Create System Throttle or ARM\" in Ruleset API Examples\nTDWM.WorkloadInfoV\nReturns a list of workload deﬁnitions (WDs) and their basic attributes. One row is returned for each WD.\nTDWM.WorkloadInfoV Syntax\nExample: TDWM.WorkloadInfoV\nTDWM.W orkloadInfoV Syntax\nREPLACE VIEW TDWM.WorkloadInfoV\n  (RulesetName ,\n   WorkloadId ,\n   WorkloadName , \n   WorkloadType ,\n   WorkloadStatus ,\n   WorkloadEvalOrder ,\n   VirtualPartition ,\n   WorkloadGroup ,\n   WorkloadDescription\n   )  AS\nSELECT \n      ...\nSyntax Elements\nRulesetName\nRuleset name.\nWorkloadId\nWorkload ID.\nWorkloadName\nWorkload name.\nWorkloadType\nWorkload type. Possible values:\n'Tactical': Tactical\n'SLG1': SLG Tier 1\n'SLG2': SLG Tier 2\n'SLG3': SLG Tier 3\n'SLG4': SLG Tier 4\n'SLG5': SLG Tier 5\n'TSTop': Timeshare top\nLake - Monitor Resources and Performance\nPage 369 of 420'TSHigh': Timeshare high\n'TSMed': Timeshare medium\n'TSLow': Timeshare low\nWorkloadStatus\nIndicates if a workload is enabled or disabled.\n'E': Enabled\n'D': Disabled\nWorkloadEvalOrder\nEvaluation order of a workload.\nVirutalPartition\nName of virtual partition to which this workload belongs.\nWorkloadGroup\nName of workload group to which this workload belongs.\nWorkloadDescription\nDescription of workload.\nExample: TDWM.W orkloadInfoV\nThis example lists existing workloads in the ruleset 'FirstConﬁg' and their attributes.\nQuery\nSELECT WorkloadId, WorkloadName, WorkloadType AS WDType, \n       WorkloadStatus AS Status, WorkloadEvalOrder AS EvalOrder, \n       WorkloadDescription AS Description\n  FROM TDWM.WorkloadInfoV \n WHERE RulesetName = 'TestConfig' \nORDER BY WorkloadEvalOrder;\nOutput\n WorkloadId  WorkloadName      WDType     Status  EvalOrder  Description\n-----------  ---------------   ---------  ------  ---------  ------------------------------------\n         13  WD-MapsMover      TSHigh     E               1\n        683  TDaaS_Critical    SLG1       E               2  SLG Tier 1 for TDaaS users\n        682  TDaaS_Important   SLG2       E               3  SLG Tier 2 for TDaaS users\n        681  TDaaS_High        TSHigh     E               4  Timeshare High for TDaaS users\n        680  TDaaS_Low         TSLow      E               5  Timeshare Low WD for TDaaS users\n        679  TDaaS_Medium      TSMed      E               6  Timeshare Medium for TDaaS users\n         15  T-WD              TSTop      E               7\n         16  H-WD              TSHigh     E               8\n         17  M-WD              TSMed      E               9\n         18  L-WD              TSLow      E              10\n         48  Tactical-WD       Tactical   E              11  Default Tactical WD for AcctStr $TA*\n         52  TC                Tactical   E              12  Default Tactical WD for total EPT \n         51  TT                TSTop      E              13  Default Timeshare Top WD for ... \n         50  MM                TSMed      E              14  Default Timeshare Medium WD for ... \n         49  LL                TSLow      E              15  Default Timeshare Low WD for ... \n         14  WD-Default        TSMed      E              16\nTDWM.WorkloadPlanEnvV\nReturns details for each planned environment of existing workload deﬁnitions (WDs). One row is returned per WD per planned environment.\nTDWM.WorkloadPlanEnvV Syntax\nExample: TDWM.WorkloadPlanEnvV\nTDWM.W orkloadPlanEnvV Syntax\nREPLACE VIEW TDWM.WorkloadPlanEnvV\n  (RulesetName ,\n   WorkloadId ,\n   WorkloadName , \n   PlannedEnvironment , \n   WorkloadEvalOrder ,\n   WorkloadType , \n   HoldRespTime ,\n   ServiceLevelGoal , \n   SLGAllocation , \n   SLGCPULimit , \n   SLGIOLimit , \n   OtherOption   \n   )  AS\nLake - Monitor Resources and Performance\nPage 370 of 420SELECT \n   ...\nSyntax Elements\nRulesetName\nRuleset name.\nWorkloadId\nWorkload ID.\nWorkloadName\nWorkload name.\nPlannedEnvironment\nPlanned environment name.\nWorkloadEvalOrder\nEvaluation order of a workload.\nWorkloadType\nWorkload type. Possible values:\n'Tactical': Tactical\n'SLG1': SLG Tier 1\n'SLG2': SLG Tier 2\n'SLG3': SLG Tier 3\n'SLG4': SLG Tier 4\n'SLG5': SLG Tier 5\n'TSTop': Timeshare top\n'TSHigh': Timeshare high\n'TSMed': Timeshare medium\n'TSLow': Timeshare low\nHoldRespTime\nHold response time.\nNONE: No hold response time.\nDEFAULT: Use default Always planned environment setting.\n'decimal': Hold response time in seconds.\nServiceLevelGoal\nService level goal (SLG) of the workload.\nNONE: No SLG\nDEFAULT: Use default Always planned environment setting.\n'<integer>% @ <decimal> seconds'\nFor example, '90% @ 2 seconds' means response time of 2 seconds and service percent of 90%.\n'<integer> rph': Throughput SLG as number of requests per hour.\nSLGAllocation\nResource allocation of an SLG workload.\nNULL: No SLG allocation.\n'decimal' : Resource allocation percentage for an SLG workload.\nSLGCPULimit\nCPU limit of an SLG workload.\nNONE: No SLG CPU limit.\n'<decimal>' : CPU percentage limit for an SLG workload.\nSLGIOLimit\nI/O limit of an SLG workload.\nNONE: No SLG I/O limit.\n'<decimal>' : I/O percentage limit for an SLG workload.\nOtherOption\nOther workload option. Currently, only one option is supported for SLG Tier 1 WD.\n'+Expedited': Use expedited AWT if the workload is SLG Tier 1.\n'-Expedited': Do not use expedited AWT if the workload is SLG Tier 1.\nExample: TDWM.W orkloadPlanEnvV\nThis example retrieves details of workloads in the ruleset 'TestConﬁg' with names containing 'DBA' or 'Load'.\nQuery\nSELECT\nWorkloadId,\nWorkloadName,\nPlannedEnvironment,\nWorkloadType,\nServiceLevelGoal,\nSLGAllocation,\nOtherOption\nLake - Monitor Resources and Performance\nPage 371 of 420FROM TDWM.WorkloadPlanEnvV\nWHERE RulesetName = 'TestRuleset'\nAND (WorkloadName like '%DSSPROF%' OR WorkloadName like '%TDaaS%')\nORDER BY RulesetName, PlannedEnvironment, WorkloadName;\nOutput\n WorkloadId  WorkloadName                    PlannedEnvironment              WorkloadType    ServiceLevelGoal      SLGAllocation  OtherOp\n-----------  ------------------------------  ------------------------------  --------------  --------------------  -------------  -------\n         96  TDaaS_Critical                  Always                          SLG1            NONE                  60.0           -Expedi\n         98  TDaaS_High                      Always                          TSHigh          NONE                  ?              ?\n         97  TDaaS_Important                 Always                          SLG2            NONE                  55.0           ?\n         99  TDaaS_Low                       Always                          TSLow           NONE                  ?              ?\n        100  TDaaS_Medium                    Always                          TSMed           NONE                  ?              ?\n        102  WD_DSSPROF1_SLG1                Always                          SLG1            100% @ 5 seconds      25.0           +Expedi\n        103  WD_DSSPROF3_SLG3                Always                          SLG3            90% @ 3.5 seconds     25.0           ?\n        104  WD_DSSPROF4_SLG4                Always                          SLG4            40 rph                25.0           ?\n        105  WD_DSSPROF5_SLG5                Always                          SLG5            NONE                  25.0           ?\n        226  WD_DSSPROF6_TS                  Always                          TSMed           NONE                  ?              ?\n         96  TDaaS_Critical                  UserDefEnv                      SLG1            DEFAULT               60.0           -Expedi\n         98  TDaaS_High                      UserDefEnv                      TSHigh          DEFAULT               ?              ?\n         97  TDaaS_Important                 UserDefEnv                      SLG2            DEFAULT               55.0           ?\n         99  TDaaS_Low                       UserDefEnv                      TSLow           DEFAULT               ?              ?\n        100  TDaaS_Medium                    UserDefEnv                      TSMed           DEFAULT               ?              ?\n        102  WD_DSSPROF1_SLG1                UserDefEnv                      SLG1            DEFAULT               20.0           +Expedi\n        103  WD_DSSPROF3_SLG3                UserDefEnv                      SLG3            75% @ 5 seconds       20.0           ?\n        104  WD_DSSPROF4_SLG4                UserDefEnv                      SLG4            25 rph                20.0           ?\n        105  WD_DSSPROF5_SLG5                UserDefEnv                      SLG4            DEFAULT               20.0           ?\n        226  WD_DSSPROF6_TS                  UserDefEnv                      TSLow           DEFAULT               ?              ?\nAutomated Statistics Management APIs\nThe following sections document the Automated Statistics Management feature including APIs in the form of stored procedures that allow callers to control its behavior and monitor its\ntuning activity.\nBefore using the Automated Statistic Management external stored procedures, you must familiarize yourself with the following topics:\nOverview of Automated Statistics Management (AutoStats)\nDashboard Reporting APIs\nManual Control and Customization APIs\nOverview of Automated Statistics Management (AutoStats)\nAutomated Statistics Management or AutoStats is an autonomous tuning feature that collects statistics on selected tables and columns to improve query optimization and performance.\nIt analyzes logged query workloads and determines the subset of columns that would beneﬁt the most from having statistics collected on them. If the statistics subsequently become\nstale due to update activity on their underlying data, it automatically refreshes them. As workloads change over time, it removes individual statistics that no longer needed to reduce the\noverhead of maintaining them.\nUsers control which databases or tables are managed by AutoStats via new DDL statement syntax (AUTODBA keyword) and can optionally specify a “semi-autonmous” mode (WITH\nCHECK keyword) that requires approval of tuning recommendations prior to their application. AutoStats tuning is supported on the majority of data storage types offered in\nVantageCloud Lake including Block Storage, Object File System (OFS), and Native Object Store (NOS). For more information, refer to SQL Data Deﬁnition Language and Data Storage.\nAutoStats tuning operations run automatically as part of a background service within VantageCloud Lake. This service replaces the Teradata ViewpointViewpoint Stats Manager portlet\nthat controls AutoStats operations within VantageCloud Enterprise. As tables marked AUTODBA are created and loaded with data, AutoStats will begin collecting summary statistics on\nthem and, after observing queries on them, it will recommend additional detailed statistics on columns frequently used in accessing the data. Tuning recommendations made on\nAUTODBA marked objects will be automatically applied by the system in a fully autonomous fashion. For those objects that include the optional WITH CHECK clause,\nrecommendations are not applied until approved by users. APIs in the form of Stored Procedures allow users to review tuning recommendations which include supporting evidence\nthat describe their anticipated beneﬁt. For more information, see Manual Control and Customization APIs.\nDashboard APIs allow system administrators to monitor AutoStats tuning activity over time. A set of key performance indicators (KPIs) summarize daily tuning activity and its overhead.\nA separate Audit Trail API reports detailed information about individual tuning actions that occurred during a speciﬁed time period and can be used to diagnose issues that may result\nfrom AutoStats operations. For more information, see Dashboard Reporting APIs.\nDashboard Reporting APIs\nThe APIs documented in this section are suitable for a dashboard that monitors and reports system wide AutoDB Service job activity. Dashboard KPIs are broken down and reported\nby today, yesterday, and 30-day trend to allow users to easily identify trends and outliers over time. The intent of this reporting is to allow a system administrator or DBA to validate that\nAutoStats tuning is enabled and delivering value.\nDailyQueryActivity\nDailyTuningActivity\nDailyTuningOverhead\nDailyJobActivity\nDailyJobErrors\nAutoDBAObjects\nLake - Monitor Resources and Performance\nPage 372 of 420General API Usage\nDashboard APIs are in the form of SQL stored procedures residing within owning database TDStats whose output is typically in the form of relational dynamic result sets. Most APIs\noffer input parameters that limit the scope of their operation to a particular set of objects or queries. APIs typically have only a single JSON input parameter which supports an\nextensible set of one or more name-value pairs.\nREPLACE PROCEDURE TDStats.< APIName> (\n   IN jIn JSON(2000) CHARACTER SET UNICODE)\n   DYNAMIC RESULT SETS 1 \nCALL TDStats.< APIName> ( '{\"Param1_Name \":\"Param1_Value \", \"Param2_Name \":\"Param2_Value \",...}');\nDailyQueryActivity\nThis stored procedure reports daily number of logged queries referencing one or more AutoDBA marked objects over a speciﬁed period of time. Reported activity is limited to SQL\nstatement types that offer tuning opportunities such as Select, Insert, Update, Delete and Merge Into.\nDailyQueryActivity Syntax\nDailyQueryActivity Usage Notes\nDailyQueryActivity Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDStats\nSELECT ON the following DBC objects:\nDbase\nQryLogV\nQryLogXMLV\nDBQLQERTbl\nSELECT ON the following PDCRINFO objects:\nDBQLLogTbl_Hst\nDBQLXMLTbl_Hst\nSELECT ON TD_METRIC_SVC.AutoDbQryLogV\nDailyQueryActivity Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.DailyQueryActivity(\n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nBeginDate DATE Starting date for query activity.\nEndDate DATE Ending date for query activity.\nLogDatabaseName VARCHAR(128) Source of DBQL telemetry.\nSupported values are ‘DBC’ and ‘TD_METRIC_SVC'\n(default).\nByUser BOOLEAN When true, break down results by individual users.\nDefault is false.\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_DailyQueryActivity rather\nthan being returned as a dynamic result.\nDefault is false.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nReportDate DATE Date for reported usage.\nUserOrUtility VARCHAR(25) Name of user executing queries or Load Utility name.\nReturned only when ByUser is true.\nLake - Monitor Resources and Performance\nPage 373 of 420Column Name Data T ype Description\nNumQueriesForAutoDBA BIGINT Number of queries referencing AutoDBA designated\nobjects.\nNumQueriesForStatsTuning BIGINT Number of queries referencing AutoDBA designated\nobjects and having stats tuning opportunities.\nNumTableLoads BIGINT Number of bulk table load operations.\nQueryAmpCPUTime FLOAT Amp CPU usage from AutoDBA eligible queries as\nrecorded by DBQL.\nQueryParserCPUTime FLOAT Parser CPU usage from AutoDBA eligible queries as\nrecorded by DBQL.\nQueryTotalIOCount FLOAT IO usage from AutoDBA eligible queries as recorded by\nDBQL.\nTableLoadsUDICount BIGINT Total rows updated, deleted, or inserted during bulk loads.\nDailyQueryActivity Usage Notes\nReport returns an output row for each day between the speciﬁed BeginDate and EndDate.\nTo report the current day's activity, specify CURRENT_DATE for both BeginDate and EndDate.\nTo report yesterday's activity, specify CURRENT_DATE - 1 for both BeginDate and EndDate.\nIf BeginDate and EndDate are not speciﬁed, output is returned for the last 7 days.\nIf ByUser is false or unspeciﬁed, daily results include all users executing queries that reference AutoDBA objects.\nDailyQueryActivity Example\nThe following example reports query activity for the past three days.\nCALL TDSTATS.DAILYQUERYACTIVITY('{\"BeginDate\":\"CURRENT_DATE - 2\",\"EndDate\":\"CURRENT_DATE\"}');\nResult:\nReportDate NumQueriesForAutoDBA NumQueriesForStatsT uning QueryAmpCPUT ime QueryParserCPUT ime QueryT otalIOCount\n2024/02/04 268 237 135,160.944 10.656 549,924,918\n2024/02/05 38212 867 267,167.816 407.052 473,901,883\n2024/02/06 337 235 256,825.940 14.800 834,812,156\nDailyT uningActivity\nThis stored procedure reports the daily counts of the number of AutoStats tuning recommendations made as well as the number applied per database.\nDailyTuningActivity Syntax\nDailyTuningActivity Usage Notes\nDailyTuningActivity Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDSTATS\nDailyTuningActivity Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.DailyTuningActivity(\n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nBeginDate DATE Starting date for tuning activity.\nEndDate DATE Ending date for tuning activity.\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_DailyTuningActivity\nrather than being returned as a dynamic result.\nDefault is false.\nLake - Monitor Resources and Performance\nPage 374 of 420Dynamic SQL  Result Columns\nColumn Name Data T ype Description\nReportDate DATE Date reported for tuning action.\nDatabaseName CHAR(128) Database on which tuning action was made.\nIdentiﬁedMissingStats INTEGER Number of missing (new) statistics recommended.\nIdentiﬁedStaleStats INTEGER Number of stale statistics in need of refresh.\nIdentiﬁedUnusedStats INTEGER Number of unused stats that can be dropped.\nLoadEventsDetected INTEGER Number of table bulk load operations detected.\nMissingStatsApplied INTEGER Number of missing (new) stats applied as part of the initial\n(ﬁrst time) collection.\nStatsSubmitted INTEGER Number of statistics submitted for [re]collection including\nboth initial and refresh.\nStatsCollected INTEGER Number of submitted statistics that were collected and not\nskipped.\nThresholdSkipped INTEGER Number of submitted statistics that were skipped due to\nthe change-based threshold not being met.\nStatsDropped INTEGER Number of unused statistics that were dropped.\nCollectStatErrors INTEGER Number of errors from Collect Stats\nDropStatErrors INTEGER Number of errors from Drop Stats.\nDailyTuningActivity Usage Notes\nReport returns an output row for each day between the speciﬁed BeginDate and EndDate.\nTo report the current day's activity, specify CURRENT_DATE for both BeginDate and EndDate.\nTo report yesterday's activity, specify CURRENT_DATE - 1 for both BeginDate and EndDate.\nIf BeginDate and EndDate are not speciﬁed, output is returned for the last 7 days.\nDailyTuningActivity Example\nThe following example reports tuning activity for the past 3 days.\nCALL TDStats.DAILYTUNINGACTIVITY('{\"BeginDate\":\"CURRENT_DATE - 2\",\"EndDate\":\"CURRENT_DATE\"}');\nResult:\nReportDate DatabaseName IdentiﬁedMissingStats IdentiﬁedStaleStats IdentiﬁedUnusedStats StatsCollected ThresholdSkipped StatsDropped\n2024/20/04 TPCS 113 0 0 110 0 0\n2024/20/04 TPCH 68 0 0 71 0 0\n2024/20/05 TPCD 53 8 0 52 8 0\n2024/20/05 TPCH 35 12 0 36 12 0\n2024/20/06 TPCD 5 25 1 5 2 1\n2024/20/06 TCPH 2 34 0 2 4 0\nDailyT uningOverhead\nThis stored procedure reports daily CPU and IO usage for AutoStats tuning operations over a speciﬁed period of time as recorded by DBQL.\nDailyTuningOverhead Syntax\nDailyTuningOverhead Usage Notes\nDailyTuningOverhead Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDStats\nSELECT ON following DBC objects: StatsTbl, DBase, QryLogV\nSELECT ON TDaaS_DB\nSELECT ON TD_METRIC_SVC\nSELECT ON PDCRINFO.DBQLogTbl_Hst\nDailyTuningOverhead Syntax\nAPI Deﬁnition\nLake - Monitor Resources and Performance\nPage 375 of 420REPLACE PROCEDURE TDStats.DailyTuningOverhead (\n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1 ;\nJSON Input Keys\nJSON Key Data T ype Description\nBeginDate DATE Starting date for resource usage.\nEndDate DATE Ending date for resource usage.\nLogDatabaseName VARCHAR(128) Source of DBQL telemetry that reports resource usage.\nValid values are:\n'DBC'\n'TD_METRIC_SVC'\nDefault is 'TD_METRIC_SVC'.\nByJob BOOLEAN Break down results by AutoDba Tuning Job.\nDefault is false.\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_DailyTuningOverhead\nrather than being returned as a dynamic result.\nDefault is false.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nReportDate DATE Date of reported usage.\nAutoDbJobName VARCHAR(25) Name of AutoDb service job. Returned only when input\nparameter ByJob is true.\nStatsAnalysisAmpCPUTime FLOAT Amp CPU usage from statistics tuning analysis operations.\nStatsAnalysisParserCPUTime FLOAT Parser CPU usage from statistics tuning analysis\noperations.\nStatsAnalysisTotalIOCount FLOAT IO usage from tuning statistics analysis operations.\nStatsCollectAmpCPUTime FLOAT Amp CPU usage from statistics collections.\nStatsCollectParserCPUTime FLOAT Parser CPU usage from statistics collections.\nStatsCollectTotalIOCount FLOAT IO usage from statistics collections.\nDailyTuningOverhead Usage Notes\nReport returns an output row for each day between the speciﬁed BeginDate and EndDate.\nTo report the current day's resource usage, specify CURRENT_DATE for both BeginDate and EndDate.\nTo report yesterday's activity, specify CURRENT_DATE - 1 for both BeginDate and EndDate.\nIf BeginDate and EndDate are not speciﬁed, output is returned for the last 7 days.\nIf ByJob is false or unspeciﬁed, daily results include all AutoDba tuning jobs.\nDailyTuningOverhead Example\nThe following example reports tuning overhead for days within an speciﬁed date range.\nCALL TDSTATS.DAILYTUNINGOVERHEAD('{\"BeginDate\":\"2024-02-04\",\"EndDate\":\"2024-02-06\"}');\nResult:\nReportDate StatsAnalysisAMPCPUT ime StatsAnalysisCPUT ime StatsAnalysisT otalIOCount StatsCollectAmpCPUT ime StatsCollectParserCUT ime StatsCollectT otalIOCo\n2024/02/04805.404 382.864 27,740,234 149,956.204 18.768 171,017,493\n2024/02/05812.768 389.672 28,137,569 308,447.140 18.028 499,277,685\n2024/02/06796.000 363.388 27,611,268 13,170.412 1.392 11,939,461\nDailyJobActivity\nLake - Monitor Resources and Performance\nPage 376 of 420This stored procedure reports the activity levels and schedule of each AutoStats tuning job running under the AutoDB service. The reported jobs are scheduled and run automatically\nand require no user interaction.\nDailyJobActivity Syntax\nDailyJobActivity Usage Notes\nAutoDB Service Jobs for AutoStats\nDailyJobActivity Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, EXECUTE FUNCTION, SELECT ON TDSTATS\nSELECT ON TDaaS_Db\nDailyJobActivity Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.DailyJobActivity( \n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nBeginDate DATE Starting date for job activity.\nEndDate DATE Ending date for job activity.\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_DailyJobActivity rather\nthan being returned as a dynamic result.\nDefault is false.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nReportDate DATE Date for reported job activity.\nAutoDbJobName VARCHAR(20) Name of AutoDb Service job.\nJobSchedule VARCHAR(20) Scheduled wake-up interval.\nCompleted INTEGER Number of completed job runs.\nInProgress INTEGER Number of jobs currently in progress.\nSkipped INTEGER Number of job scheduled runs skipped due to system\nconditions, e.g., another run of the same job was still in\nprogress.\nFailed INTEGER Number of job runs with errors.\nAborted INTEGER Number of aborted job runs.\nWithWarning INTEGER Number of job runs that completed with warnings.\nMostRecentError TIMESTAMP Most recent job run with errors.\nErrorCodes VARCHAR(40) Error codes reported by job.\nDailyJobActivity Usage Notes\nPossible values for AutoDbJobName: stats_missing, stats_apply, stats_automate, stats_inline, stats_stale, stats_unused.\nReport returns an output row for each day between the speciﬁed BeginDate and EndDate.\nTo report the current day's activity, specify CURRENT_DATE for both BeginDate and EndDate.\nTo report yesterday's activity, specify CURRENT_DATE - 1 for both BeginDate and EndDate.\nIf BeginDate and EndDate are not speciﬁed, output is returned for the last 7 days.\nAutoDB Service Jobs for AutoStats\nThe following table lists system deﬁned jobs that perform AutoStats operations using automated scheduling provided by the AutoDb tenant service. Default schedules are subject to\nchange based on the system's observed activity levels over time.\nLake - Monitor Resources and Performance\nPage 377 of 420Job Name Default Schedule Description\nAnalyze Missing Stats Every 2 hours Recommend missing (new) statistics by analyzing DBQL\nquery logs.\nAnalyze Unused Stats Weekly Recommend dropping unused statistics by analyzing\nOptimizer usage counts as recorded by USECOUNT.\nApply Stat Recs Every 1 hour Apply recently approved recommendations to collect\nmissing (new) statistics and drop unused statistics.\nThe tuning recommendations on fully-autonomous\nAutoDBA marked objects are auto approved.\nAutomate Stats Every 1 hour Designate objects under AutoStats control within TDStats\nmetadata based on most recent AutoDBA data dictionary\nmetadata.\nInLine Event Trigger Every 5 minutes Trigger stats tuning based on detected InLine events such\nas bulk loads within the Parsing Engine.\nRefresh Stale Stats Every 6 hours Analyze all automated statistics for staleness and refresh if\nnecessary.\nSchedule Information\nTwo (2) hours is the assumed period of time for logging a representative query workload for recommending missing (new) stats.\nAll stats are routinely checked for potential staleness every 6 hours but tables undergoing load operations are checked within 5 minutes of load completion.\nIt can take up to 1 hour for newly marked AutoDBA objects to be analyzed by jobs for missing and stale stats. However, DBQL logging and USECOUNT tracking starts\nimmediately and will be included in the analysis. Conversely, it can take up to 1 hour for objects removed of their AutoDBA designation to be excluded by automated tuning\njobs.\nDBA approved recommendations for missing and unused stats on semi-autonomous designated tables can take up to 1 hour to be submitted for application and can take\nlonger to complete depending on the total number to be applied.\nThe weekly Analyze Unused Stat job assumes stats that originated from AutoStats recommendations and not used by the Query Optimizer within the past 31 days can be safely\ndropped.\nStats that originated as user deﬁned are retained for 93 days to support non-frequent but important usage such as quarterly reports.\nJob Conﬁguration and History\nDeﬁnitions of the AutoStats jobs listed above are conﬁgured in system table TDaaS_DB. Similarly, AutoStats job history is stored in table TDaaS_DB.AutoDBJobTbl.\nJob As-A-Service Users\nAll SQL-related work performed by AutoStats Jobs is executed by As-A-Service user TDaaS_AutoDB1 (or TDaaS_AutoDB2) which is created during the installation of the AutoDB\nService infrastructure. All SQL executed by these users is logged using DBQL (default level is standard in Lake) and labeled with well-deﬁned Query Bands as summarized in the\nfollowing table.\nDatabase Engine 20  User Session Query Band Possible Query Band V alues for AutoStats Jobs\nTDaaS_AutoDB1\nTDaaS_AutoDB2AutoDbaJobName stats_automate, stats_missing, stats_unused, stats_apply,\nstats_stale, stats_inline\nTDaaS_AutoDB1\nTDaaS_AutoDB2AutoDbaAction stats_analysis, stats_collect, stats_drop\nTDaaS_AutoDB1\nTDaaS_AutoDB2AutoDbaJobThread 0, 1, 2, 3, 4, 5\nThe TDaaS_AutoDB1/2 users are deﬁned with a system deﬁned proﬁle (TDAAS_USRPROFILELOW) that deﬁnes passwo rd policies along with an account string that informs TASM to\nclassify the priority of its work as TimeShare Low which reduces the impact on other higher priority customer work.\nDailyJobActivity Example\nThe following example reports job activity for the past week.\nCALL TDSTATS.DAILYJOBACTIVITY('{\"BeginDate\":\"CURRENT_DATE - 7\",\"EndDate\":\"CURRENT_DATE\"}');\nResult:\nReportDate AutoDbJobName JobSchedule Completed InProgress Skipped Failed Aborted WithW arning MostRecentError ErrorCodes\n2024/02/04 stats_apply Every 1 hour43 0 19 0 0 0    \n2024/02/04 stats_automate Every 1 hour62 1 0 0 0 0    \nLake - Monitor Resources and Performance\nPage 378 of 420ReportDate AutoDbJobName JobSchedule Completed InProgress Skipped Failed Aborted WithW arning MostRecentError ErrorCodes\n2024/02/04 stats_inline Every 5\nminutes125 0 0 0 4 0    \n2024/02/04 stats_missing Every 2 hours62 1 0 0 0 0    \n2024/02/04 stats_stale Every 6 hours125 0 0 0 0 0    \nDailyJobErrors\nThis stored procedure reports each job that encountered an unexpected failure running under the AutoDB service.\nDailyJobErrors Syntax\nDailyJobErrors Usage Notes\nDailyJobErrors Example\nRequired SQL  Access Rights\nSELECT ON TDaaS_Db\nDailyJobErrors Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.DailyJobErrors( \n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nBeginDate DATE Starting date for job activity.\nEndDate DATE Ending date for job activity.\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_DailyJobErrors rather\nthan being returned as a dynamic result.\nDefault is false.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nReportDate DATE Date for reported job activity that encountered errors.\nAutoDbJobName VARCHAR(25) Name of AutoDb service job.\nErrorCode INTEGER Error code.\nErrorText VARCHAR(1024) Error text.\nDailyJobErrors Usage Notes\nReport returns an output row for each day between the speciﬁed BeginDate and EndDate.\nTo report the current day's activity, specify CURRENT_DATE for both BeginDate and EndDate.\nTo report yesterday's activity, specify CURRENT_DATE - 1 for both BeginDate and EndDate.\nIf BeginDate and EndDate are not speciﬁed, output is returned for the last 7 days.\nDailyJobErrors Example\nThe following example reports job errors for the past week.\nCALL TDSTATS.DAILYJOBERRORS('{\"BeginDate\":\"CURRENT_DATE - 7\",\"EndDate\":\"CURRENT_DATE\"}');\nResult:\nReportDate AutoDbJobName ErrorCode ErrorT ext\n2024/05/13 stats_automate -1 ?\n2024/06/11 stats_inline 3809 1 Column 'DatabaseName' is ambiguous.\nLake - Monitor Resources and Performance\nPage 379 of 420ReportDate AutoDbJobName ErrorCode ErrorT ext\n2024/07/24 stats_stale 6881 2 thread(s) encountered the following DBS\nerrors: 3706. Please check query logs.\nAutoDBAObjects\nThis stored procedure reports the aggregated number of AutoDBA marked tables per database for those databases in the system with at least one AutoDBA table. If the caller\nspeciﬁes as individual database, the AutoDBA option for each child table in that database is reported.\nAutoDBAObjects Syntax\nAutoDBAObjects Usage Notes\nAutoDBAObjects Examples\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDSTATS\nAutoDBAObjects Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.AutoDbaObjects(\n    IN jIn JSON(2000) CHARACTER SET UNICODE)\n    DYNAMIC RESULT SETS 1  \nJSON Input Keys\nJSON Key Data T ype Description\nDatabase Name VARCHAR Optionally limit report to tables in the speciﬁed database.\nWildcard characters _ and % are will and will return all\nnames that qualify in the search pattern.\nIf not speciﬁed, all customer owned databases are\nincluded.\nDynamic SQL  Result Columns When DatabaseName  is Not Speciﬁed\nColumn Name Data T ype  \nDatabaseName VARCHAR Name of database having at least 1 AutoDba table.\nTotalTables INTEGER Total number of tables in current DatabaseName.\nNumTablesNotAutoDba INTEGER Number of tables marked NO AUTODBA.\nNumTablesFullAutoDba INTEGER Number of tables marked AUTODBA.\nNumTablesSemiAutoDba INTEGER Number of tables marked AUTODBA WITH CHECK.\nLowestAutoDbaStartTime TIMESTAMP Most recently marked AUTODBA table.\nDynamic SQL  Result Columns When DatabaseName  is Speciﬁed as an Input Key V alue\nColumn Name Data T ype Description\nDatabaseName VARCHAR Name of database having at least 1 AutoDba table.\nTableName VARCHAR Table within DatabaseName.\nTableKind CHAR\nI - Join Index\nO - Table with no primary index and no partitioning\nT- Table with a primary index or primary AMP index,\npartitioning, or both.\nAutoDBA CHAR\nF - Full\nS - Semi (with check)\nN - No\nLake - Monitor Resources and Performance\nPage 380 of 420Column Name Data T ype Description\nAutoDbaStartTime TIMESTAMP Timestamp of AutoDBA marking.\nNULL if AutoDBA is 'N'.\nAutoDBAObjects Usage Notes\nIndividual objects can be marked using the [NO] AUTODBA syntax option supported in DDL CREATE, ALTER, and MODIFY statements.\nDatabases with zero AutoDBA marked tables are not included in the aggregated output.\nJoin Indexes inherit their AutoDBA option from the base tables on which they are deﬁned.\nAutoDBAObjects Examples\nExample 1 (When DatabaseName is Not Speciﬁed)\nCALL TDSTATS.AUTODBAOBJECTS('{}');\nResult:\nDatabaseName TotalT ables NumT ablesNotAutoDba NumT ablesFullAutoDba NumT ablesSemiAutoDba LowestAutoDBAStartT ime\nInventoryDb 2 0 0 2 2023-07-01 16:11:57\nSalesDb 3 1 1 1 2023-07-08 16:31:59\nCustomerDb 3 1 0 2 2023-07-08 16:32:00\nExample 2 (When DatabaseName is Speciﬁed as an Input Key V alue)\nCALL TDSTATS.AUTODBAOBJECTS('{\" DatabaseName \":\"SalesDb\"}');\nResult:\nDatabaseName TableName AutoDBA AutoDBAStartT ime\nSalesDB t1 F 2023-07-01 16:11:57\nSalesDB t2 S 2023-07-08 16:21:10\nSalesDB t3 N  \nManual Control and Customization APIs\nThe APIs documented in this section allow DBA experts to review and approve statistic recommendations on AUTODBA objects that were previously marked for semi-autonomous\ncontrol using the WITH CHECK syntax option. Additional APIs allow for customization on how statistics are analyzed or prepared for collection. Lastly, an AuditTrail API assists DBAs or\nTeradata Support personnel in investigating performance issues that may have resulted from an individual applied tuning action.\nMissingStatRecs\nDropStatRecs\nApproveStat\nDisapproveStat\nRemoveMissingRecs\nInactivateStat\nMarkAutoDBAObjects\nSetObjectOption\nRemoveObjectOption\nPreserveAfterRecreate\nHistogram Related Settings APIs\nObjectList APIs\nAuditTrail\nSelectAutomatedStats\nGeneral API Usage\nSemi-autonomous APIs are in the form of stored procedures residing within owning database TDStats, each with a single JSON input parameter that support an extensible set of name-\nvalue pairs.\nAPIs that display recommendations return output in the form of relational dynamic row results similar to Dashboard Reporting APIs.\nAPIs performing actions such as approve or disapprove will return a JSON output parameter that conﬁrms the action performed.\nREPLACE PROCEDURE TDStats.< ReportAPI > (\n   IN jIn JSON(2000) CHARACTER SET UNICODE)\n   DYNAMIC RESULT SETS 1 \nREPLACE PROCEDURE TDStats.< ActionAPI > (\nLake - Monitor Resources and Performance\nPage 381 of 420   IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nMissingStatRecs\nThis stored procedure reports the current best set of missing (new) statistic recommendations along with supporting evidence about their estimated beneﬁt. Callers can limit the report\nto a speciﬁed set of objects or only highly ranked recommendations whose estimated beneﬁt is higher relative to others. This API is often used in conjunction with ApproveStat and\nDisapproveStat.\nMissingStatRecs Syntax\nMissingStatRecs Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, EXECUTE FUNCTION, SELECT ON TDSTATS\nMissingStatRecs Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.MissingStatRecs(\n  IN jIn JSON(2000) CHARACTER SET UNICODE)\n  DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nDatabaseName VARCHAR(128) Limit recommendations to those on the speciﬁed database.\nObjectName VARCHAR(128) Further limit recommendations to those on speciﬁed table\nof DatabaseName.\nObjectListName VARCHAR(128) Limit recommendations to named list of objects. See\nrelated API \"CreateObjectList\" in ObjectList APIs Syntax.\nMaxRank INTEGER Limit returned recommendations to those with a ranking <=\nspeciﬁed value.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nRank INTEGER Ranking of recommendation relative to others where the\nbest recommendation has a ranking of 1.\nSCOID BIGINT AutoStats assigned unique numeric identiﬁer for the\nstatistic recommendation.\nDatabaseName VARCHAR(128) Database on which the recommendation was made.\nTableName VARCHAR(128) Table or join index on which recommendation was made.\nFieldNames VARCHAR(10000) Comma separated list of ﬁeld names on which the\nrecommendation was made.\nStatType CHAR(1)\n'F' - single ﬁeld\n'L' - list of ﬁelds\n'I' - indexed ﬁelds\n'S' - table summary only.\nStatus VARCHAR(128) Status indicating if the recommendation is awaiting\napproval or already approved but still awaiting application.\nMostRecentTimeStamp TIMESTAMP(6) Timestamp of when the recommendation was most recently\nmade.\nTotalQueries BIGINT Total number of queries expected to beneﬁt from the\nrecommendation.\nCardinalityEstimateErrors BIGINT Number of relevant queries that had Optimizer cardinality\nestimation errors.\nMissedSLGFrequency BIGINT Number of relevant queries that missed their Service Level\nGoal (SLG).\nAvgOptimizerImportance VARCHAR(10) Optimizer assigned importance of the recommendation.\nLake - Monitor Resources and Performance\nPage 382 of 420Column Name Data T ype Description\nPlanCostMagnitude INTEGER Average cost of relevant queries expressed as number of\ndigits in cost.\nRecDDLText VARCHAR(10000) SQL DDL text associated with the recommendation.\nQueryList VARCHAR(2000) Comma separated list of DBQL QueryIds expected to\nbeneﬁt from statistics.\nDescription VARCHAR(256) EXPLAIN-like text description of supporting evidence.\nMissingStatRecs Example\nThis example reports any recommendations for collecting new stats on database ‘V6_ADW’.\nBTEQ -- Enter your SQL request or BTEQ command:\n.set sidetitles on\n.set foldline on\nCALL TDStats.MissingStatRecs('{\"DatabaseName\":\"V6_ADW\"}');\nResult:\nRank                                                    1\nSCOID                                    11700117\nDatabaseName                       V6_ADW\nTableName                              ordertbl_ppi\nFieldNames                             \"O_ORDERKEY\",\"O_TOTALPRICE\",\"O_ORDERDATE\"\nStatType                                  L\nStatus Approved;                    Awaiting Collection\nMostRecentTimeStamp          2019-04-01 12:59:50.930000+00:00\nTotalQueries                                      18\nCardinalityEstimateErrors                   5\nMissedSLGFrequency                        3\nAvgOptimizerImportance      2.00000000000000E 000\nPlanCostMagnitude                            3\nRecDDLText                         COLLECT STATISTICS COLUMN(\"O_ORDERKEY\",\"O_TOTALPRICE\",\"O_ORDERDATE\") ON V6_ADW.ordertbl_ppi;\nQueryList                              307190584648047536,307190584648047537,307190584648047172,307190584648047537, ....\nDescription                           Missing stat rec on set of columns that may benefit 18 queries with 5 cardinality estimation errors\n                                               with an average Optimizer assigned importance of 2-High\n.\n.\n.\nDropStatRecs\nThis stored procedure reports the current best set of drop statistic recommendations along with supporting evidence. Callers can optionally limit the report to a speciﬁed set of objects.\nDropStatRecs Syntax\nDropStatRecs Usage Notes\nDropStatRecs Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDStats\nSELECT ON TDaaS_DB\nDropStatRecs Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.DropStatRecs(\n  IN jIn JSON(2000) CHARACTER SET UNICODE)\n  DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nDatabaseName VARCHAR(128) Limit recommendations to those on the speciﬁed database.\nObjectName VARCHAR(128) Further limit recommendations to those on speciﬁed table\nof DatabaseName.\nLake - Monitor Resources and Performance\nPage 383 of 420JSON Key Data T ype Description\nObjectListName VARCHAR(128) Limit recommendations to named list of objects. See\nrelated API \"CreateObjectList\" in ObjectList APIs Syntax.\nMaxRank INTEGER Limit returned recommendations to those with a ranking <=\nspeciﬁed value.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nRank INTEGER Ranking of recommendation relative to others where the\nbest recommendation has a ranking of 1.\nSCOID BIGINT AutoStats assigned unique numeric identiﬁer for the\nstatistic recommendation.\nDatabaseName VARCHAR(128) Database on which the recommendation was made.\nTableName VARCHAR(128) Table on which the recommendation was made.\nFieldNames VARCHAR(10000) Comma separated list of ﬁeld names on which the\nrecommendation was made.\nStatType CHAR(1)\n'F' - Single ﬁeld\n'L' - List of ﬁelds\n'I' - Indexed ﬁelds\n'S' - Table summary only.\nStatus VARCHAR(128) Status indicating if the recommendation is awaiting\napproval or already approved but still awaiting application.\nMostRecentTimeStamp TIMESTAMP(6) Timestamp of when the recommendation was most recently\nmade.\nLastOptimizerUsage TIMESTAMP(6) Timestamp of when the statistic was last used by the Query\nOptimizer.\nRecollectionElapsedTime INTERVAL HOUR(4) TO SECOND Average elapsed time to recollect the statistic.\nRecDDLText VARCHAR(10000) SQL DDL text associated with the recommendation.\nDescription VARCHAR(256) EXPLAIN-like text description of supporting evidence.\nDropStatRecs Usage Notes\nTo limit the recommendations to a particular set of databases or tables, callers can specify a values for DatabaseName, TableName, or ObjectListName. Otherwise, the best set\nof recommendations for all AUTODBA designated tables in the system are returned.\nRecommendations are returned in ranked order according to their estimated cost savings for the system.\nSupporting evidence for each recommendation can be found in output columns LastOptimizerUsage and RecollectionElapsedTime. Higher ranked recommendations are\ngenerally those statistics that have not been used by the Optimizer for the past 30 days and are the most costly to recollect (refresh) over time.\nThe Description output column contains a textual EXPLAIN-like description of all of the combined supporting evidence.\nDropStatRecs Example\nThis example reports any recommendations to drop statistics that currently exist on database ‘V6_ADW’.\nBTEQ -- Enter your SQL request or BTEQ command:\n.set sidetitles on\n.set foldline on\nCALL TDStats.DropStatRecs('{\"DatabaseName\":\"V6_ADW\"}');\nResult:\nRank                                                    1\nSCOID                                       1100007\nDatabaseName                        V6_ADW\nTableName                               Dept\nFieldNames                              D_Desc\nStatType                                   F\nStatus                                      Pending Recommendation\nMostRecentTimeStamp           2019-01-17 11:33:28.980000+00:00\nLastOptimizerUsage                2018-10-31 00:00:00.00\nReCollectionElapsedTime       0:00:01.230000\nRecDDLText                           DROP STATISTICS COLUMN(\"D_Desc\") ON V6_ADW.Dept;\nDescription                            Drop stat rec on column that was last used by the Optimizer on 2018-10-31 and whose estimated reco\nLake - Monitor Resources and Performance\nPage 384 of 420.\n.\n.\nApproveStat\nUse this stored procedure to approve one or more missing (new) statistic recommendations for initial collection using COLLECT STATISTICS and periodic refreshing as deemed\nnecessary by AutoStats.\nApproveStat Syntax\nApproveStat Usage Notes\nApproveStat Example\nApproveStat Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.ApproveStatJSON(\n   IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned unique numeric\nidentiﬁer for an individual missing statistic\nrecommendation.\nDatabaseName IN VARCHAR(128) Approve all statistics deﬁned on the\nspeciﬁed database.\nTableName IN VARCHAR(128) Further limit the approval to the statistics\ndeﬁned on a speciﬁed table of\nDatabaseName.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\nwhose missing statistics recommendations\nshould be approved. See related API\n\"CreateObjectList\" in ObjectList APIs\nSyntax.\nNumApproved OUT INTEGER Number of approved statistics that were\npreviously unapproved.\nApproveStat Usage Notes\nCall MissingStatRecs to display which recommended missing statistics are not yet approved.\nTo approve a single statistics recommendation, callers should specify a value for SCOID. It is not necessary to specify DatabaseName or TableName when SCOID is speciﬁed.\nTo approve all statistics recommendations for a given database, callers should specify a value for DatabaseName.\nTo approve all statistics recommendations for a given table, callers should specify a value for both DatabaseName and TableName.\nWhen the desired scope of the approval operation involves a list of objects that cannot be speciﬁed via parameters DatabaseName or TableName, callers can alternatively\nspecify an ObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust be NULL.\nCallers must specify a non-NULL value for at least one of the following: SCOID, DatabaseName, or ObjectListName.\nApproveStat Example\nThis example approves the current system recommendations on table SemiDb.OrderTbl.\nCALL TDStats.ApproveStatJSON('{\"DatabaseName\":\"SemiDb\",\"TableName\":\"OrderTbl\"}',jout);\nResult:\njOut {\"NumApproved\":3}\nDisapproveStat\nUse this stored procedure to reject one or more missing (new) statistic recommendations and refrain from making the same recommendation (on the same table) in the future.\nDisApproveStat Syntax\nDisApproveStat Usage Notes\nDisApproveStat Example\nDisApproveStat Syntax\nLake - Monitor Resources and Performance\nPage 385 of 420API Deﬁnition\nREPLACE PROCEDURE TDStats.DisapproveStatJSON(\n   IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned unique numeric\nidentiﬁer for an individual missing statistic\nrecommendation.\nDatabaseName IN VARCHAR(128) Disapproves all missing statistics\nrecommendations for the speciﬁed\ndatabase.\nTableName IN VARCHAR(128) Further limit the disapproval to the statistics\ndeﬁned on a speciﬁed table of\nDatabaseName.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\nwhose missing statistics recommendations\nshould be disapproved. See related API\n\"CreateObjectList\" in ObjectList APIs\nSyntax.\nNumDisApproved OUT INTEGER Number of statistic recommendations\nmarked disapproved.\nDisApproveStat Usage Notes\nCall MissingStatRecs to display which recommended missing statistics are not yet approved or disapproved.\nTo disapprove a single statistics recommendation, callers should specify a value for SCOID. It is not necessary to specify DatabaseName or TableName when SCOID is\nspeciﬁed.\nTo disapprove all statistics recommendations for a given database, callers should specify a value for DatabaseName.\nTo disapprove all statistics recommendations for a given table, callers should specify a value for both DatabaseName and TableName.\nWhen the desired scope of the disapproval operation involves a list of objects that cannot be speciﬁed via parameters DatabaseName or TableName, callers can alternatively\nspecify an ObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust be NULL.\nCallers must specify a non-NULL value for at least one of the following: SCOID, DatabaseName, or ObjectListName.\nDisApproveStat Example\nThis example disapproves the current system recommendations on table SemiDb.Customer.\nCALL TDStats.DisApproveStatJSON('{\"DatabaseName\":\"SemiDb\",\"TableName\":\"Customer\"}',jout);\nResult:\njOut {\"NumDisapproved\":1}\nRemoveMissingRecs\nThis stored procedure erases a set of missing statistic recommendations from past Analyze Jobs where such recommendations have not yet been approved or applied.\nRemoveMissingRecs is used by callers to \"clear the slate\" after performing a series of trial-only tuning analysis experiments. The erasure is not equivalent to “Disapproval” in that the\nsystem is free to make the same recommendations in future analysis runs. API is applicable only to recommendations made on objects marked as semi-autonomous via the WITH\nCHECK option.\nRemoveMissingRecs Syntax\nRemoveMissingRecs Example\nRemoveMissingRecs Syntax\nAPI Description\nREPLACE PROCEDURE TDStats.RemoveMissingRecsJSON(\n    IN jIn JSON(3000) CHARACTER SET UNICODE,\n    OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nLake - Monitor Resources and Performance\nPage 386 of 420JSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR(128) Erase all recommendations on the speciﬁed\ndatabase.\nObjectName IN VARCHAR(128) Further limit the erasing to the statistics\ndeﬁned on a speciﬁed table of\nDatabaseName.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\nwhose recommendations should be erased.\nSee related API \"CreateObjectList\" in\nObjectList APIs Syntax.\nAnalysisID IN BOOLEAN Erase recommendations from a prior call to\nan Analysis API whose results are marked\nwith the speciﬁed AutoStats assigned\nidentiﬁer.\nOlderThan IN STRING Erase recommendations older than a\nspeciﬁed timestamp.\nNumRemoved OUT INTEGER Number of recommendations that were\nerased.\nRemoveMissingRecs Example\nThis example removes all the current recommendations on database SemiDb.\nCALL TDStats.RemoveMissingRecsJSON('{\"DatabaseName\":\"SemiDb\"}',jout);\nResult:\njOut {\"NumRemoved\":6}\nInactivateStat\nThis stored procedure marks an existing statistic for inactivation for AutoStats management and optionally drop its deﬁnition from the Data Dictionary. See DropStatRecs for reporting\nstatistics that have have had no recent usage by the Query Optimizer.\nA short delay can occur until the statistic is dropped from the Data Dictionary as this action is performed by a job running under the AutoDb service.\nInactivateStat Syntax\nInactivateStat Usage Notes\nInactivateStat Example\nInactivateStat Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.InactivateStatJSON(\n    IN jIn JSON(3000) CHARACTER SET UNICODE,\n    OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned unique numeric\nidentiﬁer for an individual statistic under\nautomated control.\nDatabaseName IN VARCHAR(128) Inactivates all statistics deﬁned on the\nspeciﬁed database.\nTableName IN VARCHAR(128) Further limit the inactivation to the statistics\ndeﬁned on a speciﬁed table of\nDatabaseName.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\nwhose statistics should be inactivated. See\nrelated API \"CreateObjectList\" in ObjectList\nAPIs Syntax.\nDropStat IN BOOLEAN\ntrue - Statistic will be dropped from\nthe Data Dictionary via a DROP\nSTATISTICS statement.\nfalse - Statistic will be marked\ninactive and will no longer be\nLake - Monitor Resources and Performance\nPage 387 of 420JSON Key IN/OUT Data T ype Description\nrefreshed by AutoStats.\nDefault is true.\nNumInActivated OUT INTEGER Number of statistics that were dropped or\ninactivated.\nInactivateStat Usage Notes\nTo inactivate a single statistic, callers should specify a value for SCOID. It is not necessary to specify DatabaseName or TableName when SCOID is speciﬁed.\nTo inactivate all statistics for a given database, callers should specify a value for DatabaseName.\nTo inactivate all statistics for a given table, callers should specify a value for both DatabaseName and TableName.\nWhen the desired scope of the approval operation involves a list of objects that cannot be speciﬁed using parameters DatabaseName or TableName, callers can alternatively\nspecify an ObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust be NULL.\nCallers must specify a non-NULL value for at least one of the following: SCOID, DatabaseName, or ObjectListName.\nInactivateStat Example\nThis example inactivates and drops the individual statistic whose system assigned unique identiﬁer is 361.\nCALL TDStats.InactivateStatJSON('{\"SCOID\":361}',jout);\nResult:\njOut {\"NumInActivated\":1}\nMarkAutoDBAObjects\nThis stored procedure marks an existing database and all its existing tables as being excluded from the scope of AutoStats management (or conversely, included in AutoStats scope).\nUse this API to make use is equivalent cascading functionality not available in the ALTER TABLE SQL statement.\nMarkAutoDBAObjects Syntax\nMarkAutoDBAObjects Usage Notes\nMarkAutoDBAObjects Example\nRequired SQL  Privileges\nWhen marking an entire database or user, a MODIFY DATABASE | USER statement is executed by the body of the stored procedure which requires the INVOKER to have the\nDROP DATABASE or DROP USER privilege on the speciﬁed DatabaseName.\nWhen marking an individual table or when the Cascade option is speciﬁed as true, an ALTER TABLE statement is executed by the body of the stored procedure which requires\nthe INVOKER to have the DROP TABLE privilege on the speciﬁed TableName.\nEXECUTE PROCEDURE ON TDSTATS\nMarkAutoDBAObjects Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.MarkAutoDBAObjects(\n   IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\n   SQL SECURITY INVOKER\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR Name of database to mark.\nTableName IN VARCHAR Name of table to mark. If NULL, all tables\nwithin DatabaseName are marked.\nObjectListName IN VARCHAR List of objects to mark. See related API\n\"CreateObjectList\" in ObjectList APIs\nSyntax.\nAutoDBA IN CHAR Marking option:\n'F' - Fully-autonomous\n'S' - Semi-autonomous (with check)\n'N' - No AutoDBA control\nLake - Monitor Resources and Performance\nPage 388 of 420JSON Key IN/OUT Data T ype Description\nCascade IN BOOLEAN\n'true' - Cascade speciﬁed AutoDBA\noption to existing child objects.\n'false' - Do not cascade to child\nobjects.\nDefault value is false.\nNumDatabasesMarked OUT INTEGER Number of databases successfully marked.\nNumTablesMarked OUT INTEGER Number of tables successfully marked.\nNumMarkingErrors OUT INTEGER Number of databases and tables left\nunmarked due to errors.\nErrors OUT INTEGER Keys [QualiﬁedObjectName, SQL_Code]\nindicating the object marking failed along\nwith error code.\nMarkAutoDBAObjects Usage Notes\nTemporary tables and Error tables will automatically be skipped as per AUTODBA marking rules. For more information, refer to SQL Data Deﬁnition Language and the usage of\nthe AUTODBA option within DDL statements.\nTo mark a speciﬁc database, callers should specify a value for DatabaseName.\nTo mark a speciﬁc table, callers should specify a value for both DatabaseName and TableName.\nDatabaseName and TableName should not contain wildcard characters (%, _).\nWhen the desired scope of the marking operation involves a list of objects that cannot be speciﬁed using parameters DatabaseName or TableName, callers can alternatively\nspecify an ObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry. See ObjectList APIs.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust be NULL.\nDatabaseName,TableName, and ObjectListName cannot all be NULL. At least one object must be speciﬁed.\nA value for AutoDBA must be speciﬁed by the caller and cannot be left NULL.\nJoin indexes cannot be explicitly marked and instead inherit the marking option of the base tables on which they are deﬁned.\nMarkAutoDBAObjects Example\nThis example marks all existing tables within the SalesDb database as being under fully autonomous control.\nCALL TDStats.MarkAutoDbaObjects('{\"DatabaseName\":\"SalesDb\",\"AutoDBA\":\"F\",\"Cascade\":\"true\"}',jOut);\nResult:\njOut\n-----------------------------------------------------------------------------------------------------------------------------------------\n{\"NumDatabasesMarked\":1,\"NumTablesMarked\":2,\"NumMarkingErrors\":0,\"Errors\":null}\nSetObjectOption\nThis stored procedure speciﬁes customized behavior for managing the statistics on one or more tables including the option of whether or not to batch multiple statistic collections on a\ngiven table within a single COLLECT STATISTICS statement.\nSetObjectOption Syntax\nSetObjectOption Usage Notes\nSetObjectOption Example\nSetObjectOption Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.SetObjectOptionJSON(\n   IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR(128) Identiﬁes the database containing the\ntables the speciﬁed option is being set for.\nTableName IN VARCHAR(128) Identiﬁes a particular table within\nDatabaseName the speciﬁed option is\nbeing set for.\nLake - Monitor Resources and Performance\nPage 389 of 420JSON Key IN/OUT Data T ype Description\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\nto set the speciﬁed option for. See related\nAPI ObjectList APIs.\nOptionName IN VARCHAR(64) Name of the table or database level option\nbeing set.\nValid values include:\n'NoBatching'\nOptionValue IN VARCHAR(64) Value of the option being set.\nAllowable values for the 'NoBatching' option\nare:\n'Y' – Generate a separate COLLECT\nSTATISTICS statement for each\nindividual statistic deﬁned within a\ngiven table.\n'N' - Batch together all the individual\nstatistics for a given table into the\nsame COLLECT STATISTICS\nstatement.\nNumAdded OUT INTEGER Number of additions/updates made for the\nspeciﬁed option.\nSetObjectOption Usage Notes\nTo set an option at the system level, omit ObjectListName, DatabaseName and TableName.\nTo set an option for all tables and their statistics within a given database, callers should specify a value for DatabaseName only.\nTo set an option for all statistics in a given table, callers should specify a value for both DatabaseName and TableName.\nA table option set via this API supersedes any associated values speciﬁed in calls to APIs that perform tuning analysis or statistics collections.\nIf the table option is already set for a table, the current option will be overwritten by the value speciﬁed in any subsequent call to the API.\nWhen the desired scope of the operation involves a list of objects that cannot be speciﬁed via parameters DatabaseName or TableName, callers can alternatively specify an\nObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust not be speciﬁed.\nIn addition to objects marked semi-autonomous with the AUTODBA WITH CHECK syntax option, this API can also be used in conjunction with objects marked fully autonomous\nvia the AUTODBA option (no WITH CHECK).\nSetObjectOption Example\nThis example disables the batching statistic collections for the Personnel.Project table.\nCALL TDStats.SetObjectOptionJSON('{\"DatabaseName\": \"Personnel\", \"TableName\": \"Project\", \"OptionName\": \"NoBatching\", \"OptionValue\": \"Y\" }'\nResult:\njOut \n----------------------- \n{ \"NumAdded\":1 }\nRemoveObjectOption\nThis stored procedure removes a customized option previously speciﬁed by a call to SetObjectOption. Upon removal, system default behavior will be resumed.\nRemoveObjectOption Syntax\nRemoveObjectOption Usage Notes\nRemoveObjectOption Example\nRemoveObjectOption Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.RemoveObjectOptionJSON(\n  IN jIn JSON(3000) CHARACTER SET UNICODE,\n  OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nLake - Monitor Resources and Performance\nPage 390 of 420JSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR(128) Identiﬁes the database whose option\nshould be removed.\nTableName IN VARCHAR(128) Identiﬁes a particular table within\nDatabaseName on which to remove the\noption.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\non which to remove the option. See related\nAPI \"CreateObjectList\" in ObjectList APIs\nSyntax.\nOptionName IN VARCHAR(64) Name of the option being removed.\nValid values include:\n'NoBatching'\nNumRemoved OUT INTEGER Number of tables whose speciﬁed custom\noption has been removed and reverted\nback to the default option.\nRemoveObjectOption Usage Notes\nTo remove the table option for all tables within a given database, or for a speciﬁc table, don't specify OptionName.\nTo remove the table option for all tables within a given database, callers should specify a value for DatabaseName only.\nTo remove the table option for a given table, callers should specify a value for both DatabaseName and TableName.\nWhen the desired scope of the operation involves a list of objects that cannot be speciﬁed via parameters DatabaseName or TableName, callers can alternatively specify an\nObjectListName that was previously created by APIs CreateObjectList and AddObjectListEntry.\nObjectListName usage is mutually exclusive with DatabaseName and TableName. When a non-NULL value is speciﬁed for ObjectListName, DatabaseName and TableName\nmust not be speciﬁed.\nIn addition to objects marked semi-autonomous with the AUTODBA WITH CHECK syntax option, this API can also be used in conjunction with objects marked fully autonomous\nvia the AUTODBA option (no WITH CHECK).\nRemoveObjectOption Example\nThis example removes the customized batching option set for table Personnel.Project and goes back to system default.\nCALL TDStats.RemoveObjectOptionJSON('{\"DatabaseName\": \"Personnel\", \"TableName\": \"Project\", \"OptionName\": \"NoBatching\"}', jOut);\nResult:\njOut \n----------------------- \n{ \"NumRemoved\":1 }\nPreserveAfterRecreate\nThis stored procedure marks one or more objects as eligible for having their AutoStats tuning metadata preserved, including statistics deﬁnitions, after being temporarily dropped and\nthen recreated. If not marked for preservation, the AutoStats stored tuning metadata becomes orphaned from their corresponding Data Dictionary entries and is not preserved.\nAlthough the practice of temporarily dropping a table and recreating with the same schema is common to many ETL processes, it results in new Dictionary assigned table identiﬁers\nrepresenting a brand new table.\nPreserveAfterRecreate Syntax\nPreserveAfterRecreate Usage Notes\nPreserveAfterRecreate Example\nPreserveAfterRecreate Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.PreserveAfterRecreateJSON(\n  IN jIn JSON(3000) CHARACTER SET UNICODE,\n  OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR(128) Identiﬁes the database whose AutoStats\ntuning metadata should be marked for\npreservation.\nTableName IN VARCHAR(128) Identiﬁes a particular table within\nDatabaseName on which to mark for\nLake - Monitor Resources and Performance\nPage 391 of 420JSON Key IN/OUT Data T ype Description\npreservation.\nObjectListName IN VARCHAR(128) Speciﬁes a previously deﬁned list of objects\non which to mark for preservation. See\nrelated API \"CreateObjectList\" in ObjectList\nAPIs Syntax.\nNumPreserved OUT INTEGER Number of statistic entries/deﬁnitions\nmarked for preservation.\nPreserveAfterRecreate Usage Notes\nThe use of this API should be limited to those tables that after being temporarily dropped are subsequently recreated with the exact same name, column deﬁnitions, and\nstatistics deﬁnitions.\nTo reverse the changes made by a call to PreserveAfterRecreate, a call can be made to related API DoNotPreserveAfterRecreate whose JSON keys are the same as above.\nIn addition to objects marked semi-autonomous with the AUTODBA WITH CHECK syntax option, this API can also be used in conjunction with objects marked fully autonomous\nvia the AUTODBA option (no WITH CHECK).\nPreserveAfterRecreate Example\nThis example marks table Personnel.Employee as being eligible for metadata preservation after recreation.\nCALL TDSTATS.PreserveAfterRecreate('Personnel','Employee', NULL, NumPreserved);\nResult:\nNumPreserved\n           4\nAuditTrail\nThis stored procedure reports historical AutoStats tuning events, including applied missing statistic recommendations, where such events are recorded within various telemetry sources\nincluding TDStats, the Data Dictionary (DBC), and DBQL tables. Callers can limit the report to a speciﬁed time period and/or speciﬁed user objects. Use this API to diagnose\nunexpected performance problems that occur as a result of a past tuning action.\nAuditTrail Syntax\nAuditTrail Example\nRequired SQL  Access Rights\nEXECUTE PROCEDURE, SELECT ON TDStats\nSELECT ON DBC.StatsTbl\nAuditT rail Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.AuditTrail(\n  IN jIn JSON(2000) CHARACTER SET UNICODE)\n  DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nDatabaseName VARCHAR(128) Limit the audit trail to events that apply to a speciﬁed\ndatabase.\nTableName VARCHAR(128) Limit the audit trail to a speciﬁed table of DatabaseName.\nEventType VARCHAR(50) Limit audit trail to a particular type of event.\nValid values are:\n'M' - Missing statistic identiﬁed\n'D' - Dropped statistic\n'R' - (Re)collection of single statistic\n'BR' - Batched recollection of multiple statistics\n'BL' - Bulk load into table\n'A' or NULL - all event types\nStartTime TIMESTAMP(6) Start time of the desired audit period.\nEndTime TIMESTAMP(6) End time of the desired audit period.\nLake - Monitor Resources and Performance\nPage 392 of 420JSON Key Data T ype Description\nReturnTable BOOLEAN When true, results will be stored in a session level\ntemporary table named AutoDBA_AuditTrail rather than\nbeing returned as a dynamic result.\nDefault value is false.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nEventTimeStamp TIMESTAMP(6) Timestamp of when the event occurred.\nEventType VARCHAR(50) Type of recorded event.\nValid values are:\n'M' - Missing statistic identiﬁed\n'D' - Dropped statistic\n'R' - (Re)collection of single statistic\n'BR' - Batched recollection of multiple statistics\n'BL' - Bulk load into table\n'A' or NULL - all event types\nDatabaseName VARCHAR(128) Database on which the event occurred.\nTableName VARCHAR(128) Table on which the event occurred.\nFieldNames VARCHAR(10000) Comma separated list of ﬁeld names on which the event\nwas applied.\nStatsOrIndexId INTEGER Dictionary identiﬁer of the relevant statistic or index.\nSCOID BIGINT AutoStats assigned identiﬁer of the relevant statistic.\nDDLText VARCHAR(10000) SQL DDL text that was executed during the event.\nStatsSubmitted INTEGER Number of individual statistics submitted within DDLText.\nStatsCollected INTEGER Number of individual statistics collected (not skipped).\nUtilityName VARCHAR(128) Name of bulk load utility. This ﬁeld is relevant only for\nevents of type BL.\nUDIActivity BIGINT Number of rows inserted, updated, or deleted during bulk\nload.\nErrorText VARCHAR(512) Error (if any) from executing DDLText.\nDescription VARCHAR(256) Supporting evidence for the the action applied during the\nevent.\nTotalQueries BIGINT When EventType = 'M': Total number of queries expected\nto beneﬁt from recommendation.\nCardinalityEstimateErrors BIGINT When EventType = 'M': Number of relevant queries that\nhad Optimizer cardinality estimation errors.\nMissedSLGFrequency BIGINT When EventType = 'M': Number of relevant queries that\nmissed their Service Level Goal (SLG).\nAvgOptimizerImportance VARCHAR(10) When EventType = 'M': Optimizer assigned importance of\nthe recommendation.\nPlanCostMagnitude INTEGER When EventType = 'M': Average cost of relevant queries\nexpressed as number of digits in cost.\nAuditT rail Example\nThis example reports all tuning events that occurred on database MyDb during the speciﬁed time period.\n.set sidetitles on\n.set foldline on\nCALL TDStats.AuditTrail('{\"StartTime\":\"2022-01-18 15:00:00\",\"DatabaseName\":\"MyDb\",\"EventType\":\"A\"}');\nResult:\nEventTimeStamp 2022-01-18 15:13:37\n           EventType M - Missing Stat Identified\n  DatabaseName MyDb\nLake - Monitor Resources and Performance\nPage 393 of 420         TableName MyTable\n        FieldNames x1\n              DDLText COLLECT STATISTICS COLUMN(x1 ) ON MyDb.MyTable\n        Description New stat collected on column that may benefit 10 queries with 5 cardinality estimation errors and 0 missed SLGs with \n.\n.\n.\nEventTimeStamp 2022-01-18 15:13:41\n            EventType BR - Batched recollection of multiple stats\n   DatabaseName MyDb\n          TableName MyTable\n          FieldNames ?\n               DDLText COLLECT STATISTICS INDEX(pi ),COLUMN(x1 ),COLUMN(x2 ),COLUMN(x3 ),COLUMN(x4 ) ON \"MyDb.MyTable;\n          Description Table level refresh of multiple stats\nObjectList APIs\nUse the ObjectList APIs to create and manage a named object list representing a custom set of databases or tables which can then be passed as an input parameter to various APIs\nthat control or perform tuning. You can reduce the number of API calls required to perform the same operation on multiple databases or tables.\nObjectList APIs Syntax\nObjectList API Usage Notes\nObjectList APIs Example\nObjectList APIs Syntax\nCreateObjectList Syntax\nAddObjectListEntry Syntax\nRemoveObjectList Syntax\nSelectFromObjectList Syntax\nCreateObjectList Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.CreateObjectlistJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nObjectListName IN VARCHAR(128) Caller assigned name for the new list.\nObjectListID OUT BIGINT System assigned numeric identiﬁer for the\ncreated list.\nAddObjectListEntry Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.AddObjectListEntryJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nObjectListName IN VARCHAR(128) Name of already created list in which to add\na new object entry.\nObjectListID IN BIGINT Optional numeric identiﬁer of the list.\nDatabaseName IN VARCHAR(128) Name of database to add to the list.\nObjectName IN VARCHAR(128) Optional name of individual table residing in\nDatabaseName to add to the list.\nIf NULL, all tables within DatabaseName will\nbe in the list.\njOut OUT N/A Reserved for future use; no key values\ncurrently returned.\nLake - Monitor Resources and Performance\nPage 394 of 420RemoveObjectList Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.RemoveObjectlistJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nObjectListName IN VARCHAR(128) Name of the existing list to remove along\nwith all of its entries.\nObjectListID IN BIGINT Optional numeric identiﬁer for the list to be\nremoved.\nNumRemoved OUT INTEGER Number of database and table entries that\nwere in the removed list.\nSelectFromObjectList Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.SelectFromObjectlistJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\n   DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nObjectListName VARCHAR(128) Name of the existing list whose object entries should be\ndisplayed.\nObjectListID BIGINT Optional numeric identiﬁer for the list to be displayed.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nObjectListName VARCHAR(128) Name of the list containing the object.\nDatabaseName VARCHAR(128) Database with one or more objects contained in the list.\nObjectName VARCHAR(128) Individual table contained within the object list.\nIf NULL, all tables in the displayed DatabaseName are part\nof the list.\nObjectList API Usage Notes\nSpecify ObjectListName or ObjectListId to identify the existing list.\nSpeciﬁed values for DatabaseName and ObjectName keys can contain wildcard characters (%, _).\nThe SQL DROP DATABASE, DROP TABLE, MODIFY DATABASE, and ALTER TABLE statements will not have their actions automatically reﬂected in lists maintained by AutoStats\nwhose metadata resides in system database TDStats.\nObjectList APIs Example\nThis example creates a new object list and adds table MyDatabase.MyTable to it.\nCALL  Statement (Create Object List)\nCALL TDSTATS.createobjectlistjson('{\"ObjectListName\":\"MyObjList\"}',jOut);\nResult:\njOut\n---------------------------------------------------------------------------\n{\"ObjectListId\":1}\nCALL  Statement (Add T able)\nLake - Monitor Resources and Performance\nPage 395 of 420CALL TDSTATS.AddObjectListEntryJSON('{\"ObjectListName\":\"MyObjList\",\"DatabaseName\":\"MyDatabase\",\"ObjectName\":\"MyTable\" }',jOut);\nHistogram Related Settings APIs\nUse the Histogram Related Settings APIs to customize the settings related to histogram sizes, sampling, and refresh thresholds for AutoStats generated SQL COLLECT STATISTICS\nstatements. By default, each of the options are automatically determined by the system.\nHistogram Related Settings APIs Syntax\nHistogram Related Settings APIs Usage Notes\nUpdateStatThresholdSettingJSON Example\nHistogram Related Settings APIs Syntax\nUpdateHistogramSettings Syntax\nUpdateStatSamplingSetting Syntax\nUpdateStatThresholdSetting Syntax\nUpdateHistogramSettings Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.UpdateHistogramSettingsJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned identiﬁer of an\nindividual statistic whose settings are to be\nchanged.\nDatabaseName IN VARCHAR(128) Apply the new settings to all statistics\ncollected within the speciﬁed database.\nTableName IN VARCHAR(128) Apply the new settings to an individual table\nresiding within the speciﬁed\nDatabaseName.\nMaxIntervals IN INTEGER Value to specify for the MAXINTERVALS\noption for generated COLLECT STATISTICS\nstatements.\nAllowable values are 0 to 500. A value of -1\nindicates the SYSTEM selected value is\nused.\nMaxLength IN INTEGER Value to specify for the MAXVALUELENGTH\noption for generated COLLECT STATISTICS\nstatements.\nA value of -1 indicates the SYSTEM\nselected value is used.\nNumUpdated OUT INTEGER Number of statistics whose settings have\nbeen updated.\nUpdateStatSamplingSetting Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.UpdateStatSamplingSettingJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned identiﬁer of an\nindividual statistic whose settings are to be\nchanged.\nLake - Monitor Resources and Performance\nPage 396 of 420JSON Key IN/OUT Data T ype Description\nDatabaseName IN VARCHAR(128) Apply the new settings to all statistics\ncollected within the speciﬁed database.\nTableName IN VARCHAR(128) Apply the new settings to an individual table\nresiding within the speciﬁed\nDatabaseName.\nSampleType IN CHAR(1) Type to use for SAMPLE option for\ngenerated COLLECT STATISTICS\nstatements.\nValid values are:\n'U' - Designates SAMPLE\n<percentage> PERCENT\n'N' - Designates NO SAMPLE\nPercentage IN INTEGER Value for <percentage> speciﬁed in\nSampleType.\nAllowable values are 2 to 100.\nNumUpdated OUT INTEGER Number of statistics whose histogram\nsettings have been updated.\nUpdateStatThresholdSetting Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE tdstats.UpdateStatThresholdSettingJSON\n  (IN jIn JSON(3000) CHARACTER SET UNICODE,\n   OUT jOut JSON(3000) CHARACTER SET UNICODE)\nJSON Keys\nJSON Key IN/OUT Data T ype Description\nSCOID IN BIGINT AutoStats assigned identiﬁer of an\nindividual statistic whose settings are to be\nchanged.\nDatabaseName IN VARCHAR(128) Apply the new settings to all statistics\ncollected within the speciﬁed database.\nTableName IN VARCHAR(128) Apply the new settings to an individual table\nresiding within the speciﬁed\nDatabaseName.\nThresholdType IN CHAR(1) Type to use for THRESHOLD option for\ngenerated COLLECT STATISTICS\nstatements.\nValid values are:\n'S' - Designates SYSTEM\nTHRESHOLD\n'U’- Designates THRESHOLD\n<AgeThreshold> DAYS AND\nTHRESHOLD <GrowthThreshold>\nPERCENT\n'N' - Designates NO THRESHOLD\nAgeThreshold IN INTEGER Value for <AgeThreshold> in number of\ndays.\nAllowable values are 1 to 9999.\nGrowthThreshold IN INTEGER Value for <GrowthThreshold> as a\npercentage.\nForCurrentOnly IN BOOLEAN\ntrue - The THRESHOLD setting will\nbe issued along with the FOR\nCURRENT option making it\napplicable to the current collection\nonly.\nLake - Monitor Resources and Performance\nPage 397 of 420JSON Key IN/OUT Data T ype Description\nfalse or NULL - The THRESHOLD\nsetting is applied to all future\ncollections.\nNumUpdated OUT INTEGER Number of statistics whose histogram\nsettings have been updated.\nHistogram Related Settings APIs Usage Notes\nUsers are cautioned to use these APIs sparingly and instead rely on system determined optimal settings as optimal settings vary by individual statistic.\nSettings can be applied at different levels including database, table, and individual statistic by specifying one or more non-null values for parameters DatabaseName,\nTableName, or SCOID.\nUse API SelectAutomatedStats to determine the SCOID value for an individual statistics.\nIn addition to objects marked semi-autonomous with the AUTODBA WITH CHECK syntax option, this API can also be used in conjunction with objects marked fully autonomous\nvia the AUTODBA option (no WITH CHECK).\nUpdateStatThresholdSettingJSON Example\nThis example changes the conﬁgured threshold type for table SemiDb.OrderTbl to NO THRESHOLD\nBTEQ -- Enter your SQL request or BTEQ command:\nCALL TDStats.UpdateStatThresholdSettingJSON('{\"DatabaseName\":\"SemiDb\",\"TableName\":\"OrderTbl\",\"ThresholdType\":\"N\"}',jout);\nResult:\njOut\n{\"NumUpdated\":6}\nSelectAutomatedStats\nUse this stored procedure to display the list of automated statistics for a speciﬁed object along with their TDSTATS stored tuning metadata including their system assigned SCOID\nvalues.\nSelectAutomatedStats Syntax\nSelectAutomatedStats Example\nSelectAutomatedStats Syntax\nAPI Deﬁnition\nREPLACE PROCEDURE TDStats.SelectAutomatedStatsJSON(\n  IN jIn JSON(2000) CHARACTER SET UNICODE)\n  DYNAMIC RESULT SETS 1\nJSON Input Keys\nJSON Key Data T ype Description\nDatabaseName VARCHAR(128) Limit output to stats belonging to a speciﬁed database.\nTableName VARCHAR(128) Further limit output to a speciﬁed table within\nDatabaseName.\nObjectListName VARCHAR(128) Limit output to stats belonging to objects within a speciﬁed\nlist name.\nDynamic SQL  Result Columns\nColumn Name Data T ype Description\nDatabaseName VARCHAR(128) Database in which the statistic is deﬁned.\nTableName VARCHAR(128) Table on which the statistic is deﬁned.\nExpressionList VARCHAR(10000) Comma separated list of ﬁeld names on which the statistic\nis deﬁned.\nIndexId INTEGER Dictionary identiﬁer of index on which statistic is deﬁned or\nNULL no index exists.\nSCOID BIGINT AutoStats assigned identiﬁer of the statistic.\nLake - Monitor Resources and Performance\nPage 398 of 420Column Name Data T ype Description\nApprovedStat CHAR(1) Flag indicating whether the recommended statistic has\nbeen approved for application ('Y' or 'N').\nStatsState CHAR(1)\n'M' - Missing statistic recommendation that is not\nyet applied\n'S' - Potentially stale\n'C' - Current and up to date\nStatsOrigin CHAR(1)\n'U' - User deﬁned\n'A' - Automatically recommended by the system\nLastCollectTimeStamp TIMESTAMP(6) Time of when the statistic was last collected.\nLastEvaluationTimeStamp TIMESTAMP(6) Time when the statistics was last submitted for collection.\nDepending on the THRESHOLD evaluation, the statistic\nmay or may not have been recollected.\nThresholdSkipCnt INTEGER Number of consecutive submissions where the statistic did\nnot meet its deﬁned threshold for recollection.\nLastAccessedByOpt TIMESTAMP(6) Last recorded statistics usage by the Query Optimizer\naccording to USECOUNT activity counters.\nQryUsageFrequency INTEGER Number of logged queries observed using the statistic.\nMissingFrequency INTEGER Number of queries observed wanting the missing statistic.\nEstErrorFrequency INTEGER Number of queries wanting the missing statistic and\nobserved with cardinality estimation inaccuracies.\nCreateUser VARCHAR(128) User who originally automated the statistic.\nCreateTimeStamp TIMESTAMP(6) Time in which the statistic was originally automated.\nSelectAutomatedStats Example\nThis example lists all the automated statistics that are currently deﬁned within database SemiDb.\nbteq> .set sidetitles on\nbteq> .set foldline on \nbteq> call TDStats.SelectAutomatedStatsJSON('{\"DatabaseName\":\"SemiDB\"}',jout);\nResult:\njOut {}\n *** ResultSet# 1 : 17 rows returned by \"TDSTATS.SELECTAUTOMATEDSTATSJSON\".\n           DatabaseName semiDb\n              TableName CUSTOMER\n         ExpressionList SUBSTRING((TD_SYSFNLIB.LTRIM ( C_PHONE )) FROM (1 ) FOR (2 ))\n            IndexNumber           ?\n              IndexName ?\n                StatsId              1\n              StatsName SUBSTRING((TD_SYSFNL_390\n                  SCOID                  390\n           ApprovedStat Y\n               Excluded N\n             StatsState C\n            StatsOrigin A\n              StatsType T\n   LastCollectTimeStamp 2024-05-28 13:07:44\nLastEvaluationTimeStamp 2024-05-28 13:07:44.170000+00:00\n      SubmissionSkipCnt           0\n       ThresholdSkipCnt           0\n         UserImportance           5\n       SystemImportance           2\n             ActiveStat           Y\n      LastAccessedByOpt           ?\n      QryUsageFrequency           0\n       MissingFrequency           0\n   EstPercentDataChange           0\n                    Age           0\nLake - Monitor Resources and Performance\nPage 399 of 420     ThresholdSignature Global Default\n          EstimateError           N\n        EstErrFrequency           0\n             CreateUser TDAAS_AUTODB1\n        CreateTimeStamp 2024-05-28 13:06:24.740000+00:00\n          LastAlterUser TDAAS_AUTODB1\n     LastAlterTimeStamp 2024-05-28 13:07:44.170000+00:00\n.\n.\n.\nSample PM/API Application\nThe following is a sample PM/API application based on a sample CLI program. A PM/API application is no more than a CLI application. The only difference between a regular SQL CLI\napplication and a PM/API application is:\nPM/API logs on to a Monitor partition\nSQL logs onto DBC/SQL partition\nThis sample PM/API application is for an earlier monitor version. You must change the monitor version to return needed PM/API ﬁelds used in creating and enhancing applications.\nFor a sample PM/API application that uses the Teradata JDBC Driver, see the sample programs in Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nSample Application\nHeader File for Sample PMPC Application\nSample Application\nThe following is a sample of a CLI program.\n/**********************************************************************/\n/* This is a sample PM/API application.                               */\n/* 1) Prompts for a logon string                                      */\n/* 2) Connects to a Teradata RDBMS and establishes a MONITOR session */\n/* 3) Prompts for input parameter for MONITOR SESSION; PM/API command */\n/* 4) Submits MONITOR SESSION;                                        */\n/* 5) Retrieves the response, formats and prints the response parcels */\n/* 6) Above 3 - 5 are repeated until Q is entered in #3.              */\n/* 7) Disconnects.                                                     */\n/**********************************************************************/\n#include <stdio.h>       \n#include <string.h>\n#include <stdlib.h>\n#include \"samplepmpc.h\"\n// Global variables\nstruct  DBCAREA dbc;    /* see dbcarea.h for definition of structure */\nchar    cnta[4];\nint     IndicatorMode; \nunsigned short TargetVersion = 6;\nchar           RespMode = 'R';\nstatic int IndicFieldCount = 0;\nstatic char CurrRequestText[32];\n#define MON_SESS_REQ   1\n// List of field names for Monitor Session Record 2\nchar *MonSesRec2fieldnamelist[]= {\n    \"HostId\",\n    \"LogonProcId\",\n    \"RunProcId\",\n    \"SessionNo\",\n    \"UserName\",\n    \"UserAccount\",\n    \"UserId\",\n    \"LSN\",\n    \"LogonTime\",\n    \"LogonDate\",\n    \"PartName\",\n    \"Priority\",\n    \"IFPState\",\n    \"IFPCPUSec\",\n    \"XactCount\",\n    \"ReqCount\",\n    \"ReqCacheHits\",\n    \"AMPState\",\nLake - Monitor Resources and Performance\nPage 400 of 420    \"AMPCPUSec\",\n    \"AMPIO\",\n    \"DeltaAMPSpool\",\n    \"Blk1HostId\",\n    \"Blk1SessNo\",\n    \"\"Blk1UserId\",\n    \"Blk1LMode\",\n    \"Blk1OType\",\n    \"Blk1ObjDBId\",\n    \"Blk1ObjTId\",\n    \"Blk1Status\",\n    \"Blk2HostId\",\n    \"Blk2SessNo\",\n    \"Blk2UserId\",\n    \"Blk2LMode\",\n    \"Blk2OType\",\n    \"Blk2ObjDBId\",\n    \"Blk2ObjTId\",\n    \"Blk2Status\",\n    \"Blk3HostId\",\n    \"Blk3SessNo\",\n    \"Blk3UserId\",\n    \"Blk3LMode\",\n    \"Blk3OType\",\n    \"Blk3ObjDBId\",\n    \"Blk3ObjTId\",\n    \"Blk3Status\",\n    \"MoreBlockers\",\n    \"LogonSource\",\n    \"TempSpaceUsage\",\n    \"HotAmp1CPU\",\n    \"HotAmp2CPU\",\n    \"HotAmp3CPU\",\n    \"HotAmp1IO \",\n    \"HotAmp2IO \",\n    \"HotAmp3IO \",\n    \"HotAmp1CPUId\",\n    \"HotAmp2CPUId\",\n    \"HotAmp3CPUId\",\n    \"HotAmp1IOId\",\n    \"HotAmp2IOId\",\n    \"HotAmp3IOId\",\n    \"LowAmp1CPU\",\n    \"LowAmp2CPU\",\n    \"LowAmp3CPU\",\n    \"LowAmp1IO \",\n    \"LowAmp2IO \",\n    \"LowAmp3IO \",\n    \"LowAmp1CPUId\",\n    \"LowAmp2CPUId\",\n    \"LowAmp3CPUId\",\n    \"LowAmp1IOId\",\n    \"LowAmp2IOId\",\n    \"LowAmp3IOId\",\n    \"AmpCount\",\n    \"AvgAmpCPUSec\",\n    \"AvgAmpIOCnt\",\n    \"ReqStartTime\",\n    \"ReqStartDate\",\n    \"ReqCPU\",\n    \"ReqIO\",\n    \"RequestNo\",\n    \"WlcId\",\n    \"DontReclassifyFlag\",\n};\n/* This routine displays the presence bits with the field name. */\nstatic void PrintPresenceBits(char *ptr,int fieldcount,char **fieldnamelist)\n{\n    char *tempptr=ptr;\n    char temp = *ptr;\n    int i=0;\n    int bitOn;\nLake - Monitor Resources and Performance\nPage 401 of 420    char buf[200];\n    int endlist=0;\n    printf(\"\\nPresence Bits:\\n\");\n    while (i < fieldcount)\n    {\n        bitOn = (temp & (char)0x80);\n        if (!endlist)\n        {\n            if (!fieldnamelist  ||\n               (fieldnamelist && strlen(fieldnamelist[i]) == 0))\n                endlist = 1;\n        };\n        if (endlist)\n        {\n            sprintf(buf,\"Field%03d\",i+1);\n        }\n        else\n            strcpy(buf,fieldnamelist[i]);\n        if (bitOn)\n            printf(\"[%02d] %30s \\tis \\tNULL\\n\",i,buf);\n        else\n            printf(\"[%02d] %30s \\tis \\tNOT NULL\\n\",i,buf);\n        i++;\n        if ((i % 8) == 0)\n        {\n            tempptr++;\n            temp = *tempptr;\n        }\n        else\n            temp = temp << 1;\n    }\n    printf(\"\\n\");\n}\n/***************************************************************/\n/* WRITE_ERROR -- Prints error message that is located in      */\n/*                the response buffer--Error or Failure Parcel */\n/***************************************************************/\nstatic void Write_error(char *parcel)\n{ \n  int i;\n  Error_Fail_t *Error_Fail;\n  Error_Fail = ((struct ERROR_FAIL_Type *) (parcel));\n  printf(\"DBS Error code: %d : \",Error_Fail->Code);\n  for(i=0;i < (int)Error_Fail->Length;i++)\n    printf(\"%c\",Error_Fail->Msg[i]);\n  printf(\"\\n\");\n} /**end write_error**/\n/* MONITOR SESSION formatting routines */  \nstatic void PrtSes1(char *dataptr)\n{\n  short *SampleRate;\n  SampleRate = (short *) (dataptr);\n  printf(\"Sample rate: %d seconds\\n\\n\", *SampleRate);\n}\nstatic void PrtSes2(char *dataptr, int version)\n{\n    MonSesRec2_t  *MonSesRec2;\n    MonSesRecV3_t *MonSesRecV3;\n    MonSesRecV4_t *MonSesRecV4;\n    MonSesRecV5_t *MonSesRecV5;\n    MonSesRec2 = (MonSesRec2_t *) (dataptr);\n    if (version >= MONVERSION3)\n    {\n      MonSesRecV3 = (MonSesRecV3_t *)(((char *) (&MonSesRec2->LogonSource)) +\n                       MonSesRec2->LogonSourceLen);\n    }\n    if (version >=MONVERSION4)\n    {\n      MonSesRecV4 = (MonSesRecV4_t *) (MonSesRecV3 +1);\n    }\n    if (version >=MONVERSION5)\n    {\nLake - Monitor Resources and Performance\nPage 402 of 420      MonSesRecV5 = (MonSesRecV5_t *) (MonSesRecV4 +1);\n    }\n    printf(\"HostId: %8d   \", MonSesRec2->HostId);\n    printf(\"SessionNo: %d\\n\", MonSesRec2->SessionNo);\n    printf(\"LogonPENo: %5d   \", MonSesRec2->LogonProcId);\n    printf(\"RunVprocNo: %5d\\n\", MonSesRec2->RunProcId);\n    printf(\"PartName: %.16s\", MonSesRec2->PartName);\n    printf(\"PEState:  %.18s\\n\\n\", MonSesRec2->PEState);\n    printf(\"LogonDate: %04d/%02d/%02d         \", \n        (int) MonSesRec2->LogonDate / 10000 + 1900,\n        (int) MonSesRec2->LogonDate / 100 % 100, \n        (int) MonSesRec2->LogonDate % 100);\n    printf(\"LogonTime: %02d:%02d:%05.2f\\n\", \n        (int) MonSesRec2->LogonTime / 10000,\n        (int) MonSesRec2->LogonTime / 100 % 100, \n        (int) MonSesRec2->LogonTime % 100 + \n        MonSesRec2->LogonTime - \n        (int) MonSesRec2->LogonTime);\n    printf(\"UserID: %d \", MonSesRec2->UserID);\n    printf(\"LSN: %d\\n\", MonSesRec2->LSN);\n    printf(\"UserName: %.30s\\n\", MonSesRec2->UserName);\n    printf(\"UserAccount: %.30s\\n\\n\", MonSesRec2->UserAccount);\n    printf(\"PECPUSec: %10.2f   \", MonSesRec2->PECPUSec);\n    printf(\"XactCount: %13.2f\\n\", MonSesRec2->XactCount);\n    printf(\"ReqCount: %10.1f   \", MonSesRec2->ReqCount);\n    printf(\"ReqCacheHits: %10.1f\\n\\n\", MonSesRec2->ReqCacheHits);\n    printf(\"AMPState: %.18s\\n\", MonSesRec2->AMPState);\n    printf(\"AMPCPUSec: %9.2f   \", MonSesRec2->AMPCPUSec);\n    printf(\"AMPIO: %7.2f\\n\", MonSesRec2->AMPIO);\n    printf(\"Request_AMPSpool: %4.1f\\n\\n\", MonSesRec2->Delta_AMPSpool);\n    printf(\"Blk_1_HostId: %6d   \", MonSesRec2->Blk_1_HostId);\n    printf(\"Blk_2_HostId: %6d   \", MonSesRec2->Blk_2_HostId);\n    printf(\"Blk_3_HostId: %6d\\n\", MonSesRec2->Blk_3_HostId);\n    printf(\"Blk_1_SessNo: %6d   \", MonSesRec2->Blk_1_SessNo);\n    printf(\"Blk_2_SessNo: %6d   \", MonSesRec2->Blk_2_SessNo);\n    printf(\"Blk_3_SessNo: %6d\\n\", MonSesRec2->Blk_3_SessNo);\n    printf(\"Blk_1_UserID: %6d   \", MonSesRec2->Blk_1_UserID);\n    printf(\"Blk_2_UserID: %6d   \", MonSesRec2->Blk_2_UserID);\n    printf(\"Blk_3_UserID: %6d\\n\", MonSesRec2->Blk_3_UserID);\n    printf(\"Blk_1_LMode: %c         \", MonSesRec2->Blk_1_LMode);\n    printf(\"Blk_2_LMode: %c         \", MonSesRec2->Blk_2_LMode);\n    printf(\"Blk_3_LMode: %c\\n\", MonSesRec2->Blk_3_LMode);\n    printf(\"Blk_1_OType: %c         \", MonSesRec2->Blk_1_OType);\n    printf(\"Blk_2_OType: %c         \", MonSesRec2->Blk_2_OType);\n    printf(\"Blk_3_OType: %c\\n\", MonSesRec2->Blk_3_OType);\n    printf(\"Blk_1_ObjDBId: %5d   \", MonSesRec2->Blk_1_ObjDBId);\n    printf(\"Blk_2_ObjDBId: %5d   \", MonSesRec2->Blk_2_ObjDBId);\n    printf(\"Blk_3_ObjDBId: %5d\\n\", MonSesRec2->Blk_3_ObjDBId);\n    printf(\"Blk_1_ObjTId: %6d   \", MonSesRec2->Blk_1_ObjTId);\n    printf(\"Blk_2_ObjTId: %6d   \", MonSesRec2->Blk_2_ObjTId);\n    printf(\"Blk_3_ObjTId: %6d\\n\", MonSesRec2->Blk_3_ObjTId);\n  \n    printf(\"Blk_1_Status: %c        \", MonSesRec2->Blk_1_Status);\n    printf(\"Blk_2_Status: %c        \", MonSesRec2->Blk_2_Status);\n    printf(\"Blk_3_Status: %c\\n\", MonSesRec2->Blk_3_Status);\n    printf(\"MoreBlockers: %c\\n\\n\", MonSesRec2->MoreBlockers);\n    MonSesRec2->LogonSource[MonSesRec2->LogonSourceLen] = '\\0';\n    printf(\"LogonSource: %.128s\\n\\n\", MonSesRec2->LogonSource);\n    /* MonVerId 3 fields */\n    if (version < MONVERSION3)\n        return;\n    printf(\"HotAmp1CPU: %9.2f   \", MonSesRecV3->HotAmp1CPU);\n    printf(\"HotAmp2CPU: %9.2f   \", MonSesRecV3->HotAmp2CPU);\n    printf(\"HotAmp3CPU: %9.2f\\n\", MonSesRecV3->HotAmp3CPU);\n    printf(\"HotAmp1CPUId: %7d   \", MonSesRecV3->HotAmp1CPUId);\n    printf(\"HotAmp2CPUId: %7d   \", MonSesRecV3->HotAmp2CPUId);\n    printf(\"HotAmp3CPUId: %7d\\n\\n\", MonSesRecV3->HotAmp3CPUId);\n    printf(\"HotAmp1IO: %10.2f   \", MonSesRecV3->HotAmp1IO);\n    printf(\"HotAmp2IO: %10.2f   \", MonSesRecV3->HotAmp2IO);\n    printf(\"HotAmp3IO: %10.2f\\n\", MonSesRecV3->HotAmp3IO);\n    printf(\"HotAmp1IOId: %8d   \", MonSesRecV3->HotAmp1IOId);\n    printf(\"HotAmp2IOId: %8d   \", MonSesRecV3->HotAmp2IOId);\nLake - Monitor Resources and Performance\nPage 403 of 420    printf(\"HotAmp3IOId: %8d\\n\\n\", MonSesRecV3->HotAmp3IOId);\n    printf(\"LowAmp1CPU: %9.2f   \", MonSesRecV3->LowAmp1CPU);\n    printf(\"LowAmp2CPU: %9.2f   \", MonSesRecV3->LowAmp2CPU);\n    printf(\"LowAmp3CPU: %9.2f\\n\", MonSesRecV3->LowAmp3CPU);\n    printf(\"LowAmp1CPUId: %7d   \", MonSesRecV3->LowAmp1CPUId);\n    printf(\"LowAmp2CPUId: %7d   \", MonSesRecV3->LowAmp2CPUId);\n    printf(\"LowAmp3CPUId: %7d\\n\\n\", MonSesRecV3->LowAmp3CPUId);\n    printf(\"LowAmp1IO: %10.2f   \", MonSesRecV3->LowAmp1IO);\n    printf(\"LowAmp2IO: %10.2f   \", MonSesRecV3->LowAmp2IO);\n    printf(\"LowAmp3IO: %10.2f\\n\", MonSesRecV3->LowAmp3IO);\n    printf(\"LowAmp1IOId: %8d   \", MonSesRecV3->LowAmp1IOId);\n    printf(\"LowAmp2IOId: %8d   \", MonSesRecV3->LowAmp2IOId);\n    printf(\"LowAmp3IOId: %8d\\n\\n\", MonSesRecV3->LowAmp3IOId);\n    printf(\"AvgAmpCPUSec:%8.2f   \", MonSesRecV3->AvgAmpCPUSec);\n    printf(\"AvgAmpIOCnt: %8.2f\\n\", MonSesRecV3->AvgAmpIOCnt);\n    printf(\"AmpCount: %11d\\n\\n\", MonSesRecV3->AmpCount);\n    printf(\"TempSpaceUsg: %7.2f\\n\\n\", MonSesRecV3->TempSpaceUsage); \n    if (version <MONVERSION4)\n        return;\n    /* MonVerId 4 fields */\n    printf(\"ReqStartTime: %04d/%02d/%02d  \", \n        (int) MonSesRecV4->ReqStartDate / 10000 + 1900,\n        (int) MonSesRecV4->ReqStartDate / 100 % 100, \n        (int) MonSesRecV4->ReqStartDate % 100);\n    printf(\"%02d:%02d:%05.2f\", \n        (int) MonSesRecV4->ReqStartTime / 10000,\n        (int) MonSesRecV4->ReqStartTime / 100 % 100, \n        (int) MonSesRecV4->ReqStartTime % 100 + \n        MonSesRecV4->ReqStartTime - \n        (int) MonSesRecV4->ReqStartTime);\n    printf(\"  ReqCPU: %10.2f\", MonSesRecV4->ReqCPU);\n    printf(\"  ReqIO: %10.2f\\n\", MonSesRecV4->ReqIO);\n    if (version <MONVERSION5)\n        return;\n    /* MonVerId 5 fields */\n    printf(\"ReqNo:%d   WlcId: %d     DontReclassifyFlag: %d\\n\", \n        MonSesRecV5->ReqNo,          \n       MonSesRecV5->WlcId,MonSesRecV5->DontReclassifyFlag);\n}\nstatic void CheckSuccess(int ActivityType,\n                         int ActivityCount,\n                         int StatementNo)\n{\n    switch (ActivityType)\n    {\n        case PCLSTMTNULL:                          \n            printf(\"Null statement successful. \\n\\n\"); \n            break;                                 \n    }\n    return;\n}\nstatic void CheckData(int ActivtyType, int StatementNo)\n{\n   DataInfo_t * DataInfo;\n   int          i;\n   DataInfo = (DataInfo_t *) (dbc.fet_data_ptr);\n   printf(\"\\nCheckData called for Indicator mode data info parcel.\\n\"); \n   printf(\"Field Count: %d \\n\", DataInfo->field_count);\n   IndicFieldCount  = DataInfo->field_count;\n \n   if (DataInfo->field_count > MAXFIELDS)   \n       DataInfo->field_count = MAXFIELDS;\n   for (i = 0; i < DataInfo->field_count; i++)\n   {\n        printf(\"Field %d: Type = %d Size = %d\\n\", i + 1,\n            DataInfo->FieldData[i].FType,\n            DataInfo->FieldData[i].FSize);\n   }\n   return;\n}\nstatic void CheckRecord(int ActivtyType, int StatementNo, int ActivityCount)\n{\nLake - Monitor Resources and Performance\nPage 404 of 420    switch (ActivtyType)\n    {       \n        case PCLMONSESS:\n            if (StatementNo == 1)\n                PrtSes1(dbc.fet_data_ptr);\n            else if (StatementNo == 2)\n            {\n                int IndLen=0;  \n                if (IndicatorMode)         \n                {   \n                    switch (TargetVersion)\n                    {\n                    case MONVERSION3:\n                    case MONVERSION4:\n                       IndLen = 10; \n                       break;\n                    case MONVERSION5:\n                    case MONVERSION6:\n                    default:\n                       IndLen = 11; \n                       break;\n                    }\n                    PrintPresenceBits(dbc.fet_data_ptr,IndicFieldCount,MonSesRec2fieldnamelist); \n                    dbc.fet_data_ptr = (char *)dbc.fet_data_ptr + IndLen;    \n                }                   \n                PrtSes2(dbc.fet_data_ptr,TargetVersion); \n                printf(\"\\n\");\n                printf(\"----------------------------------------------------\\n\\n\");\n            }\n            break;\n        default:\n            printf(\"\\nFound a funny parcel number: %d\\n\",ActivtyType);\n            break;\n    }\n}\n/***************************************************************/\n/*  SET_OPTIONS -- sets cli options (record,field,indicator    */\n/*                 mode; and so on)                            */\n/*                 Sets size of buffers (request and response) */\n/***************************************************************/\nset_options()\n{\n    dbc.change_opts = 'Y';\n    dbc.resp_mode = 'R';\n    dbc.use_presence_bits = 'Y';\n    dbc.keep_resp = 'N';\n    dbc.wait_across_crash = 'N';\n    dbc.tell_about_crash = 'Y';\n    dbc.loc_mode = 'Y';\n    dbc.var_len_req = 'N';\n    dbc.var_len_fetch = 'N';\n    dbc.save_resp_buf = 'N';\n    dbc.two_resp_bufs = 'N';\n    dbc.ret_time = 'N';\n    dbc.parcel_mode = 'Y';\n    dbc.wait_for_resp = 'Y';\n    dbc.req_proc_opt = 'E';\n    dbc.req_buf_len = 256;\n    dbc.resp_buf_len = 32000; \n    return(0);\n} /**end set_options**/\n/***************************************************************/\n/* EXITOUT -- If connected logs off session. Cleans up         */\n/*            any used memory.                                 */\n/***************************************************************/\nvoid exitout(int status)\n{\n    Int32  result;\n    if (status == CONNECTED)\n    { \n        printf (\"Logging off.\\n\");\n        dbc.func = DBFDSC;\nLake - Monitor Resources and Performance\nPage 405 of 420        DBCHCL (&result,cnta,&dbc);\n        if (result != EM_OK)\n            printf(\"disconnect failed -- %s\\n\", dbc.msg_text);\n    }\n    DBCHCLN(&result,cnta);\n    if (result != EM_OK)\n        printf(\"cleanup failed -- %s\\n\", dbc.msg_text);\n    exit(0);\n} /**end exitout**/\n/***************************************************************/\n/* INITIALIZE_DBCAREA -- Sets default options (clispb.dat) in  */\n/*                       dbcarea by calling DBCHINI()          */\n/***************************************************************/\ninitialize_dbcarea()\n{\n    Int32  result;\n    dbc.total_len = sizeof(struct DBCAREA);\n    DBCHINI(&result,cnta,&dbc);\n    if (result != EM_OK)\n    { /* if we can't initialize, we can't go on, so exit */\n        printf(\"init failed -- %s\\n\", dbc.msg_text);\n        exitout(NOT_CONNECTED);\n    }\n    return(0);\n}  /**end initialize_dbcarea**/\n/***************************************************************/\n/* LOGON_TO_DBC -- Connects session and logs on to DBC         */\n/*                 Fetches result of connection to check if    */\n/*                 successful                                  */\n/***************************************************************/\nlogon_to_dbc(char * logonstr)\n{ \n    struct  CliCONNECTType connectstr;\n    Int32   result, i;\n    char    TempString[30];\n    for (i = 0; i < 30; i++)\n        TempString[i] = ' ';\n    for (i = 0; i < 30; i++)\n    {\n        if (logonstr[i] == '/')\n        {\n            TempString[i] = '\\0';\n            break;\n        }\n        TempString[i] = logonstr[i];\n    }\n    printf(\"Logging on to %s ...\\n\", TempString);\n    dbc.logon_ptr = logonstr;\n    dbc.logon_len = strlen(logonstr);\n    dbc.func = DBFCON;\n    dbc.run_ptr = (char *) &connectstr;\n    strncpy(connectstr.PartitionName, \"MONITOR         \", 16);\n    connectstr.Function = 0;\n    dbc.run_len = sizeof(struct CliCONNECTType);\n    DBCHCL(&result,cnta,&dbc);\n    if (result != EM_OK)  /*if connect fails exit*/\n    { \n        printf(\"connect failed -- %s\\n\",dbc.msg_text);\n        exitout(NOT_CONNECTED);\n    }\n    printf(\"Logon successful.\\n\");\n    return(0);\n} /**end logon_to_dbc**/\n/***************************************************************/\n/* CLOSE_REQUEST -- Terminates and cleans up specified request */\n/***************************************************************/\nclose_request(Int32 req_id, Int32 sess_id)\n{\n    Int32  result;\n    dbc.i_sess_id = sess_id;\n    dbc.i_req_id = req_id;\n    dbc.func=DBFERQ;\nLake - Monitor Resources and Performance\nPage 406 of 420    DBCHCL(&result,cnta,&dbc);\n    if (result !=EM_OK)\n    {\n        printf(\"end request failed -- %s\\n\", dbc.msg_text);\n        exitout(CONNECTED);\n    }\n    return(0);\n} /**end close_request**/\n/***************************************************************/\n/* OPEN_REQUEST -- Sends request to DBC                        */\n/***************************************************************/\nopen_request (int InReqType,\n              void *UsingPtr)\n{\n    Int32   result;\n    char    CurrRequestText[32];\n                                  \n    /* set up for a new request */\n    dbc.func = DBFIRQ;            \n    dbc.using_data_ptr = (char *) UsingPtr; \n  \n    switch (InReqType)\n    {\n        case MON_SESS_REQ:\n            strcpy(CurrRequestText,\"MONITOR SESSION;\");\n            dbc.using_data_len = sizeof(monsess_t);\n            break;\n        default: \n            printf(\"Internal error\\n\");\n            exitout(CONNECTED);\n    }\n    dbc.req_ptr = &CurrRequestText[0];\n    dbc.req_len = strlen (CurrRequestText);\n    printf (\"\\nSubmitting request %s ...\\n\", dbc.req_ptr); \n                                                          \n    /* Submit request */\n    DBCHCL (&result,cnta,&dbc);\n    if (result != EM_OK)\n    {\n        printf (\"result = %d \\n\", result);\n        printf (\"initiate request failed -- %s \\n\", dbc.msg_text);\n        exitout(CONNECTED);\n    }\n    return(EM_OK);\n} /**end open_request**/\nint fetch_request(Int32 request, Int32 session)\n{ \n    int     status;\n    int     StatementNo = 0;\n    int     ActivityType = 0;\n    int     ActivityCount = 0;\n    Int32   result;\n    int     ReturnCode;\n    dbc.i_sess_id = session;\n    dbc.i_req_id = request;\n    dbc.func = DBFFET;\n    status = OK;\n    ReturnCode = OK;\n    /* fetch one parcel at a time until all parcels are used up  */\n    /* or an error occurs */\n    while (status == OK)\n    { \n        DBCHCL(&result,cnta,&dbc);\n        if (result == REQEXHAUST) \n            status = STOP;\n        else if (result != EM_OK) \n            status = NOT_OK;\n        else\n        {\n            switch ((Int16) (dbc.fet_parcel_flavor))\n            { \n               case PCLSUCCESS :                        /*Success Parcel */\nLake - Monitor Resources and Performance\nPage 407 of 420                   {\n                    struct  PclSUCCESSType   succ;\n                    memcpy(&succ,dbc.fet_data_ptr-4,4);\n                    memcpy(&succ,dbc.fet_data_ptr-4,succ.Length+4);\n                    StatementNo = succ.StatementNo;\n                    ActivityCount = *(int *)(&succ.ActivityCount[0]);\n                    ActivityType = succ.ActivityType;\n                    if ( succ.WarningLength > 0 )\n                        printf(\"%s \\n\", succ.WarningMsg);\n                    CheckSuccess(ActivityType, ActivityCount, StatementNo);\n                    }\n                    break;\n                case PclDATAINFO :                        \n                    CheckData(ActivityType, StatementNo);\n                    break;\n                case PclRECORD :                         /*Returned data */\n                    CheckRecord(ActivityType, StatementNo, ActivityCount);\n                    break;\n                case PclFAILURE :                        /*Failure parcel*/\n                case PclERROR :                          /*Error parcel  */\n                    status = STOP;\n                    Write_error(dbc.fet_data_ptr);\n                    ReturnCode = PclERROR;\n                    break;\n            } /*switch*/\n        }\n    } /*while*/\n    if (status == NOT_OK)\n    { \n        printf(\"fetch failed -- %s \\n\", dbc.msg_text);\n        exitout(CONNECTED);\n    } /*if*/\n    return(ReturnCode);\n} /**end fetch_request**/\nstatic Boolean MonSession()\n{\n    monsess_t   MonSess;\n    int         i;\n    char        InString[MAXNAME];\n    /* Initializations */\n    MonSess.monheader.version  = TargetVersion;\n    MonSess.monheader.indicbyte = '\\0';\n    for (i = 0; i < MAXNAME; i++)\n        monsess.user[i] = ' ';\n    printf(\"Enter logical hostid (* for all hosts) or Q)uit: \");\n    gets(InString);\n    if (!strcmp(InString, \"*\") || (strlen(InString) == 0))\n        MonSess.hostid = (Int16) 65535; \n    else if (!strcmp(InString, \"Q\") || !strcmp(InString, \"q\"))\n        return (TRUE);\n    else\n        MonSess.hostid = atoi(InString);\n    printf(\"Enter user name (* for all users): \");\n    gets(InString);\n    if (!strcmp(InString, \"*\") || (strlen(InString) == 0))\n    {\n        for (i = 0; i < MAXNAME; i++)\n        {\n            if (InString[i] == '\\0')\n                break;\n            MonSess.user[i] = InString[i];\n        }\n    }\n    printf(\"Enter session number (* for all sessions): \");\n    gets(InString);\n    if (!strcmp(InString, \"*\") || (strlen(InString) == 0))\n        MonSess.session = 0;\n    else\n        MonSess.session = atoi(InString);\n    if (RespMode == 'I' || RespMode == 'i')\n    {\n        dbc.resp_mode = 'I';\nLake - Monitor Resources and Performance\nPage 408 of 420        IndicatorMode = TRUE;\n    }\n    else\n    {\n        dbc.resp_mode = 'R';\n        IndicatorMode = FALSE;\n    }\n    open_request( MON_SESS_REQ,&MonSess);\n    fetch_request(dbc.o_req_id, dbc.o_sess_id);\n    close_request(dbc.o_req_id, dbc.o_sess_id);\n    return (FALSE);\n}\nmain (int argc, char **argv)\n{\n    char    LogonString[MAXLOGONSIZE];\n    Boolean stop = FALSE;\n    initialize_dbcarea();\n    set_options();\n  \n    //6: Teradata 12.x;  5: Teradata 6.x  4: Teradata 5.x\n    TargetVersion = 6;  \n    // 'R' no presence bits returned; 'I' presence bits returned\n    RespMode = 'I';  \n    IndicatorMode = TRUE;\n    printf (\"TargetVersion(argv1) = %d, RespMode(argv2) = %c \\n\\n\",\n            TargetVersion, RespMode);\n    /* Establish session */\n    printf (\"Enter logon string (tdpid/user,password): \");\n    gets (LogonString);\n    if (strlen(LogonString) == 0)\n    {\n       printf (\"NULL logon string not accepted.\\n\");\n       return (1);\n    }\n  \n    logon_to_dbc(LogonString);\n    if (fetch_request(dbc.o_req_id,dbc.o_sess_id) != OK)\n       exitout(NOT_CONNECTED);\n    close_request(dbc.o_req_id,dbc.o_sess_id);\n    while (stop == FALSE)\n       stop = MonSession();\n    /* Logoff and cleanup */\n    exitout(CONNECTED);\n    return 0;\n} /**end main**/\nHeader File for Sample PMPC Application\nThis section deﬁnes the contents for all parcel ﬂavors. Each parcel is deﬁned in the Notes section under the deﬁnition of each parcel.\n#ifndef PMPC_H\n#define PMPC_H\n/* These are standard CLI include files */\n#include \"coptypes.h\"\n#include \"coperr.h\"\n#include \"dbcarea.h\"\n#include \"parcel.h\"\n/*****************************************************************/\n/*   Purpose  To define the data type for kinds of activities\n            returned in the Ok and Success parcels. */\ntypedef unsigned short pclstmt_t;\n/* Purpose  To express the kind of activity within Ok and Success parcels. */\n#define PCLSTMTNUL              (0)\n#define PCLRETSTMT              (1)\n#define PCLINSSTMT              (2)\n#define PCLUPDSTMT              (3)  /*  UPDATE                   */\n#define PCLUPDRETSTMT           (4)  /*  UPDATE ... RETRIEVING    */\n#define PCLDELSTMT              (5)\n#define PCLCTSTMT               (6)\n#define PCLMODTABSTMT           (7)\n#define PCLCVSTMT               (8)\n#define PCLCMSTMT               (9)\n#define PCLDROPTABSTMT          (10)\nLake - Monitor Resources and Performance\nPage 409 of 420#define PCLDROPVIEWSTMT         (11)\n#define PCLDROPMACSTMT          (12)\n#define PCLDROPINDSTMT          (13)\n#define PCLRENTABSTMTT          (14)\n#define PCLRENVIEWSTMT          (15)\n#define PCLRENMACSTMT           (16)\n#define PCLCREINDSTMT           (17)\n#define PCLCDSTMTT              (18)\n#define PCLCREUSERSTMT          (19)\n#define PCLGRANTSTMT            (20)\n#define PCLREVOKESTMT           (21)\n#define PCLGIVESTMT             (22)\n#define PCLDROPDBSTMT           (23)\n#define PCLMODDBSTMT            (24)\n#define PCLDATABASESTMT         (25)\n#define PCLBTSTMT               (26)\n#define PCLETSTMT               (27)\n#define PCLABORTSTMT            (28)\n#define PCLNULLSTMT             (29)\n#define PCLEXECSTMT             (30)\n#define PCLCMNTSETSTMT          (31)  /*  COMMENT set statement       */\n#define PCLCMNTGETSTMT          (32)  /*  COMMENT returning statement */\n#define PCLECHOSTMT             (33)\n#define PCLREPVIEWSTMT          (34)\n#define PCLREPMACSTMT           (35)\n#define PCLCHECKPTSTMT          (36)\n#define PCLDELJRNLSTMT          (37)\n#define PCLROLLBACKSTMT         (38)\n#define PCLRELLOCKSTMT          (39)\n#define PCLHUTCONFIGSTMT        (40)\n#define PCLVCHECKPTSTMT         (41)\n#define PCLDUMPJRNLSTMT         (42)\n#define PCLDUMPDBSTMT           (43)\n#define PCLRESTORESTMT          (44)\n#define PCLROLLFORWSTMT         (45)\n#define PCLDELDBSTMT            (46)\n#define PCLCLEARDUMPST          (47)\n#define PCLSAVEDUMPSTMT         (48)\n#define PCLSHOWSTMT             (49)\n#define PCLHELPSTMT             (50)\n#define PCLBEGINLOADSTMT        (51)\n#define PCLCHKPTLOADSTMT        (52)\n#define PCLENDLOADSTMT          (53)\n#define PCLLINSTMT              (54)\n#define PCLGRANTLOGONSTMT       (55)\n#define PCLREVOKELOGONSTMT      (56)\n#define PCLBEGACCLOGSTMT        (57)\n#define PCLENDACCLOGSTMT        (58)\n#define PCLCOLLSTATSTMT         (59)\n#define PCLDROPSTATSTMT         (60)\n#define PCLSESSETSTMT           (61)\n#define PCLBEGEDITSTMT          (62)\n#define PCLEDITSTMT             (63)\n#define PCLEXECEDITSTM          (64)\n#define PCLENDEDITSTMT          (65)\n#define PCLRELEDITSTMT          (66)\n#define PCLEDITDELSTMT          (67)\n#define PCLEDITINSSTMT          (68)\n#define PCLEDITUPDSTMT          (69)\n#define PCLBEGDELMLSTMT         (70)\n#define PCLDATASTATUS           (71)\n#define PCLBEGEXPORTSTMT        (74)\n#define PCLENDEXPORTSTMT        (75)\n#define PCL2PCVOTEREQ           (76)  /* 2PC vote request.           */\n#define PCL2PCVOTETERM          (77)  /* 2PC vote and terminate.     */\n#define PCL2PCCMMT              (78)  /* 2PC commit request.         */\n#define PCL2PCABRT              (79)  /* 2PC abort request.          */\n#define PCL2PCFORGET            (80)  /* Vote request yes/done       */\n#define PCLSETSESSR             (83)  /* Set Session Rate            */\n#define PCLMONSESS              (84)  /* Monitor Session             */\n#define PCLIDENTIFY             (85)  /* Identify                    */\n#define PCLABTSESS              (86)  /* Abort Session               */\nLake - Monitor Resources and Performance\nPage 410 of 420#define PCLSETRESSR             (87)  /* Set Resource Rate           */\n#define PCLREVALIDATERISTMT     (89)\n#define PCLCOMMITSTMT           (90)\n#define PCLMONVCONFIG           (91)  /* Monitor Virtual Config      */\n#define PCLMONPCONFIG           (92)  /* Monitor Physical Config     */\n#define PCLMONVSUMMARY          (93)  /* Monitor Virtual Summary     */\n#define PCLMONPSUMMARY          (94)  /* Monitor Physical Summary    */\n#define PCLMONVRES              (95)  /* Monitor Virtual Resource    */\n#define PCLMONPRES              (96)  /* Monitor Physical Resource   */\n#define PCLRDLSTMT              (102) /* Replication statement       */\n#define PCLDROPPROCSTMT         (103) /* DROP PROCEDURE SQL          */\n#define PCLCREATEPROCSTMT       (104) /* CREATE PROCEDURE SQL        */\n#define PCLCALLSTMT             (105) /* CALL SQL                    */\n#define PCLRENPROCSTMT          (106) /* RENAME PROCEDURE SQL        */\n#define PCLREPPROCSTMT          (107) /* REPLACE PROCEDURE SQL       */\n#define PCLSETACCT              (108) /* Set Session Account         */\n#define PCLHULSTMT              (109) /* Arcmain Lock Request        */\n#define PCLMONSQL               (110) /* MONITOR SQL                 */\n#define PCLMONVER               (111) /* Monitor Version             */\n#define PCLBEGINDBQLSTMT        (112) /* Begin DBQL                  */\n#define PCLENDDBQLSTMT          (113) /* End DBQL                    */\n#define PCLCREROLESTMT          (114) /* Create Role SQL             */\n#define PCLDRPROLESTMT          (115) /* Drop Role SQL               */\n#define PCLGRANTROLESTMT        (116) /* Grant Role SQL              */\n#define PCLREVOKEROLESTMT       (117) /* Revoke Role SQL             */\n#define PCLCREPROFILESTMT       (118) /* Create Profile SQL          */\n#define PCLMODPROFILESTMT       (119) /* Modify Profile SQL          */\n#define PCLDRPPROFILESTMT       (120) /* Drop Profile SQL            */\n#define PCLSETROLESTMT          (121) /* Set Role SQL                */\n#define PCLCREUDFSTMT           (122) /* Create UDF stmt             */\n#define PCLRPLCUDFSTMT          (123) /* Replace UDF stmt            */\n#define PCLDROPUDFSTMT          (124) /* Drop UDF stmt               */\n#define PCLALTERUDFSTMT         (125) /* Alter UDF stmt              */\n#define PCLRENUDFSTMT           (126) /* Rename UDF stmt             */\n#define PCLMRGMIXEDSTMT         (127) /* Mixture of upd & ins        */\n#define PCLMRGUPDSTMT           (128) /* Upds and no ins             */\n#define PCLMRGINSSTMT           (129) /* Ins and no upds             */\n#define PCLALTERPROCSTMT        (130) /* ALTER PROCEDURE SQL         */\n#define PCLTWMSTATSSTMT         (132) /* TDQM Statistics             */\n#define PCLTWMPERFGROUPSSTMT    (133) /* TDQM get Perf Groups        */\n#define PCLCREUDTSTMT           (134) /* Create UDT stmt             */\n#define PCLDROPUDTSTMT          (135) /* Drop UDT stmt               */\n#define PCLALTERUDTSTMT         (136) /* Alter UDT stmt              */\n#define PCLRPLCUDTSTMT          (137) /* Replace UDT stmt            */\n#define PCLCREUDMSTMT           (138) /* Create UDM stmt             */\n#define PCLALTERUDMSTMT         (139) /* Alter UDM stmt              */\n#define PCLRPLCUDMSTMT          (140) /* Replace UDM stmt            */\n#define PCLCRECASTSTMT          (141) /* Create Cast stmt            */\n#define PCLRPLCCASTSTMT         (142) /* Replace Cast stmt           */\n#define PCLDROPCASTSTMT         (143) /* Drop Cast stmt              */\n#define PCLCREORDSTMT           (144) /* Create Ordering stmt        */\n#define PCLRPLCORDSTMT          (145) /* Replace Ordering stmt       */\n#define PCLDROPORDSTMT          (146) /* Drop Ordering stmt          */\n#define PCLCREXFORMSTMT         (147) /* Create Transform stmt       */\n#define PCLRPLCXFORMSTMT        (148) /* Replace Transform stmt      */\n#define PCLDROPXFORMSTMT        (149) /* Drop Transform stmt         */\n#define PCLCREAUTHSTMT          (150) /* Create Auth stmt            */\n#define PCLDRPAUTHSTMT          (151) /* Drop Auth Stmt              */\n#define PCLTWMDELRQSTCHGSTM     (155) /* TDQM Delay Request Change   */\n#define PCLTWMSUMMARYSTMT       (156) /* TDQM get Summary            */\n#define PCLTWMDYNBUILDSTMT      (160) /* TDWM Dynamic Build          */\n#define PCLTWMLISTWDSTMT        (161) /* TDWM LIST WD                */\n#define PCLSETSESISOLVLSTMT     (162) /* Set Session Isolation Level */\n#define PCLINITIDXANALYSIS      (163) /* Initiate Index Analysis     */\n#define PCLRPLCAUTHSTMT         (164) /* Replace Auth stmt           */\n#define PCLSETQBANDSTMT         (165) /* Set QUERY_BAND stmt         */\n#define PCLLOGARCONSTMT         (166) /* LOGGING ONLINE ARCHIVE ON   */\n#define PCLLOGARCOFFSTMT        (167) /* LOGGING ONLINE ARCHIVE OFF  */\n#define PCLMONQUERYBANDSTMT     (168) /* MONITOR QUERYBAND           */\n#define PCLLOGARCONSTMT         (166) /* LOGGING ONLINE ARCHIVE ON   */\n#define PCLLOGARCOFFSTMT        (167) /* LOGGING ONLINE ARCHIVE OFF  */\n#define PCLCRECORRSTMT          (169)\nLake - Monitor Resources and Performance\nPage 411 of 420#define PCLREPCORRSTMT          (170)\n#define PCLDRPCORRSTMT          (171)\n#define PCLALTCORRSTMT          (172)\n#define PCLUSEREVENTCONTROLSTMT (173) /* USER EVENT CONTROL          */\n#define PCLEVENTSTATUSSTMT      (174) /* EVENT STATUS                */\n#define PCLMONAWTRES            (175) /* MONITOR AWT RESOURCE        */\n#define PCLSPDYNRESULTSET       (176) /* SP Dynamic Result Set       */\n#define MONVERSION3   3\n#define MONVERSION4   4\n#define MONVERSION    MONVERSION4\n#define CONNECTED     0\n#define NOT_CONNECTED 1\n#define OK            0\n#define STOP          1\n#define NOT_OK       -1\n#define MAXLOGONSIZE 100\n#define MAXCOMMANDSIZE 50\n#define MAXNAME 30\n#define SYSMAXRECSIZE   64000\n#define ABORTSESTXT \"ABORT SESSION;\"\n#define SETSESSACCTTXT \"SET SESSION ACCOUNT;\"\n#define MONSESSTXT \"MONITOR SESSION;\"\n#define MONSQLTXT \"MONITOR SQL;\"\n#define TDWMPERFGROUPSTXT \"TDWM PERFGROUPS;\"\n#define TDWMSTATISTICSTXT \"TDWM STATISTICS;\"\n#define MONVERTXT \"MONITOR VERSION;\"\n#define SETSESSTXT \"SET SESSION RATE;\"\n#define SETRESTXT \"SET RESOURCE RATE;\"\n#define MONPHYSUMTXT \"MONITOR PHYSICAL SUMMARY;\"\n#define MONVIRSUMTXT \"MONITOR VIRTUAL SUMMARY;\"\n#define MONVIRRESTXT \"MONITOR VIRTUAL RESOURCE;\"\n#define MONPHYRESTXT \"MONITOR PHYSICAL RESOURCE;\"\n#define MONVIRCONTXT \"MONITOR VIRTUAL CONFIG;\"\n#define MONPHYCONTXT \"MONITOR PHYSICAL CONFIG;\"\n#define IDENTSESTXT \"IDENTIFY SESSION;\"\n#define IDENTDBTXT \"IDENTIFY DATABASE;\"\n#define IDENTTABLETXT \"IDENTIFY TABLE;\"\n#define IDENTUSERTXT \"IDENTIFY USER;\"\n#define HELPTXT \"HELP;\"\ntypedef short SysInt32[2];\ntypedef double fltreal64_t;\ntypedef unsigned short tosprocnum_t;\ntypedef short Integer;\ntypedef enum Request_t\n{\n    ABORTSESSREQ,\n    SETSESSACCTREQ,\n    MONSESSREQ,\n    MONSQLREQ,\n    TDWMPERFGROUPSREQ,\n    TDWMSTATISTICSREQ,\n    MONVERREQ,\n    MONPHYSUM,\n    MONVIRSUM,\n    MONVIRRES,\n    MONPHYRES,\n    MONVIRCON,\n    MONPHYCON,\n    SETSESSREQ,\n    SETRESREQ,\n    IDENTSESREQ,\n    IDENTDBREQ,\n    IDENTTABLEREQ,\n    IDENTUSERREQ\n} Request_t;\n#pragma pack(1)\n/* Input parcel structure for PMPC requests */\ntypedef struct\n{\n    char  indicbyte;\n    Int16 version;\n} monheader_t;\nLake - Monitor Resources and Performance\nPage 412 of 420typedef struct\n{\n    monheader_t monheader;\n    Int16 hostid;\n    Int32 session;\n    char  user[30];\n    char  listsess;\n    char  logoffsess;\n    char  override;\n} abortsess_t;\ntypedef struct\n{\n   monheader_t monheader;\n   Int16 hostid;\n   Int32 session;\n   char  acct[30];\n   char  entiresess;\n} setsessacct_t;\ntypedef struct\n{\n    monheader_t monheader;\n    Int16 hostid;\n    Int32 session;\n    char  user[30];\n} monsess_t;\ntypedef struct\n{\n    monheader_t monheader;\n    Int16 hostid;\n    Int32 session;\n} monsql_t;\ntypedef struct\n{\n    monheader_t monheader;\n    Int16 samplerate;\n    char  LocalChange;\n    char  VirtualChange;\n} setrate_t;\ntypedef struct\n{\n    Int16 hostid;\n    Int32 sessionno;\n} identses_t;\ntypedef struct\n{\n    monheader_t monheader;\n    union\n    {\n        Int32 objid;\n        identses_t identses;\n    } UU;\n} identify_t;\n/* Output record parcel structures */\ntypedef struct\n{\n    Int16    HostId;       /* Logical Host Identifier */\n    char     UserName[30]; /* User (database) Name of this session */\n    SysInt32 SessionNo;    /* Session Number of session */\n    char     AbortStatus;  /* Status of aborted session */\n} MonAbtSes_t;\ntypedef struct\n{\n   Int16 HostId; /* Logical Host Identifier */\n   Int16 LogonProcId; /* Processor number session logged on to */\n   Int16 RunProcId; /* Procnum the session initiates requests to */\n   Int32 SessionNo; /* Session Number of session */\n   char UserName[30]; /* User (database) Name of this session */\n   char UserAccount[30]; /* Acct name that this User logged in with */\n   Int32 UserID; /* User (database) Identifier for this session */\n   Int32 LSN; /* Logon Sequence Number */\n   double LogonTime; /* Logon Time for this session */\n   Int32 LogonDate; /* Logon Date */\nLake - Monitor Resources and Performance\nPage 413 of 420   char PartName[16]; /* Session Partition Name this session is associated with */\n   char Priority[2]; /* DBC run priority (Low, Medium, High, Rush) */\n   char PEState[18]; /* Current state of this session in the PE */\n   double PECPUSec; /* Current elapsed cpu usage in PE for sess */\n   double XactCount; /* Number of transactions processed by a DBC SQL session */\n   double ReqCount; /* Number of requests processed by a session */\n   double ReqCacheHits; /* Number of Request Cache uses inDBC/SQL sess */\n   char AMPState[18]; /* Current state of associated session in AMP processors */\n   double AMPCPUSec; /* Current elapsed cpu usage in AMP ( TOTAL ) */\n   double AMPIO; /* Current Total Logical I/O count for associated session */\n   double Delta_AMPSpool; /* Total Spool space change for the associated session */\n   Int16 Blk_1_HostId; /* Logical HostId of a session causing block */\n   Int32 Blk_1_SessNo; /* Session Number of a session causing block */\n   Int32 Blk_1_UserID; /* User Identifier of a Host Utility Job causing block */\n   char Blk_1_LMode; /* Mode (Severity) of lock involved in causing a block */\n   char Blk_1_OType; /* Type (Database/Table/Row Hash) of object being locked */\n   Int32 Blk_1_ObjDBId; /* DB Identifier of object being locked */\n   Int32 Blk_1_ObjTId; /* TBID (If applicable) of object being locked */\n   char Blk_1_Status;\n   Int16 Blk_2_HostId;\n   Int32 Blk_2_SessNo;\n   Int32 Blk_2_UserID;\n   char Blk_2_LMode;\n   char Blk_2_OType;\n   Int32 Blk_2_ObjDBId;\n   Int32 Blk_2_ObjTId;\n   char Blk_2_Status;\n   Int16 Blk_3_HostId;\n   Int32 Blk_3_SessNo;\n   Int32 Blk_3_UserID;\n   char Blk_3_LMode;\n   char Blk_3_OType;\n   Int32 Blk_3_ObjDBId;\n   Int32 Blk_3_ObjTId;\n   char Blk_3_Status;\n   char MoreBlockers; /* Indicates there are more lock conflicts */\n   Int16 LogonSourceLen; /* Logon source length (Variable Length) */\n   char LogonSource[128];/* Logon source info (Variable Length) */\n} MonSesRec2_t;\ntypedef struct\n{\n   double TempSpaceUsage; /* Temporary space usage for the associated session */\n   fltreal64_t HotAmp1CPU;\n   fltreal64_t HotAmp2CPU;\n   fltreal64_t HotAmp3CPU;\n   fltreal64_t HotAmp1IO;\n   fltreal64_t HotAmp2IO;\n   fltreal64_t HotAmp3IO;\n   Word HotAmp1CPUId;\n   Word HotAmp2CPUId;\n   Word HotAmp3CPUId;\n   Word HotAmp1IOId;\n   Word HotAmp2IOId;\n   Word HotAmp3IOId;\n   fltreal64_t LowAmp1CPU;\n   fltreal64_t LowAmp2CPU;\n   fltreal64_t LowAmp3CPU;\n   fltreal64_t LowAmp1IO;\n   fltreal64_t LowAmp2IO;\n   fltreal64_t LowAmp3IO;\n   Word LowAmp1CPUId;\n   Word LowAmp2CPUId;\n   Word LowAmp3CPUId;\n   Word LowAmp1IOId;\n   Word LowAmp2IOId;\n   Word LowAmp3IOId;\n   Word AmpCount;\n   fltreal64_t AvgAmpCPUSec;\n   fltreal64_t AvgAmpIOCnt;\n} MonSesRecV3_t;\ntypedef struct\n{\nLake - Monitor Resources and Performance\nPage 414 of 420   double ReqStartTime;\n   Int32 ReqStartDate;\n   fltreal64_t ReqCPU;\n   fltreal64_t ReqIO;\n} MonSesRecV4_t;\ntypedef struct\n{\n   Int32 ReqNo;\n   Int32 WlcId;\n   Int16 DontReclassifyFlag;\n} MonSesRecV5_t;\ntypedef struct\n{\n    fltreal64_t    AvgCPU;\n    fltreal64_t    AvgDisk;\n    fltreal64_t    AvgDiskIO;\n    fltreal64_t    HighCPUUse;\n    tosprocnum_t   HighCPUProcId;\n    fltreal64_t    LowCPUUse;\n    tosprocnum_t   LowCPUProcId;\n    fltreal64_t    HighDisk;\n    tosprocnum_t   HighDiskProcId;\n    fltreal64_t    LowDisk;\n    tosprocnum_t   LowDiskProcId;\n    fltreal64_t    HighDiskIO;\n    tosprocnum_t   HighDiskIOProcId;\n    fltreal64_t    LowDiskIO;\n    tosprocnum_t   LowDiskIOProcId;\n    fltreal64_t    NetUse;\n    char           NetAUp;\n    char           NetBUp;\n    Integer        ResLogging;\n    Integer        ResMonitor;\n    char           Release[29];\n    char           Version[32];\n} MonPhySum_t;\ntypedef struct\n{\n    fltreal64_t    AMPAvgCPU;\n    fltreal64_t    AMPAvgDisk;\n    fltreal64_t    AMPAvgDiskIO;\n    fltreal64_t    HiCPUAMPUse;\n    tosprocnum_t   HiCPUAMPNo;\n    tosprocnum_t   HiCPUAMPProc;\n    fltreal64_t    LoCPUAMPUse;\n    tosprocnum_t   LoCPUAMPNo;\n    tosprocnum_t   LoCPUAMPProc;\n    fltreal64_t    HiDiskAMP;\n    tosprocnum_t   HiDiskAMPNo;\n    tosprocnum_t   HiDiskAMPProc;\n    fltreal64_t    LoDiskAMP;\n    tosprocnum_t   LoDiskAMPNo;\n    tosprocnum_t   LoDiskAMPProc;\n    fltreal64_t    HiDiskAMPIO;\n    tosprocnum_t   HiDiskAMPIONo;\n    tosprocnum_t   HiDiskAMPIOProc;\n    fltreal64_t    LoDiskAMPIO;\n    tosprocnum_t   LoDiskAMPIONo;\n    tosprocnum_t   LoDiskAMPIOProc;\n    fltreal64_t    PEAvgCPU;\n    fltreal64_t    HiCPUPEUse;\n    tosprocnum_t   HiCPUPENo;\n    tosprocnum_t   HiCPUPEProc;\n    fltreal64_t    LoCPUPEUse;\n    tosprocnum_t   LoCPUPENo;\n    tosprocnum_t   LoCPUPEProc;\n    fltreal64_t    SessionCount;\n    Integer        SesMonitorSys;\n    Integer        SesMonitorLoc;\n    Integer        ResLogging;\n    Integer        ResMonitor;\n    char           Release[29];\nLake - Monitor Resources and Performance\nPage 415 of 420    char           Version[32];\n} MonVirSum_t;\ntypedef struct \n{\n    char           NetAUp;\n    char           NetBUp;\n    Int16          SampleRate;\n} MonVirRes1_t;\ntypedef struct \n{\n    char           NetAUp;\n    char           NetBUp;\n    char           SystemType[7];\n} MonConfig_t;\ntypedef struct\n{\n    Integer        ProcId;\n    Integer        VProcNo;\n    char           VprocType[3];\n    Int16          HostId;\n    char           Status;\n    Int16          DiskSlice;\n} MonVirConfig_t;\ntypedef struct\n{\n    Integer        ProcId;\n    char           Status;\n    char           CpuType[7];\n    Integer        CpuCount;    \n} MonPhyConfig_t;\ntypedef struct\n{\n    char           VprocType[3];\n    Integer        ProcId;\n    Integer        VProcNo;\n    Integer        ClusterNo;\n    fltreal64_t    CPUUse;\n    char           Status;\n    Integer        SessLogCount;\n    Integer        SessRunCount;\n    fltreal64_t    DiskUse;\n    fltreal64_t    DiskReads;\n    fltreal64_t    DiskWrites;\n    fltreal64_t    DiskOutReqAvg;\n    fltreal64_t    HostBlockReads;\n    fltreal64_t    HostBlockWrites;\n    fltreal64_t    MemAllocates;\n    fltreal64_t    MemAllocateKB;\n    fltreal64_t    PctService;\n    fltreal64_t    PctAMPWT;\n    fltreal64_t    PctParser;\n    fltreal64_t    PctDispatcher;\n    fltreal64_t    NetReads;\n    fltreal64_t    NetWrites;\n    fltreal64_t    NVMemAllocSegs;\n} MonVirRes2_t;\ntypedef struct\n{\n    Integer        ProcId;\n    Integer        AmpCount;\n    Integer        PECount;\n    fltreal64_t    CPUUse;\n    fltreal64_t    PercentKernel;\n    fltreal64_t    PercentService;\n    fltreal64_t    PercentUser;\n    char           Status;\n    fltreal64_t    NetAUse;\n    fltreal64_t    NetBUse;\n    fltreal64_t    DiskUse;\n    fltreal64_t    CICUse;\n    fltreal64_t    DiskReads;\n    fltreal64_t    DiskWrites;\nLake - Monitor Resources and Performance\nPage 416 of 420    fltreal64_t    DiskOutReqAvg;\n    fltreal64_t    HostBlockReads;\n    fltreal64_t    HostBlockWrites;\n    fltreal64_t    SwapReads;\n    fltreal64_t    SwapWrites;\n    fltreal64_t    SwapDrops;\n    fltreal64_t    MemAllocates;\n    fltreal64_t    MemAllocateKB;\n    fltreal64_t    MemFailures;\n    fltreal64_t    MemAgings;\n    fltreal64_t    NetReads;\n    fltreal64_t    NetWrites;\n} MonPhyRes2_t;\ntypedef struct \n{\n    Integer        NumOfSteps;\n    Integer        CurStepBegNum;\n    Integer        CurStepEndNum;\n} MonSqlStepInfo_t;\ntypedef struct\n{\n    fltreal64_t    EstRowCount;\n    fltreal64_t    ActRowCount;\n    fltreal64_t    EstElapTime;\n    fltreal64_t    ActElapTime;\n} MonSqlStepStats_t;\ntypedef struct\n{\n    char          OldAcct[MAXNAME] ;\n    Int16         ErrorCode;\n} SetSessAcct_t;\ntypedef struct ERROR_FAIL_Type {\n    Word         StatementNo;\n    Word         Info;\n    Word         Code;\n    Word         Length;\n    char         Msg[255];\n} Error_Fail_t;\n#define MAXFIELDS 100\ntypedef struct InfoPairs\n{\n    short FType;\n    short FSize;\n} InfoPairs;\ntypedef struct DataInfo_t\n{\n    short field_count;\n    InfoPairs FieldData[MAXFIELDS];\n       \n} DataInfo_t; \n#pragma pack()\n#endif\nMONITOR SESSION Response Combinations\nThe following lists all the possible combinations of the PEState and AMPState response values returned from a MONITOR SESSION request and the resulting effect of each\ncombination on session states. For a detailed description of each of these response values, see MONITOR SESSION.\nSample PM/API MONITOR SESSION Request Responses\nAs described in the following table, the MONITOR SESSION request returns both the PEState and AMPState response values. A client performance monitoring application interprets\nthe meaning of the PEState and AMPState combination, which is displayed as the session state in the client application.\nThe session state is interpreted by the client application, not returned by a PM/API CLIv2 or Teradata JDBC Driver request.\nPEState AMPState Session State\nHOST-RESTART any AMP state HOST-RESTART\nABORTING ABORTING ABORTING\nABORTING ACTIVE ABORTING\nABORTING BLOCKED ABORTING\nABORTING IDLE ABORTING\nLake - Monitor Resources and Performance\nPage 417 of 420PEState AMPState Session State\nABORTING UNKNOWN ABORTING\nPARSING-WAIT ABORTING ABORTING\nPARSING-WAIT BLOCKED BLOCKED\nPARSING-WAIT ACTIVE PARSING\nPARSING-WAIT IDLE PARSING\nPARSING-WAIT UNKNOWN PARSING\nPARSING ABORTING ABORTING\nPARSING BLOCKED BLOCKED\nPARSING ACTIVE PARSING\nPARSING IDLE PARSING\nPARSING UNKNOWN PARSING\nDISPATCHING ABORTING ABORTING\nDISPATCHING BLOCKED BLOCKED\nDISPATCHING ACTIVE ACTIVE\nDISPATCHING IDLE IDLE\nDISPATCHING UNKNOWN ACTIVE\nELICIT CLIENT DATA ABORTING ABORTING\nELICIT CLIENT DATA BLOCKED BLOCKED\nELICIT CLIENT DATA ACTIVE ACTIVE\nELICIT CLIENT DATA IDLE ACTIVE\nELICIT CLIENT DATA UNKNOWN ACTIVE\nRESPONSE ABORTING ABORTING\nRESPONSE BLOCKED BLOCKED\nRESPONSE ACTIVE RESPONSE\nRESPONSE IDLE RESPONSE\nRESPONSE UNKNOWN RESPONSE\nRESPONSE-HELD any AMP state RESPONSE-HELD\nACTIVE ABORTING ABORTING\nACTIVE BLOCKED BLOCKED\nACTIVE ACTIVE ACTIVE\nACTIVE IDLE ACTIVE\nACTIVE UNKNOWN ACTIVE\nIDLE: IN-DOUBT ABORTING UNKNOWN\nIDLE: IN-DOUBT BLOCKED UNKNOWN\nIDLE: IN-DOUBT ACTIVE UNKNOWN\nIDLE: IN-DOUBT IDLE UNKNOWN\nIDLE: IN-DOUBT UNKNOWN UNKNOWN\nIDLE ABORTING IDLE\nIDLE BLOCKED IDLE\nIDLE ACTIVE IDLE\nIDLE IDLE IDLE\nIDLE UNKNOWN IDLE\nDELAYED any AMP state DELAYED\nSESDELAYED any AMP state SESDELAYED\nQTDELAYED any AMP state QTDELAYED\nBLOCKED IDLE BLOCKED\nA BLOCKED session state in monitor partition session means\nbackground activity is in progress and the last request is on hold until\nLake - Monitor Resources and Performance\nPage 418 of 420PEState AMPState Session State\nthis background activity is completed. Database locks are not directly\ninvolved in BLOCKED monitor partition sessions.\nWorkload Management API\nWorkload management API consists of interfaces to PM/APIs and open APIs. You can use these interfaces to:\nMonitor system and session-level activities.\nMonitor Teradata Active System Management (ASM) activity.\nTrack system usage and manage task priorities.\nModify Workload Management ruleset.\nAPI Categories\nPM/APIs and open APIs, also called SQL interfaces, are divided into the following categories:\nSystem PMPC\nTeradata Dynamic Workload Management\nQuery Band\nRuleset\nEmbedded services system is another category that applies only to some of the SQL interfaces (for example, the GetPSFVersion and TD_get_COD_limits functions).\nThe following diagram shows how:\nThe System PMPC, Teradata Dynamic Workload Management, and Query Band PM/API requests (such as Call-Level Interface Version 2 [CLIv2] and the Teradata JDBC Driver)\ninterface to the PMPC subsystem through the MONITOR partition.\nThese PM/APIs are supported by both Call-Level Interface Version 2 (CLIv2) and the Teradata JDBC Driver. See Teradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nThe System PMPC and Teradata Dynamic Workload Management SQL interfaces (such as, user-deﬁned functions and external stored procedures) connect to the PMPC\nsubsystem through the SQL partition, except TDWMApply, TDWMRuleControl, and TDWMSetLimits. These APIs connect to the database system through the SQL partition and\nare not shown in the following diagram.\nThe embedded services system and most Query Band SQL interfaces connect to the SQL partition, except MonitorQueryband. This SQL interface is the only Query Band API\nthat connects to the PMPC subsystem through the SQL partition and is not shown in the following diagram.\nSee also:\nWorkload Management API Features and Examples\nSystem PMPC APIs\nTeradata Dynamic Workload Management APIs: PM/APIs\nWorkload Management: Query Band APIs\nWorkload Management: Embedded Services System APIs\nWorkload Management: Ruleset APIs\nPM/APIs\nPM/APIs provide access to PMPC routines resident in Teradata Vantage™. The PMPC subsystem is available through a logon partition called MONITOR, using a specialized PM/ API\nsubset of CLIv2 or Teradata JDBC Driver.\nPM/APIs have the following features:\nLake - Monitor Resources and Performance\nPage 419 of 420CLIv2 or Teradata JDBC Driver data is acquired in near real time, with less overhead and minimal possibility of being blocked. These capabilities allow frequent in-process\nperformance analysis.\nCLIv2 request saves the raw data in an in-memory buffer where a client application program can easily retrieve the data for real-time analysis or importing into custom reports.\nThe Teradata JDBC Driver returns the data as a JDBC ResultSet where a client application program can easily retrieve the data.\nCLIv2 or Teradata JDBC Driver request provides access to data that the resource usage does not. For example, session-level resource usage data, and data on application\nlocks and which application is being blocked.\nUsing PM/APIs may not be the right choice for all performance monitoring requirements. Standard performance monitoring tools and reports, such as resource usage reports, may be\nsufﬁcient.\nOpen APIs\nThe workload management open API provides an SQL interface to the PMPC subsystem and Teradata system through user-deﬁned functions, embedded services functions, and\nexternal stored procedures. Most of the SQL interfaces available to the PMPC subsystem provide similar functionality to the CLIv2 or Teradata JDBC Driver requests.\nMost open APIs do not follow transaction rules. If a transaction calls a UDF or external stored procedure and the transaction rolls back, the action of the UDF or external stored\nprocedure is not rolled back. However, the external stored procedures that update the TDWM database must follow the transaction rules. If a transaction calls one of these external\nstored procedures and the transaction is aborted, the update is rolled back.\nDifferences between Open APIs and PM/APIs\nThe following table describes the differences between open APIs (that is, SQL interfaces consisting of UDFs or external stored procedures) and PM/APIs.\nOpen APIs PM/APIs\nAre issued in the current SQL partition Require logging on to the MONITOR partition. To view a diagram of the process, see API\nCategories.\nRequire EXECUTE privilege on the function or external stored procedure Require MONITOR privileges.\nUse SQL parsing, dispatching steps, and UDF processing Require use of a custom application in C, Java, or another programming language.\nRun in priority of account string or by the Teradata dynamic workload management\nsoftware classiﬁcationRun in the system priority.\nCan be placed on a Teradata dynamic workload management software delay queue\nand can block system resourcesDo not block.\nUse AMP Worker Tasks (AWTs) Are not subject to running out of resources (AWTs).\nPM/APIs Requirements for Using the API\nIf you are using CLIv2, you must install CLIv2 on a client machine where the PM/API application is running.\nIf you are using the Teradata JDBC Driver, you must import the SQL Interface package and load the Teradata JDBC Driver. For complete instructions, see Teradata JDBC Driver\nReference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.\nRequired Privileges\nEach API described in this document, except for the MONITOR VERSION request and the embedded services system functions, has its own required privileges.\nFollowing are examples of the required privileges.\nTo connect with the Teradata JDBC Driver, it is necessary that you are granted privileges for running PM/API requests. For example, you must issue GRANT MONITOR TO guest\nbefore connecting as a guest user and running any PM/API request.\nTo issue the ABORT SESSION and MONITOR SESSION requests, you must have the ABORTSESSION and MONSESSION privileges respectively as part of your default role or\nthese privileges must be granted directly to you.\nTo issue the MONITOR AWT RESOURCE, MONITOR VIRTUAL RESOURCE, and MONITOR PHYSICAL RESOURCE requests, you must have the MONRESOURCE privilege as\npart of your default role or this privilege must be granted directly to you.\nTo access the UDFs and external stored procedures, the DBA must grant EXECUTE FUNCTION and EXECUTE PROCEDURE privileges to you. These privileges are not granted\nby default.\nFor more information on roles and privileges, see:\nUsing Roles to Manage User Privileges\nTeradata JDBC Driver Reference, available at https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html\nRelated Information\nTopic Reference\nthe different System PMPC PM/APIs and open APIs System PMPC APIs.\nthe different Teradata Dynamic Workload Management PM/APIs and open APIs Teradata Dynamic Workload Management APIs: PM/APIs.\nthe different Workload Management ruleset APIs Workload Management: Ruleset APIs\nthe different Query band PM/APIs and open APIs Workload Management: Query Band APIs.\nLake - Monitor Resources and Performance\nPage 420 of 420Topic Reference\nthe different embedded services system functions Workload Management: Embedded Services System APIs.\nhow to code an application that uses the CLIv2 requests in this document\nTeradata® Call-Level Interface Version 2 Reference for Mainframe-Attached\nSystems, B035-2417.\nTeradata® Call-Level Interface Version 2 Reference for Workstation-Attached\nSystems, B035-2418.\nusing the Teradata JDBC Driver to access the database\nTeradata JDBC Driver Reference, available at https://teradata-\ndocs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/frameset.html.",
  "metadata": {
    "document_id": "96682e33-0000-489d-a12a-2b9a92648d20",
    "collection_id": 19,
    "repository_type": "knowledge",
    "filename": "TD Performance.pdf",
    "document_type": "pdf",
    "source": "upload",
    "title": "TD Performance.pdf",
    "author": "Rainer G",
    "tags": "Performance",
    "category": "Manual",
    "created_at": "2025-11-29T13:18:00.717800+00:00",
    "file_size": 12458126,
    "page_count": 0
  },
  "created_at": "2025-11-29T13:18:01.542259+00:00"
}