# Trusted Data Agent REST API Documentation

## 1. Introduction

Welcome to the Trusted Data Agent (TDA) REST API. This API provides a programmatic interface to interact with the agent's powerful data analysis and querying capabilities.

The API is designed around an **asynchronous task-based architecture**. This pattern is ideal for handling potentially long-running agent processes in a robust and scalable way. Instead of holding a connection open while the agent works, you initiate a task and then poll a status endpoint to get progress updates and the final result. You can also cancel a running task if needed.

### Key Features

- **Asynchronous Query Execution**: Submit queries and poll for results without holding connections
- **RAG Collection Management**: Create and manage collections of query patterns for context-aware responses
- **Template-Based Population**: Use modular templates to automatically generate RAG case studies
- **LLM-Assisted Generation**: Generate question/SQL pairs automatically from database schemas
- **MCP Server Integration**: Connect to multiple Model Context Protocol servers for data access
- **Session Management**: Maintain conversation context across multiple queries

This document provides a comprehensive guide to all available endpoints and data models.

**For detailed RAG template documentation, see**: `docs/RAG_Templates/README.md`

## 2. Authentication

Most endpoints in the Trusted Data Agent REST API (v1) now require a `X-TDA-User-UUID` header for authentication and user identification. This UUID is a unique identifier generated by the client (e.g., by the provided example scripts) and is used to associate sessions and tasks with a specific user.

*   **`X-TDA-User-UUID`**: A client-generated UUID (e.g., `a1b2c3d4-e5f6-7890-1234-567890abcdef`) that must be included in the headers of most requests. This allows the API to manage user-specific sessions and tasks.

The `/v1/configure` endpoint is an exception and does not require this header, as it deals with global application configuration. Future versions may introduce more robust API key or OAuth-based authentication.

## 3. API Endpoints

The base URL for all endpoints is `/api`.

### 3.1. Configure Application

**Note:** Exemplary configuration files for all supported providers can be found in the `docs/RestAPI/scripts/sample_configs` directory. These files can be used as a starting point for your own configurations.

Initializes and validates the agent's core services, including the LLM provider and the MCP server connection. This is the first step required before creating sessions or submitting queries.

* **Endpoint**: `POST /v1/configure`
* **Method**: `POST`
* **Body**:
    A JSON object containing the full configuration. The structure varies slightly by provider.

    **For Google, Anthropic, OpenAI:**
    ```json
    {
      "provider": "Google",
      "model": "gemini-1.5-flash-latest",
      "credentials": {
        "apiKey": "YOUR_API_KEY"
      },
      "mcp_server": {
        "name": "my_mcp_server",
        "host": "localhost",
        "port": 8001,
        "path": "/mcp"
      }
    }
    ```

    **For Friendli:**
    ```json
    {
      "provider": "Friendli",
      "model": "google/gemma-3-27b-it",
      "credentials": {
        "apiKey": "YOUR_FRIENDLI_API_KEY",
        "friendli_endpoint_url": "YOUR_FRIENDLI_ENDPOINT_URL" 
      },
      "mcp_server": { ... }
    }
    ```

    **For Amazon Bedrock:**
    ```json
    {
      "provider": "Amazon",
      "model": "amazon.titan-text-express-v1",
      "credentials": {
        "aws_access_key_id": "YOUR_AWS_ACCESS_KEY",
        "aws_secret_access_key": "YOUR_AWS_SECRET_KEY",
        "aws_region": "us-east-1"
      },
      "mcp_server": { ... }
    }
    ```

    **For Ollama:**
    ```json
    {
      "provider": "Ollama",
      "model": "llama2",
      "credentials": {
        "ollama_host": "http://localhost:11434"
      },
      "mcp_server": { ... }
    }
    ```

* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "MCP Server 'my_mcp_server' and LLM configured successfully."
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (e.g., if configuration fails validation)
    * **Content**:
        ```json
        {
          "status": "error",
          "message": "Configuration failed: Authentication failed. Please check your API keys or credentials."
        }
        ```

### 3.2. Create a New Session

Creates a new, isolated conversation session for the agent. A session stores context and history for subsequent queries.

* **Endpoint**: `POST /v1/sessions`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **Body**: None
* **Success Response**:
    * **Code**: `201 Created`
    * **Content**:
        ```json
        {
          "session_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
        }
        ```
* **Error Response**:
    * **Code**: `503 Service Unavailable` (if services are not configured via `/v1/configure`)
    * **Content**:
        ```json
        {
          "error": "Application is not configured. Please connect to LLM and MCP services first."
        }
        ```

### 3.3. Submit a Query

Submits a natural language query to a specific session. This initiates a background task for the agent to process the query.

* **Endpoint**: `POST /v1/sessions/{session_id}/query`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `session_id` (string, required): The unique identifier for the session, obtained from the "Create a New Session" endpoint.
* **Body**:
    ```json
    {
      "prompt": "Your natural language query for the agent."
    }
    ```
* **Success Response**:
    * **Code**: `202 Accepted`
    * **Content**:
        ```json
        {
          "task_id": "task-9876-5432-1098-7654",
          "status_url": "/api/v1/tasks/task-9876-5432-1098-7654"
        }
        ```
* **Error Responses**:
    * **Code**: `404 Not Found` (if `session_id` is invalid)
    * **Code**: `400 Bad Request` (if the `prompt` field is missing from the request body)

### 3.4. Get Task Status and Result

Polls for the status of a background task. This endpoint provides real-time progress updates through an event log and delivers the final result when the task is complete.

* **Endpoint**: `GET /v1/tasks/{task_id}`
* **Method**: `GET`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `task_id` (string, required): The unique identifier for the task, obtained from the "Submit a Query" endpoint.
* **Success Responses**:
    * **Code**: `200 OK`
    * See section **4. The Task Object** for detailed response content.
* **Error Response**:
    * **Code**: `404 Not Found` (if `task_id` is invalid)

### 3.5. Cancel Task Execution

Requests cancellation of an actively running background task.

* **Endpoint**: `POST /v1/tasks/{task_id}/cancel`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `task_id` (string, required): The unique identifier for the task to cancel.
* **Body**: None
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Cancellation request sent."
        }
        ```
* **Informational Response (Task Already Done)**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "info",
          "message": "Task already completed."
        }
        ```
* **Error Response**:
    * **Code**: `404 Not Found` (if `task_id` does not correspond to an active or recently completed task)
    * **Content**:
        ```json
        {
          "status": "error",
          "message": "No active task found for this task ID."
        }
        ```

### 3.6. RAG Collection Management

#### 3.6.1. Get All RAG Collections

Get all configured RAG collections with their active status.

* **Endpoint**: `GET /v1/rag/collections`
* **Method**: `GET`
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "collections": [
            {
              "id": 1,
              "name": "Support Queries",
              "description": "Customer support query patterns",
              "mcp_server_id": "prod_server",
              "enabled": true,
              "is_active": true
            }
          ]
        }
        ```

#### 3.6.2. Create RAG Collection

Create a new RAG collection. All collections must be associated with an MCP server.

* **Endpoint**: `POST /v1/rag/collections`
* **Method**: `POST`
* **Body**:
    ```json
    {
      "name": "Support Queries",
      "description": "Customer support query patterns",
      "mcp_server_id": "prod_server"
    }
    ```
* **Success Response**:
    * **Code**: `201 Created`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Collection created successfully",
          "collection_id": 1,
          "mcp_server_id": "prod_server"
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (if `mcp_server_id` is missing)

#### 3.6.3. Update RAG Collection

Update a RAG collection's metadata (name, description, MCP server association).

* **Endpoint**: `PUT /v1/rag/collections/{collection_id}`
* **Method**: `PUT`
* **URL Parameters**:
    * `collection_id` (integer, required): The collection ID
* **Body**:
    ```json
    {
      "name": "Updated Name",
      "description": "Updated description",
      "mcp_server_id": "new_server"
    }
    ```
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `400 Bad Request` (if attempting to remove `mcp_server_id`)
    * **Code**: `404 Not Found` (if collection doesn't exist)

#### 3.6.4. Delete RAG Collection

Delete a RAG collection and its vector store.

* **Endpoint**: `DELETE /v1/rag/collections/{collection_id}`
* **Method**: `DELETE`
* **URL Parameters**:
    * `collection_id` (integer, required): The collection ID
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `404 Not Found`

#### 3.6.5. Toggle RAG Collection

Enable or disable a RAG collection.

* **Endpoint**: `POST /v1/rag/collections/{collection_id}/toggle`
* **Method**: `POST`
* **URL Parameters**:
    * `collection_id` (integer, required): The collection ID
* **Body**:
    ```json
    {
      "enabled": true
    }
    ```
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `400 Bad Request` (if enabling a collection without MCP server assignment)

#### 3.6.6. Refresh RAG Collection

Refresh the vector store for a specific collection (rebuilds from case files).

* **Endpoint**: `POST /v1/rag/collections/{collection_id}/refresh`
* **Method**: `POST`
* **URL Parameters**:
    * `collection_id` (integer, required): The collection ID
* **Success Response**:
    * **Code**: `202 Accepted`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Collection refresh started"
        }
        ```

#### 3.6.7. Submit Case Feedback

Submit user feedback (upvote/downvote) for a RAG case.

* **Endpoint**: `POST /v1/rag/cases/{case_id}/feedback`
* **Method**: `POST`
* **URL Parameters**:
    * `case_id` (string, required): The case UUID
* **Body**:
    ```json
    {
      "feedback_score": 1
    }
    ```
    * `feedback_score`: `-1` (downvote), `0` (neutral), `1` (upvote)
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Feedback submitted successfully",
          "case_id": "f3a16261-82a9-5d30-a654-64af74f19fcd",
          "feedback_score": 1
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (invalid feedback_score)
    * **Code**: `404 Not Found` (case not found)

### 3.6A. RAG Template System

The RAG Template System enables automatic generation of RAG case studies through modular templates with LLM-assisted question generation.

#### 3.6A.1. List Available Templates

Get all registered RAG templates.

* **Endpoint**: `GET /v1/rag/templates`
* **Method**: `GET`
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "templates": [
            {
              "template_id": "sql_query_v1",
              "display_name": "SQL Query Template - Business Context",
              "description": "Two-phase strategy: Execute SQL and generate report",
              "version": "1.0.0",
              "status": "active"
            },
            {
              "template_id": "sql_query_doc_context_v1",
              "display_name": "SQL Query Template - Document Context",
              "description": "Three-phase strategy with document retrieval",
              "version": "1.0.0",
              "status": "active"
            }
          ]
        }
        ```

#### 3.6A.2. Get Template Plugin Info

Get detailed configuration for a specific template including manifest and UI field definitions.

* **Endpoint**: `GET /v1/rag/templates/{template_id}/plugin-info`
* **Method**: `GET`
* **URL Parameters**:
    * `template_id` (string, required): The template identifier (e.g., `sql_query_v1`)
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "template_id": "sql_query_v1",
          "plugin_info": {
            "name": "sql-query-basic",
            "version": "1.0.0",
            "display_name": "SQL Query Template - Business Context",
            "description": "Two-phase strategy...",
            "population_modes": {
              "manual": {
                "enabled": true,
                "input_variables": {
                  "database_name": {
                    "required": true,
                    "type": "string",
                    "description": "Target database name"
                  }
                }
              },
              "auto_generate": {
                "enabled": true,
                "input_variables": {
                  "context_topic": {
                    "required": true,
                    "type": "string",
                    "description": "Business context for generation"
                  },
                  "num_examples": {
                    "required": true,
                    "type": "integer",
                    "default": 5,
                    "min": 1,
                    "max": 1000,
                    "description": "Number of question/SQL pairs to generate"
                  }
                }
              }
            }
          }
        }
        ```

#### 3.6A.3. Generate Questions (LLM-Assisted)

Generate question/SQL pairs using LLM based on schema context and business requirements.

* **Endpoint**: `POST /v1/rag/generate-questions`
* **Method**: `POST`
* **Body**:
    ```json
    {
      "template_id": "sql_query_v1",
      "execution_context": "CREATE TABLE customers (id INT, name VARCHAR(100), email VARCHAR(100), status VARCHAR(20));\nCREATE TABLE orders (id INT, customer_id INT, total DECIMAL(10,2), created_at TIMESTAMP);",
      "subject": "Customer analytics and order reporting",
      "count": 10,
      "database_name": "sales_db"
    }
    ```
    * `template_id`: Template to use for generation
    * `execution_context`: Database schema information (from HELP TABLE, DESCRIBE, etc.)
    * `subject`: Business context topic for question generation
    * `count`: Number of question/SQL pairs to generate (1-1000)
    * `database_name`: Target database name
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "questions": [
            {
              "user_query": "Show all active customers",
              "sql_statement": "SELECT * FROM sales_db.customers WHERE status = 'active';"
            },
            {
              "user_query": "Count total orders by customer",
              "sql_statement": "SELECT customer_id, COUNT(*) as order_count FROM sales_db.orders GROUP BY customer_id;"
            }
          ],
          "input_tokens": 1234,
          "output_tokens": 567
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (invalid parameters)
    * **Code**: `500 Internal Server Error` (LLM generation failed)

#### 3.6A.4. Populate Collection from Template

Populate a RAG collection with generated or manual examples using a template.

* **Endpoint**: `POST /v1/rag/collections/{collection_id}/populate`
* **Method**: `POST`
* **URL Parameters**:
    * `collection_id` (integer, required): The collection ID
* **Body**:
    ```json
    {
      "template_type": "sql_query",
      "examples": [
        {
          "user_query": "Show all active customers",
          "sql_statement": "SELECT * FROM sales_db.customers WHERE status = 'active';"
        },
        {
          "user_query": "Count total orders",
          "sql_statement": "SELECT COUNT(*) FROM sales_db.orders;"
        }
      ],
      "database_name": "sales_db",
      "mcp_tool_name": "base_readQuery"
    }
    ```
    * `template_type`: Currently only `"sql_query"` supported
    * `examples`: Array of question/SQL pairs
    * `database_name`: Optional database context
    * `mcp_tool_name`: Optional MCP tool override (default: `base_readQuery`)
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Successfully populated 2 cases",
          "results": {
            "total_examples": 2,
            "successful": 2,
            "failed": 0,
            "case_ids": [
              "abc123-def456-ghi789",
              "xyz789-uvw456-rst123"
            ],
            "errors": []
          }
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (validation errors)
        ```json
        {
          "status": "error",
          "message": "Validation failed for some examples",
          "validation_issues": [
            {
              "example_index": 0,
              "field": "sql_statement",
              "issue": "SQL statement is empty or invalid"
            }
          ]
        }
        ```
    * **Code**: `404 Not Found` (collection not found)
    * **Code**: `500 Internal Server Error` (population failed)

### 3.7. MCP Server Management

#### 3.7.1. Get All MCP Servers

Get all configured MCP servers and the active server ID.

* **Endpoint**: `GET /v1/mcp/servers`
* **Method**: `GET`
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "servers": [
            {
              "id": "prod_server",
              "name": "Production Server",
              "host": "localhost",
              "port": 8001,
              "path": "/mcp"
            }
          ],
          "active_server_id": "prod_server"
        }
        ```

#### 3.7.2. Create MCP Server

Create a new MCP server configuration.

* **Endpoint**: `POST /v1/mcp/servers`
* **Method**: `POST`
* **Body**:
    ```json
    {
      "id": "dev_server",
      "name": "Development Server",
      "host": "localhost",
      "port": 8002,
      "path": "/mcp"
    }
    ```
* **Success Response**:
    * **Code**: `201 Created`
* **Error Response**:
    * **Code**: `400 Bad Request` (missing required fields)

#### 3.7.3. Update MCP Server

Update an existing MCP server configuration.

* **Endpoint**: `PUT /v1/mcp/servers/{server_id}`
* **Method**: `PUT`
* **URL Parameters**:
    * `server_id` (string, required): The server ID
* **Body**:
    ```json
    {
      "name": "Updated Name",
      "host": "newhost",
      "port": 8003
    }
    ```
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `404 Not Found`

#### 3.7.4. Delete MCP Server

Delete an MCP server configuration. Fails if any RAG collections are assigned to it.

* **Endpoint**: `DELETE /v1/mcp/servers/{server_id}`
* **Method**: `DELETE`
* **URL Parameters**:
    * `server_id` (string, required): The server ID
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `400 Bad Request` (if collections are assigned to this server)

#### 3.7.5. Activate MCP Server

Set an MCP server as the active server for the application.

* **Endpoint**: `POST /v1/mcp/servers/{server_id}/activate`
* **Method**: `POST`
* **URL Parameters**:
    * `server_id` (string, required): The server ID
* **Success Response**:
    * **Code**: `200 OK`
* **Error Response**:
    * **Code**: `404 Not Found`

### 3.8. Session Analytics and Management

#### 3.8.1. Get Session Analytics

Get comprehensive analytics across all sessions for the execution dashboard.

* **Endpoint**: `GET /v1/sessions/analytics`
* **Method**: `GET`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "total_sessions": 42,
          "total_tokens": {
            "input": 125000,
            "output": 85000,
            "total": 210000
          },
          "success_rate": 87.5,
          "estimated_cost": 2.10,
          "model_distribution": {
            "gemini-1.5-flash": 60.0,
            "gpt-4": 40.0
          },
          "top_champions": [
            {
              "query": "What databases are available?",
              "tokens": 320,
              "case_id": "abc-123"
            }
          ],
          "velocity_data": [
            {"hour": "2025-11-19 10:00", "count": 5}
          ]
        }
        ```

#### 3.8.2. Get Sessions List

Get a filtered and sorted list of all sessions.

* **Endpoint**: `GET /v1/sessions`
* **Method**: `GET`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **Query Parameters**:
    * `search` (string, optional): Search query to filter sessions
    * `sort` (string, optional): Sort order - `recent`, `oldest`, `tokens`, `turns` (default: `recent`)
    * `filter_status` (string, optional): Filter by status - `all`, `success`, `partial`, `failed` (default: `all`)
    * `filter_model` (string, optional): Filter by model name (default: `all`)
    * `limit` (integer, optional): Maximum number of results (default: 100)
    * `offset` (integer, optional): Pagination offset (default: 0)
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "sessions": [
            {
              "id": "session-uuid",
              "name": "Data Analysis Session",
              "created_at": "2025-11-19T10:00:00Z",
              "last_updated": "2025-11-19T10:15:00Z",
              "provider": "Google",
              "model": "gemini-1.5-flash",
              "input_tokens": 5000,
              "output_tokens": 3000,
              "turn_count": 3,
              "status": "success"
            }
          ],
          "total": 42
        }
        ```

#### 3.8.3. Get Session Details

Get complete details for a specific session including timeline and RAG associations.

* **Endpoint**: `GET /v1/sessions/{session_id}/details`
* **Method**: `GET`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `session_id` (string, required): The session UUID
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**: Complete session data including `workflow_history`, `execution_trace`, and `rag_cases`
* **Error Response**:
    * **Code**: `404 Not Found`

## 4. The Task Object

The Task Object is the central data structure for monitoring a query. It is returned by the `GET /v1/tasks/{task_id}` endpoint.

### 4.1. Structure

```json
{
  "task_id": "string",
  "status": "string",
  "last_updated": "string (ISO 8601 UTC)",
  "events": [
    {
      "timestamp": "string (ISO 8601 UTC)",
      "event_data": { ... },
      "event_type": "string"
    }
  ],
  "intermediate_data": [
    {
      "tool_name": "string",
      "data": [ ... ]
    }
  ],
  "result": { ... }
}
```

### 4.2. Fields

* `task_id`: The unique ID of the task.
* `status`: The current state of the task (`pending`, `processing`, `complete`, `error`, `cancelled`, `cancelling`).
* `last_updated`: The UTC timestamp of the last update to this task object.
* `events`: A chronological log of events from the agent's execution process.
* `intermediate_data`: A list of successful data results from tool calls as they are generated.
* `result`: The final, structured output from the agent. This field is `null` until the `status` is `complete` or `error`. If the status is `cancelled`, it might contain a cancellation message.

### 4.3. Event Types

The `event_data` object within the `events` list provides insight into the agent's internal state. The `event_type` key indicates the nature of the event.

| Event Type       | Description                                                 |
| ---------------- | ----------------------------------------------------------- |
| `plan_generated` | A strategic plan has been created or revised.               |
| `phase_start`    | The agent is beginning a new phase of its plan.             |
| `tool_result`    | A tool was executed.                                        |
| `token_update`   | Tokens were consumed in a call to the LLM.                  |
| `workaround`     | The agent performed a self-correction or optimization.      |
| `cancelled`      | The execution was stopped, usually due to user request.     |
| `error`          | A general or unrecoverable error occurred during execution. |

### 4.4. The Result Object

When a task is `complete`, the `result` field will be populated with the final structured data from the agent, conforming to either the `CanonicalResponse` or `PromptReportResponse` schema.

* **`CanonicalResponse`**: For standard, ad-hoc queries.
    ```json
    {
      "direct_answer": "string",
      "key_metric": { "value": "string", "label": "string" } | null,
      "key_observations": [ { "text": "string" } ],
      "synthesis": [ { "text": "string" } ]
    }
    ```
* **`PromptReportResponse`**: For queries initiated via a pre-defined prompt.
    ```json
    {
      "title": "string",
      "executive_summary": "string",
      "report_sections": [
        { "title": "string", "content": "string (Markdown)" }
      ]
    }
    ```

## 5. Configuration

**IMPORTANT**: Before creating a session or submitting a query, you must first configure the application. This can be done programmatically via the REST API or manually through the web interface.

### Method 1: REST API (Recommended for Automation)

Send a `POST` request to the `/api/v1/configure` endpoint with the appropriate credentials and server details. See section **3.1 Configure Application** for the full request structure. Once you receive a successful response, the API is ready for use.

### Method 2: Web UI (for Manual Setup)

1. Start the application server.
2. Open a web browser and navigate to the application's URL (e.g., `http://127.0.0.1:5000`).
3. Click on the **Config** tab.
4. Enter and validate your LLM provider credentials and MCP server details.
5. Once the UI shows a "Successfully configured" message, the REST API is ready to accept requests.

## 6. Full Workflow Example (cURL)

**Note on `X-TDA-User-UUID`**: Most API calls require an `X-TDA-User-UUID` header. The provided example scripts (`rest_run_query.sh`, `rest_check_status.sh`, `rest_stop_task.sh`) now require you to provide the User UUID as a command-line argument. You can get your User UUID from the application's configuration screen. When using `curl` directly, you will need to manually include this header with a generated UUID (e.g., `curl -H "X-TDA-User-UUID: <your-user-uuid>" ...`).

**Note on `--verbose` mode**: The `rest_run_query.sh` and `rest_check_status.sh` scripts support a `--verbose` flag. By default (without `--verbose`), these scripts will output only the final JSON result to `stdout`, redirecting all informational and progress messages to `stderr`. If you wish to see all messages on `stdout`, include the `--verbose` flag when running the scripts.

**1. Configure the Application (Run this first!)**

Use the `rest_config.sh` script with one of the sample configuration files from `docs/RestAPI/scripts/sample_configs/`.

For example, to configure with Google:
```bash
./rest_config.sh scripts/sample_configs/config_google.json
```

Alternatively, you can use `curl` directly with your custom configuration:
```bash
curl -X POST http://127.0.0.1:5000/api/v1/configure \
     -H "Content-Type: application/json" \
     -d '{
           "provider": "YOUR_PROVIDER",
           "model": "YOUR_MODEL",
           "credentials": { "apiKey": "YOUR_API_KEY" },
           "mcp_server": {
             "name": "dev_server",
             "host": "localhost",
             "port": 8001,
             "path": "/mcp"
           }
         }'
```

**2. Get your User UUID**

Before creating a session, you need your User UUID. You can find this in the application's web UI under **Config -> Optional Services -> REST UserID**.

**3. Create a Session**

```bash
# Replace <YOUR_USER_UUID> with the UUID from the UI
SESSION_ID=$(curl -s -X POST -H "X-TDA-User-UUID: <YOUR_USER_UUID>" http://127.0.0.1:5000/api/v1/sessions | jq -r .session_id)
echo "Created Session: $SESSION_ID"
```

**4. Submit a Query**

Use the `rest_run_query.sh` script. You can either create a new session or use an existing one.

**To create a new session:**
```bash
./rest_run_query.sh <YOUR_USER_UUID> "What is the business description for the DEMO_DB database?"
```

**To use an existing session:**
```bash
./rest_run_query.sh <YOUR_USER_UUID> "What is the business description for the DEMO_DB database?" --session-id <YOUR_SESSION_ID>
```

**5. Poll for the Result**

Use the `rest_check_status.sh` script, providing the `TASK_URL` and your `USER_UUID`.

```bash
./rest_check_status.sh "$TASK_URL" "<YOUR_USER_UUID>"
```

**(Optional) 6. Cancel the Task**

Use the `rest_stop_task.sh` script with the `TASK_ID` and your `USER_UUID`.

```bash
./rest_stop_task.sh "$TASK_ID" "<YOUR_USER_UUID>"
```

## 7. Troubleshooting

### "Created Session: null"

* **Symptom**: When running the "Create a Session" cURL command, the output is `Created Session: null`.
* **Cause**: This occurs because the application has not yet been configured with valid LLM and MCP credentials. The API returns an error message, and the `jq` command cannot find a `session_id` field in the error, so it outputs `null`.
* **Solution**: Follow the steps in the **Configuration** section. Use either the REST API (`POST /api/v1/configure`) or the web UI to configure the application. Once the configuration is successful, the command will work as expected.