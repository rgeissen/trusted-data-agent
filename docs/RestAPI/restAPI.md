# Trusted Data Agent REST API Documentation

## 1. Introduction

Welcome to the Trusted Data Agent (TDA) REST API. This API provides a programmatic interface to interact with the agent's powerful data analysis and querying capabilities.

The API is designed around an **asynchronous task-based architecture**. This pattern is ideal for handling potentially long-running agent processes in a robust and scalable way. Instead of holding a connection open while the agent works, you initiate a task and then poll a status endpoint to get progress updates and the final result. You can also cancel a running task if needed.

This document provides a comprehensive guide to all available endpoints and data models.

## 2. Authentication

Most endpoints in the Trusted Data Agent REST API (v1) now require a `X-TDA-User-UUID` header for authentication and user identification. This UUID is a unique identifier generated by the client (e.g., by the provided example scripts) and is used to associate sessions and tasks with a specific user.

*   **`X-TDA-User-UUID`**: A client-generated UUID (e.g., `a1b2c3d4-e5f6-7890-1234-567890abcdef`) that must be included in the headers of most requests. This allows the API to manage user-specific sessions and tasks.

The `/v1/configure` endpoint is an exception and does not require this header, as it deals with global application configuration. Future versions may introduce more robust API key or OAuth-based authentication.

## 3. API Endpoints

The base URL for all endpoints is `/api`.

### 3.1. Configure Application

**Note:** Exemplary configuration files for all supported providers can be found in the `docs/RestAPI/scripts/sample_configs` directory. These files can be used as a starting point for your own configurations.

Initializes and validates the agent's core services, including the LLM provider and the MCP server connection. This is the first step required before creating sessions or submitting queries.

* **Endpoint**: `POST /v1/configure`
* **Method**: `POST`
* **Body**:
    A JSON object containing the full configuration. The structure varies slightly by provider.

    **For Google, Anthropic, OpenAI:**
    ```json
    {
      "provider": "Google",
      "model": "gemini-1.5-flash-latest",
      "credentials": {
        "apiKey": "YOUR_API_KEY"
      },
      "mcp_server": {
        "name": "my_mcp_server",
        "host": "localhost",
        "port": 8001,
        "path": "/mcp"
      }
    }
    ```

    **For Friendli:**
    ```json
    {
      "provider": "Friendli",
      "model": "google/gemma-3-27b-it",
      "credentials": {
        "apiKey": "YOUR_FRIENDLI_API_KEY",
        "friendli_endpoint_url": "YOUR_FRIENDLI_ENDPOINT_URL" 
      },
      "mcp_server": { ... }
    }
    ```

    **For Amazon Bedrock:**
    ```json
    {
      "provider": "Amazon",
      "model": "amazon.titan-text-express-v1",
      "credentials": {
        "aws_access_key_id": "YOUR_AWS_ACCESS_KEY",
        "aws_secret_access_key": "YOUR_AWS_SECRET_KEY",
        "aws_region": "us-east-1"
      },
      "mcp_server": { ... }
    }
    ```

    **For Ollama:**
    ```json
    {
      "provider": "Ollama",
      "model": "llama2",
      "credentials": {
        "ollama_host": "http://localhost:11434"
      },
      "mcp_server": { ... }
    }
    ```

* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "MCP Server 'my_mcp_server' and LLM configured successfully."
        }
        ```
* **Error Response**:
    * **Code**: `400 Bad Request` (e.g., if configuration fails validation)
    * **Content**:
        ```json
        {
          "status": "error",
          "message": "Configuration failed: Authentication failed. Please check your API keys or credentials."
        }
        ```

### 3.2. Create a New Session

Creates a new, isolated conversation session for the agent. A session stores context and history for subsequent queries.

* **Endpoint**: `POST /v1/sessions`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **Body**: None
* **Success Response**:
    * **Code**: `201 Created`
    * **Content**:
        ```json
        {
          "session_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
        }
        ```
* **Error Response**:
    * **Code**: `503 Service Unavailable` (if services are not configured via `/v1/configure`)
    * **Content**:
        ```json
        {
          "error": "Application is not configured. Please connect to LLM and MCP services first."
        }
        ```

### 3.3. Submit a Query

Submits a natural language query to a specific session. This initiates a background task for the agent to process the query.

* **Endpoint**: `POST /v1/sessions/{session_id}/query`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `session_id` (string, required): The unique identifier for the session, obtained from the "Create a New Session" endpoint.
* **Body**:
    ```json
    {
      "prompt": "Your natural language query for the agent."
    }
    ```
* **Success Response**:
    * **Code**: `202 Accepted`
    * **Content**:
        ```json
        {
          "task_id": "task-9876-5432-1098-7654",
          "status_url": "/api/v1/tasks/task-9876-5432-1098-7654"
        }
        ```
* **Error Responses**:
    * **Code**: `404 Not Found` (if `session_id` is invalid)
    * **Code**: `400 Bad Request` (if the `prompt` field is missing from the request body)

### 3.4. Get Task Status and Result

Polls for the status of a background task. This endpoint provides real-time progress updates through an event log and delivers the final result when the task is complete.

* **Endpoint**: `GET /v1/tasks/{task_id}`
* **Method**: `GET`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `task_id` (string, required): The unique identifier for the task, obtained from the "Submit a Query" endpoint.
* **Success Responses**:
    * **Code**: `200 OK`
    * See section **4. The Task Object** for detailed response content.
* **Error Response**:
    * **Code**: `404 Not Found` (if `task_id` is invalid)

### 3.5. Cancel Task Execution

Requests cancellation of an actively running background task.

* **Endpoint**: `POST /v1/tasks/{task_id}/cancel`
* **Method**: `POST`
* **Headers**:
    * `X-TDA-User-UUID` (string, required): The unique identifier for the user.
* **URL Parameters**:
    * `task_id` (string, required): The unique identifier for the task to cancel.
* **Body**: None
* **Success Response**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "success",
          "message": "Cancellation request sent."
        }
        ```
* **Informational Response (Task Already Done)**:
    * **Code**: `200 OK`
    * **Content**:
        ```json
        {
          "status": "info",
          "message": "Task already completed."
        }
        ```
* **Error Response**:
    * **Code**: `404 Not Found` (if `task_id` does not correspond to an active or recently completed task)
    * **Content**:
        ```json
        {
          "status": "error",
          "message": "No active task found for this task ID."
        }
        ```

## 4. The Task Object

The Task Object is the central data structure for monitoring a query. It is returned by the `GET /v1/tasks/{task_id}` endpoint.

### 4.1. Structure

```json
{
  "task_id": "string",
  "status": "string",
  "last_updated": "string (ISO 8601 UTC)",
  "events": [
    {
      "timestamp": "string (ISO 8601 UTC)",
      "event_data": { ... },
      "event_type": "string"
    }
  ],
  "intermediate_data": [
    {
      "tool_name": "string",
      "data": [ ... ]
    }
  ],
  "result": { ... }
}
```

### 4.2. Fields

* `task_id`: The unique ID of the task.
* `status`: The current state of the task (`pending`, `processing`, `complete`, `error`, `cancelled`, `cancelling`).
* `last_updated`: The UTC timestamp of the last update to this task object.
* `events`: A chronological log of events from the agent's execution process.
* `intermediate_data`: A list of successful data results from tool calls as they are generated.
* `result`: The final, structured output from the agent. This field is `null` until the `status` is `complete` or `error`. If the status is `cancelled`, it might contain a cancellation message.

### 4.3. Event Types

The `event_data` object within the `events` list provides insight into the agent's internal state. The `event_type` key indicates the nature of the event.

| Event Type       | Description                                                 |
| ---------------- | ----------------------------------------------------------- |
| `plan_generated` | A strategic plan has been created or revised.               |
| `phase_start`    | The agent is beginning a new phase of its plan.             |
| `tool_result`    | A tool was executed.                                        |
| `token_update`   | Tokens were consumed in a call to the LLM.                  |
| `workaround`     | The agent performed a self-correction or optimization.      |
| `cancelled`      | The execution was stopped, usually due to user request.     |
| `error`          | A general or unrecoverable error occurred during execution. |

### 4.4. The Result Object

When a task is `complete`, the `result` field will be populated with the final structured data from the agent, conforming to either the `CanonicalResponse` or `PromptReportResponse` schema.

* **`CanonicalResponse`**: For standard, ad-hoc queries.
    ```json
    {
      "direct_answer": "string",
      "key_metric": { "value": "string", "label": "string" } | null,
      "key_observations": [ { "text": "string" } ],
      "synthesis": [ { "text": "string" } ]
    }
    ```
* **`PromptReportResponse`**: For queries initiated via a pre-defined prompt.
    ```json
    {
      "title": "string",
      "executive_summary": "string",
      "report_sections": [
        { "title": "string", "content": "string (Markdown)" }
      ]
    }
    ```

## 5. Configuration

**IMPORTANT**: Before creating a session or submitting a query, you must first configure the application. This can be done programmatically via the REST API or manually through the web interface.

### Method 1: REST API (Recommended for Automation)

Send a `POST` request to the `/api/v1/configure` endpoint with the appropriate credentials and server details. See section **3.1 Configure Application** for the full request structure. Once you receive a successful response, the API is ready for use.

### Method 2: Web UI (for Manual Setup)

1. Start the application server.
2. Open a web browser and navigate to the application's URL (e.g., `http://127.0.0.1:5000`).
3. Click on the **Config** tab.
4. Enter and validate your LLM provider credentials and MCP server details.
5. Once the UI shows a "Successfully configured" message, the REST API is ready to accept requests.

## 6. Full Workflow Example (cURL)

**Note on `X-TDA-User-UUID`**: Most API calls require an `X-TDA-User-UUID` header. The provided example scripts (`rest_run_query.sh`, `rest_check_status.sh`, `rest_stop_task.sh`) now require you to provide the User UUID as a command-line argument. You can get your User UUID from the application's configuration screen. When using `curl` directly, you will need to manually include this header with a generated UUID (e.g., `curl -H "X-TDA-User-UUID: <your-user-uuid>" ...`).

**Note on `--verbose` mode**: The `rest_run_query.sh` and `rest_check_status.sh` scripts support a `--verbose` flag. By default (without `--verbose`), these scripts will output only the final JSON result to `stdout`, redirecting all informational and progress messages to `stderr`. If you wish to see all messages on `stdout`, include the `--verbose` flag when running the scripts.

**1. Configure the Application (Run this first!)**

Use the `rest_config.sh` script with one of the sample configuration files from `docs/RestAPI/scripts/sample_configs/`.

For example, to configure with Google:
```bash
./rest_config.sh scripts/sample_configs/config_google.json
```

Alternatively, you can use `curl` directly with your custom configuration:
```bash
curl -X POST http://127.0.0.1:5000/api/v1/configure \
     -H "Content-Type: application/json" \
     -d '{
           "provider": "YOUR_PROVIDER",
           "model": "YOUR_MODEL",
           "credentials": { "apiKey": "YOUR_API_KEY" },
           "mcp_server": {
             "name": "dev_server",
             "host": "localhost",
             "port": 8001,
             "path": "/mcp"
           }
         }'
```

**2. Get your User UUID**

Before creating a session, you need your User UUID. You can find this in the application's web UI under **Config -> Optional Services -> REST UserID**.

**3. Create a Session**

```bash
# Replace <YOUR_USER_UUID> with the UUID from the UI
SESSION_ID=$(curl -s -X POST -H "X-TDA-User-UUID: <YOUR_USER_UUID>" http://127.0.0.1:5000/api/v1/sessions | jq -r .session_id)
echo "Created Session: $SESSION_ID"
```

**4. Submit a Query**

Use the `rest_run_query.sh` script. You can either create a new session or use an existing one.

**To create a new session:**
```bash
./rest_run_query.sh <YOUR_USER_UUID> "What is the business description for the DEMO_DB database?"
```

**To use an existing session:**
```bash
./rest_run_query.sh <YOUR_USER_UUID> "What is the business description for the DEMO_DB database?" --session-id <YOUR_SESSION_ID>
```

**5. Poll for the Result**

Use the `rest_check_status.sh` script, providing the `TASK_URL` and your `USER_UUID`.

```bash
./rest_check_status.sh "$TASK_URL" "<YOUR_USER_UUID>"
```

**(Optional) 6. Cancel the Task**

Use the `rest_stop_task.sh` script with the `TASK_ID` and your `USER_UUID`.

```bash
./rest_stop_task.sh "$TASK_ID" "<YOUR_USER_UUID>"
```

## 7. Troubleshooting

### "Created Session: null"

* **Symptom**: When running the "Create a Session" cURL command, the output is `Created Session: null`.
* **Cause**: This occurs because the application has not yet been configured with valid LLM and MCP credentials. The API returns an error message, and the `jq` command cannot find a `session_id` field in the error, so it outputs `null`.
* **Solution**: Follow the steps in the **Configuration** section. Use either the REST API (`POST /api/v1/configure`) or the web UI to configure the application. Once the configuration is successful, the command will work as expected.